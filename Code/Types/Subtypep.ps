%!PS-Adobe-3.0%%Title: (DOE-NNsubtypep.text)%%Creator: (Microsoft Word: LaserWriter 8 8.2)%%CreationDate: (3:15 PM Tuesday, December 6, 1994)%%For: (Henry Baker)%%Pages: 23%%DocumentFonts: Times-Italic Symbol Times-Roman Times-Bold Courier-Bold Courier Courier-Oblique%%DocumentNeededFonts: Times-Italic Symbol Times-Roman Times-Bold Courier-Bold Courier Courier-Oblique%%DocumentSuppliedFonts:%%DocumentData: Clean7Bit%%PageOrder: Ascend%%Orientation: Portrait%%DocumentMedia: Default 612 792 0 () ()%ADO_ImageableArea: 31 31 583 761%%EndCommentsuserdict begin/dscInfo 5 dict dup begin/Title(DOE-NNsubtypep.text)def/Creator(Microsoft Word: LaserWriter 8 8.2)def/CreationDate(3:15 PM Tuesday, December 6, 1994)def/For(Henry Baker)def/Pages 1 defend def endsave /version23-manualfeedpatch where { pop false } { true }ifelse % we don't do an explicit 'get' since product and version MAY % be in systemdict or statusdict - this technique gets the lookup % without failurestatusdict begin  product (LaserWriter) eq        % true if LaserWriter  version cvr 23.0 eq             % true if version 23endand  % only install this patch if both are trueand  % true only if patch is not installed and is for this printer     % save object and boolean on stackdup { exch restore }if% either true OR saveobject falsedup{  /version23-manualfeedpatch true def  /oldversion23-showpage /showpage load def  /showpage       % this showpage will wait extra time if manualfeed is true  {%     statusdict /manualfeed known     {% manualfeed known in statusdict        statusdict /manualfeed get        {% if true then we loop for 5 seconds           usertime 5000 add       % target usertime           { % loop             dup usertime sub 0 lt             { exit }if           }loop           pop             % pop the usertime off the stac        }if     }if     oldversion23-showpage  }bind def}ifnot{ restore }if/md 192 dict def md begin/currentpacking where {pop /sc_oldpacking currentpacking def true setpacking}if%%BeginFile: adobe_psp_basic%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./bd{bind def}bind def/xdf{exch def}bd/xs{exch store}bd/ld{load def}bd/Z{0 def}bd/T/true/F/false/:L/lineto/lw/setlinewidth/:M/moveto/rl/rlineto/rm/rmoveto/:C/curveto/:T/translate/:K/closepath/:mf/makefont/gS/gsave/gR/grestore/np/newpath14{ld}repeat/$m matrix def/av 81 def/por true def/normland false def/psb-nosave{}bd/pse-nosave{}bd/us Z/psb{/us save store}bd/pse{us restore}bd/level2/languagelevel where{pop languagelevel 2 ge}{false}ifelsedef/featurecleanup{stoppedcleartomarkcountdictstack exch sub dup 0 gt{{end}repeat}{pop}ifelse}bd/noload Z/startnoload{{/noload save store}if}bd/endnoload{{noload restore}if}bdlevel2 startnoload/setjob{statusdict/jobname 3 -1 roll put}bd/setcopies{userdict/#copies 3 -1 roll put}bdlevel2 endnoload level2 not startnoload/setjob{1 dict begin/JobName xdf currentdict end setuserparams}bd/setcopies{1 dict begin/NumCopies xdf currentdict end setpagedevice}bdlevel2 not endnoload/pm Z/mT Z/sD Z/realshowpage Z/initializepage{/pm save store mT concat}bd/endp{pm restore showpage}def/$c/DeviceRGB def/rectclip where{pop/rC/rectclip ld}{/rC{np 4 2 roll:M1 index 0 rl0 exch rlneg 0 rl:Kclip np}bd}ifelse/rectfill where{pop/rF/rectfill ld}{/rF{gSnp4 2 roll:M1 index 0 rl0 exch rlneg 0 rlfillgR}bd}ifelse/rectstroke where{pop/rS/rectstroke ld}{/rS{gSnp4 2 roll:M1 index 0 rl0 exch rlneg 0 rl:KstrokegR}bd}ifelse%%EndFile%%BeginFile: adobe_psp_colorspace_level1%%Copyright: Copyright 1991-1993 Adobe Systems Incorporated. All Rights Reserved./G/setgray ld/:F/setrgbcolor ld%%EndFile%%BeginFile: adobe_psp_uniform_graphics%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./@a{np :M 0 rl :L 0 exch rl 0 rl :L fill}bd/@b{np :M 0 rl 0 exch rl :L 0 rl 0 exch rl fill}bd/arct where{pop}{/arct{arcto pop pop pop pop}bd}ifelse/x1 Z/x2 Z/y1 Z/y2 Z/rad Z/@q{/rad xs/y2 xs/x2 xs/y1 xs/x1 xsnpx2 x1 add 2 div y1 :Mx2 y1 x2 y2 rad arctx2 y2 x1 y2 rad arctx1 y2 x1 y1 rad arctx1 y1 x2 y1 rad arctfill}bd/@s{/rad xs/y2 xs/x2 xs/y1 xs/x1 xsnpx2 x1 add 2 div y1 :Mx2 y1 x2 y2 rad arctx2 y2 x1 y2 rad arctx1 y2 x1 y1 rad arctx1 y1 x2 y1 rad arct:Kstroke}bd/@i{np 0 360 arc fill}bd/@j{gSnp:Tscale0 0 .5 0 360 arcfillgR}bd/@e{np0 360 arc:Kstroke}bd/@f{np$m currentmatrixpop:Tscale0 0 .5 0 360 arc:K$m setmatrixstroke}bd/@k{gSnp:T0 0 :M0 0 5 2 rollarc fillgR}bd/@l{gSnp:T0 0 :Mscale0 0 .5 5 -2 roll arcfillgR}bd/@m{nparcstroke}bd/@n{np$m currentmatrixpop:Tscale0 0 .5 5 -2 roll arc$m setmatrixstroke}bd%%EndFile%%BeginFile: adobe_psp_basic_text%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./S/show ld/A{0.0 exch ashow}bd/R{0.0 exch 32 exch widthshow}bd/W{0.0 3 1 roll widthshow}bd/J{0.0 32 4 2 roll 0.0 exch awidthshow}bd/V{0.0 4 1 roll 0.0 exch awidthshow}bd/fcflg true def/fc{fcflg{vmstatus exch sub 50000 lt{(%%[ Warning: Running out of memory ]%%\r)print flush/fcflg false store}if pop}if}bd/$f[1 0 0 -1 0 0]def/:ff{$f :mf}bd/MacEncoding StandardEncoding 256 array copy defMacEncoding 39/quotesingle putMacEncoding 96/grave put/Adieresis/Aring/Ccedilla/Eacute/Ntilde/Odieresis/Udieresis/aacute/agrave/acircumflex/adieresis/atilde/aring/ccedilla/eacute/egrave/ecircumflex/edieresis/iacute/igrave/icircumflex/idieresis/ntilde/oacute/ograve/ocircumflex/odieresis/otilde/uacute/ugrave/ucircumflex/udieresis/dagger/degree/cent/sterling/section/bullet/paragraph/germandbls/registered/copyright/trademark/acute/dieresis/notequal/AE/Oslash/infinity/plusminus/lessequal/greaterequal/yen/mu/partialdiff/summation/product/pi/integral/ordfeminine/ordmasculine/Omega/ae/oslash/questiondown/exclamdown/logicalnot/radical/florin/approxequal/Delta/guillemotleft/guillemotright/ellipsis/space/Agrave/Atilde/Otilde/OE/oe/endash/emdash/quotedblleft/quotedblright/quoteleft/quoteright/divide/lozenge/ydieresis/Ydieresis/fraction/currency/guilsinglleft/guilsinglright/fi/fl/daggerdbl/periodcentered/quotesinglbase/quotedblbase/perthousand/Acircumflex/Ecircumflex/Aacute/Edieresis/Egrave/Iacute/Icircumflex/Idieresis/Igrave/Oacute/Ocircumflex/apple/Ograve/Uacute/Ucircumflex/Ugrave/dotlessi/circumflex/tilde/macron/breve/dotaccent/ring/cedilla/hungarumlaut/ogonek/caronMacEncoding 128 128 getinterval astore poplevel2 startnoload/copyfontdict{findfont dup length dictbegin{1 index/FID ne{def}{pop pop}ifelse}forall}bdlevel2 endnoload level2 not startnoload/copyfontdict{findfont dup length dictcopybegin}bdlevel2 not endnoloadmd/fontname known not{/fontname/customfont def}if/Encoding Z/:mre{copyfontdict/Encoding MacEncoding deffontname currentdictenddefinefont :ff def}bd/:bsr{copyfontdict/Encoding Encoding 256 array copy defEncoding dup}bd/pd{put dup}bd/:esr{pop popfontname currentdictenddefinefont :ff def}bd/scf{scalefont def}bd/scf-non{$m scale :mf setfont}bd/ps Z/fz{/ps xs}bd/sf/setfont ld/cF/currentfont ld/mbf{/makeblendedfont where{popmakeblendedfont/ABlend exch definefont}{pop}ifelsedef}def%%EndFile%%BeginFile: adobe_psp_derived_styles%%Copyright: Copyright 1990-1993 Adobe Systems Incorporated. All Rights Reserved./wiversion(23.0)eq{{gS 0 0 0 0 rC stringwidth gR}bind}{/stringwidth load}ifelsedef/$o 1. def/gl{$o G}bd/ms{:M S}bd/condensedmtx[.82 0 0 1 0 0]def/:mc{condensedmtx :mf def}bd/extendedmtx[1.18 0 0 1 0 0]def/:me{extendedmtx :mf def}bd/basefont Z/basefonto Z/dxa Z/dxb Z/dxc Z/dxd Z/dsdx2 Z/bfproc Z/:fbase{dup/FontType get 0 eq{dup length dict begindup{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall/FDepVector exch/FDepVector get[exch/:fbase load forall]def}/bfproc load ifelse/customfont currentdict end definefont}bd/:mo{/bfproc{dup dup length 2 add dictbegin{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall/PaintType 2 def/StrokeWidth .012 0 FontMatrix idtransform pop def/customfont currentdictenddefinefont8 dict begin/basefonto xdf/basefont xdf/FontType 3 def/FontMatrix[1 0 0 1 0 0]def/FontBBox[0 0 1 1]def/Encoding StandardEncoding def/BuildChar{exch beginbasefont setfont( )dup 0 4 -1 roll putdup wisetcharwidth0 0 :MgSgldup showgRbasefonto setfontshowend}def}store :fbase}bd/:mso{/bfproc{7 dict begin/basefont xdf/FontType 3 def/FontMatrix[1 0 0 1 0 0]def/FontBBox[0 0 1 1]def/Encoding StandardEncoding def/BuildChar{exch beginsD begin/dxa 1 ps div defbasefont setfont( )dup 0 4 -1 roll putdup wi1 index 0 ne{exch dxa add exch}ifsetcharwidthdup 0 0 msdup dxa 0 msdup dxa dxa msdup 0 dxa msgldxa 2. div dup msendend}def}store :fbase}bd/:ms{/bfproc{dup dup length 2 add dictbegin{1 index/FID ne 2 index/UniqueID ne and{def}{pop pop}ifelse}forall/PaintType 2 def/StrokeWidth .012 0 FontMatrix idtransform pop def/customfont currentdictenddefinefont8 dict begin/basefonto xdf/basefont xdf/FontType 3 def/FontMatrix[1 0 0 1 0 0]def/FontBBox[0 0 1 1]def/Encoding StandardEncoding def/BuildChar{exch beginsD begin/dxb .05 defbasefont setfont( )dup 0 4 -1 roll putdup wiexch dup 0 ne{dxb add}ifexch setcharwidthdup dxb .01 add 0 ms0 dxb :TgSgldup 0 0 msgRbasefonto setfont0 0 msendend}def}store :fbase}bd/:mss{/bfproc{7 dict begin/basefont xdf/FontType 3 def/FontMatrix[1 0 0 1 0 0]def/FontBBox[0 0 1 1]def/Encoding StandardEncoding def/BuildChar{exch beginsD begin/dxc 1 ps div def/dsdx2 .05 dxc 2 div add defbasefont setfont( )dup 0 4 -1 roll putdup wiexch dup 0 ne{dsdx2 add}ifexch setcharwidthdup dsdx2 .01 add 0 ms0 .05 dxc 2 div sub :Tdup 0 0 msdup dxc 0 msdup dxc dxc msdup 0 dxc msgldxc 2 div dup msendend}def}store :fbase}bd/:msb{/bfproc{7 dict begin/basefont xdf/FontType 3 def/FontMatrix[1 0 0 1 0 0]def/FontBBox[0 0 1 1]def/Encoding StandardEncoding def/BuildChar{exch beginsD begin/dxd .03 defbasefont setfont( )dup 0 4 -1 roll putdup wi1 index 0 ne{exch dxd add exch}ifsetcharwidthdup 0 0 msdup dxd 0 msdup dxd dxd ms0 dxd msendend}def}store :fbase}bd/italicmtx[1 0 -.212557 1 0 0]def/:mi{italicmtx :mf def}bd/:v{[exch dup/FontMatrix get exchdup/FontInfo known{/FontInfo getdup/UnderlinePosition known{dup/UnderlinePosition get2 index 03 1 rolltransformexch pop}{.1}ifelse3 1 rolldup/UnderlineThickness known{/UnderlineThickness getexch 0 3 1 rolltransformexch popabs}{pop pop .067}ifelse}{pop pop .1 .067}ifelse]}bd/$t Z/$p Z/$s Z/:p{aload pop2 index mul/$t xs1 index mul/$p xs.012 mul/$s xs}bd/:m{gS0 $p rm$t lw0 rl strokegR}bd/:n{gS0 $p rm$t lw0 rlgSglstrokegRstrokepath$s lw/setstrokeadjust where{popcurrentstrokeadjust true setstrokeadjust stroke setstrokeadjust}{stroke}ifelsegR}bd/:o{gS0 $p rm$t 2 div dup rm$t lwdup 0 rlstrokegR:n}bd%%EndFile/currentpacking where {pop sc_oldpacking setpacking}if end%%EndProlog%%BeginSetupmd begincountdictstack[{%%BeginFeature: *ManualFeed Falsestatusdict /manualfeed false put%%EndFeature}featurecleanupcountdictstack[{%%BeginFeature: *InputSlot Cassette%%EndFeature}featurecleanupcountdictstack[{%%BeginFeature: *PageRegion LetterSmalllettersmall%%EndFeature}featurecleanup(Henry Baker)setjob/mT[1 0 0 -1 31 761]def/sD 16 dict def300 level2{1 dict dup/WaitTimeout 4 -1 roll put setuserparams}{statusdict/waittimeout 3 -1 roll put}ifelse%%IncludeFont: Times-Italic%%IncludeFont: Symbol%%IncludeFont: Times-Roman%%IncludeFont: Times-Bold%%IncludeFont: Courier-Bold%%IncludeFont: Courier%%IncludeFont: Courier-Oblique/f0_1/Times-Italic:mre/f0_12 f0_1 12 scf/f0_10 f0_1 10 scf/f1_1/Symbol:bsr240/apple pd:esr/f1_12 f1_1 12 scf/f1_10 f1_1 10 scf/f1_9 f1_1 9 scf/f2_1 f1_1:mi/f2_12 f2_1 12 scf/f3_1/Times-Roman:mre/f3_12 f3_1 12 scf/f3_10 f3_1 10 scf/f3_9 f3_1 9 scf/f4_1/Times-Bold:mre/f4_14 f4_1 14 scf/f4_12 f4_1 12 scf/f4_10 f4_1 10 scf/f5_1 f3_1:v def/f6_1 f0_1:v def/f7_1/Courier-Bold:mre/f7_14 f7_1 14 scf/f7_10 f7_1 10 scf/f8_1/Courier:mre/f8_12 f8_1 12 scf/f8_10 f8_1 10 scf/f9_1/Courier-Oblique:mre/f9_10 f9_1 10 scf/Courier findfont[10 0 0 -10 0 0]:mf setfont%%EndSetup%%Page: 1 1%%BeginPageSetupinitializepage(Henry Baker; page: 1 of 23)setjob%%EndPageSetupgS 0 0 552 730 rC41 18 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J41 722 :M-.093(\251 1989 Nimble Computer Corporation)A401 722 :M(1)S41 57 :Mf4_14 sf2.946 .295(A Decision Procedure for Common Lisp's )Jf7_14 sf.969(SUBTYPEP)Af4_14 sf3.659 .366( Predicate)J41 78 :Mf3_12 sf.214 .021(Henry G. Baker)J41 100 :Mf0_12 sf-.056(Nimble Computer Corporation, 16231 Meadow Ridge Way, Encino, California 91436)A41 112 :M1.241 .124(\(818\) 986-1436\312\312\(818\) 986-1360 \(FAX\))J41 127 :Mf3_9 sf.579 .058(This work was supported in part by the U.S. Department of Energy Contract No. DE-AC03-88ER80663.)J41 142 :Mf4_12 sf.337(Abstract)A41 158 :Mf0_12 sf.236 .024(Common Lisp)Jf3_12 sf.158 .016( [CL84,CL90] includes a dynamic datatype system of moderate complexity, as well)J41 170 :M.176 .018(as predicates for checking the types of language objects.  Additionally, an interesting predicate of)J41 182 :M-.018(two "type specifiers"\321)Af8_10 sf-.021(SUBTYPEP)Af3_12 sf-.017(\321is included in the language.  This )Af8_10 sf-.021(subtypep)Af3_12 sf-.017( predicate provides)A41 194 :M.203 .02(a mechanism with which to query the Common Lisp type system regarding containment relations)J41 206 :M1.554 .155(among the various built-in and user-defined types.  While )Jf8_10 sf.493(subtypep)Af3_12 sf1.235 .124( is rarely needed by an)J41 218 :M.273 .027(applications programmer, the efficiency of a Common Lisp implementation can depend critically)J41 230 :M.214 .021(upon the quality of its )Jf8_10 sf.088(subtypep)Af3_12 sf.273 .027( predicate: the run-time system typically calls upon )Jf8_10 sf.088(subtypep)Af3_12 sf.15 .015( to)J41 242 :M-.089(decide what sort of representations to use when making arrays; the compiler calls upon )Af8_10 sf-.11(subtypep)Af3_12 sf-.113( to)A41 254 :M-.063(interpret user )Af0_12 sf-.071(declarations)Af3_12 sf-.068(, on which efficient data representation and code generation decisions are)A41 266 :M.136(based.)A41 282 :M.234 .023(As might be expected due to the complexity of the Common Lisp type system, there may be type)J41 294 :M.655 .066(containment questions which cannot be decided.  In these cases )Jf8_10 sf.208(subtypep)Af3_12 sf.573 .057( is expected to return)J41 306 :M-.05("can't determine", in order to avoid giving an incorrect answer.  Unfortunately, most Common Lisp)A41 318 :M-.012(implementations have abused this license by answering "can't determine" in all but the most trivial)A41 330 :M.063 .006(cases.  )Jf0_12 sf.11 .011(In particular, most Common Lisp implementations of )Jf9_10 sf.031(SUBTYPEP)Af0_12 sf.076 .008( fail on the basic axioms of)J41 342 :M.505 .05(the Common Lisp type system itself )Jf3_12 sf.616 .062([CL84,p.33].  This situation is particularly embarrassing for)J41 354 :M1.618 .162(Lisp\321the premier "symbol processing language"\321in which the implementation of complex)J41 366 :M-.064(symbolic logical operations should be relatively easy.  Since )Af8_10 sf-.082(subtypep)Af3_12 sf-.072( was presumably included in)A41 378 :M1.066 .107(Common Lisp to answer the )Jf0_12 sf.33(hard)Af3_12 sf1.105 .11( cases of type containment, this "lazy evaluation" limits the)J41 390 :M-.083(usefulness of an important language feature.)A41 406 :M.103 .01(This paper shows how those type containment relations of Common Lisp which can be decided at)J41 418 :M.117 .012(all, can be decided simply and quickly by a decision procedure which can dramatically reduce the)J41 430 :M.293 .029(number of occurrences of the "can't determine" answer from )Jf8_10 sf.09(subtypep)Af3_12 sf.285 .029(.  This decision procedure)J41 442 :M(does )Sf0_12 sf(not)Sf3_12 sf.035 .004( require the conversion of a type specifier expression to conjunctive or disjunctive normal)J41 454 :M1.708 .171(form, and therefore does not incur the exponential explosion in space and time that such a)J41 466 :M-.056(conversion would entail.)A41 482 :M.994 .099(The lattice mechanism described here for deciding )Jf8_10 sf.292(subtypep)Af3_12 sf.738 .074( is also ideal for performing )Jf0_12 sf.324(type)A41 494 :M-.039(inference)Af3_12 sf-.038( [Baker90]; the particular implementation developed here, however, is specific to the type)A41 506 :M-.032(system of Common Lisp [Beer88].)A41 522 :M.247 .025(Categories and Subject Descriptors: Lisp, dynamic typing, compiler optimization, type inference,)J41 534 :M-.053(decision procedure.)A41 556 :Mf4_12 sf1.045(1.\312\312Introduction)A41 572 :Mf3_12 sf.565 .056(The Common Lisp functions )Jf8_10 sf.158(typep)Af3_12 sf.246 .025( and )Jf8_10 sf.158(subtypep)Af3_12 sf.466 .047( are the basic predicates of the Common Lisp)J41 584 :M1.132 .113(type system [CL84,p.72].  Loosely speaking, )Jf8_10 sf.323(\(typep\312x\312y\))Af3_12 sf.945 .095( poses the question of whether the)J41 596 :Mf0_12 sf(object)Sf3_12 sf( )Sf8_10 sf(x)Sf3_12 sf( is an )Sf0_12 sf(element)Sf3_12 sf( of the )Sf0_12 sf(type)Sf3_12 sf( )Sf8_10 sf(y)Sf3_12 sf(, while )Sf8_10 sf-.006(\(subtypep\312y\312z\))Af3_12 sf-.005( poses the question of whether the )Af0_12 sf(type)S41 608 :Mf8_10 sf(y)Sf3_12 sf-.02( is a )Af0_12 sf-.027(subset)Af3_12 sf-.022( of the )Af0_12 sf-.027(type)Af3_12 sf( )Sf8_10 sf(z)Sf3_12 sf-.025(.  While )Af8_10 sf-.032(typep)Af3_12 sf-.025( is heavily used to distinguish object types at run-time, and)A41 620 :M2.079 .208(indeed the common )Jf8_10 sf.613(typecase)Af3_12 sf2.204 .22( construct [CL84,p.118] depends upon )Jf8_10 sf.613(typep)Af3_12 sf.511 .051(, )Jf8_10 sf.613(subtypep)Af3_12 sf.937 .094( is)J41 632 :M-.053(considered by most Common Lisp applications programmers to be an obscure language function of)A41 644 :M1.481 .148(only theoretical interest.  However, if these programmers were aware that the quality of the)J41 656 :M1.889 .189(optimization of their programs depended critically on the quality of the implementation of)J41 668 :Mf8_10 sf.634(subtypep)Af3_12 sf2.065 .207(, they might take more notice.  For example, these programmers might become)J41 680 :M-.061(exasperated if a program with a variable declared as a )Af8_10 sf-.077(bit)Af3_12 sf-.06( \(taking on only the integer values 0 or 1\))Aendp%%Page: 2 2%%BeginPageSetupinitializepage(Henry Baker; page: 2 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(2)S72 81 :M.819 .082(actually runs )Jf0_12 sf.23(slower)Af3_12 sf.645 .065( than when the same variable is declared as a )Jf8_10 sf.259(fixnum)Af3_12 sf.728 .073( \(taking on any small)J72 93 :M1.006 .101(integer values\).  They would be similarly distressed by an implementation which gave them a)J72 105 :M.415 .042(general vector of type )Jf8_10 sf.145(\(array\312t\312\(*\)\))Af3_12 sf.314 .031(, when )Jf8_10 sf.145(make-array)Af3_12 sf.329 .033( was called with an )Jf8_10 sf.145(element-type)Af3_12 sf.262 .026( of)J72 117 :Mf8_10 sf.254(\(integer\3120\31263\))Af3_12 sf.801 .08(, even though the Lisp system was capable of providing specialized arrays of)J72 130 :M.936 .094(signed 8-bit integers.)Jf3_9 sf0 -3 rm.175(1)A0 3 rmf3_12 sf.669 .067(  These problems can both be traced to deficiencies in the particular Lisp)J72 142 :M-.012(system's implementation of )Af8_10 sf-.015(subtypep)Af3_12 sf(.)S72 158 :M1.748 .175(The problem that a Common Lisp implementation is typically trying to solve when calling)J72 170 :Mf8_10 sf.168(subtypep)Af3_12 sf.491 .049( is to determine the storage requirement for a given object, as specified by a Common)J72 182 :M-.061(Lisp type specifier expression.  The more accurate )Af8_10 sf-.077(subtypep)Af3_12 sf-.059( is, the smaller the storage required for)A72 194 :M-.075(the user's program, and the faster it can be as a result of manipulating more compact objects.)A72 210 :M.547 .055(Optimizing Common Lisp compilers also attempt to remove type checks from a user's program,)J72 222 :M.8 .08(whether they were inserted by the programmer, the expansion of a macro, or a code expansion)J72 234 :M.421 .042(during code generation.  Eliminating such type checking is essential to achieving high execution)J72 246 :M-.042(speed on modern RISC architectures.  If the compiler can prove, by calling )Af8_10 sf-.052(subtypep)Af3_12 sf-.041(, that the type)A72 258 :M-.086(check will always be satisfied, then the type check is redundant code, and can be eliminated without)A72 270 :M.439 .044(any ill effects.  Once again, the quality of the implementation is directly related to the quality of)J72 282 :Mf8_10 sf.119(subtypep)Af3_12 sf(.)S72 298 :M-.099(Many programmers from outside the Lisp community are accustomed to including type declarations)A72 310 :M.519 .052(in their programs, and start programming in Lisp by including complete type declarations.  This)J72 322 :M.069 .007(information can be valuable for the compiler, since compilers for non-Lisp architectures can often)J72 334 :M-.057(make use of declarations to improve execution speed.  Supplying the most specific declarations can)A72 346 :M2.964 .296(also be valuable for program maintenance, because such declarations provide excellent)J72 358 :M1.421 .142(documentation.  However, in many Common Lisp implementations this attention to detail is)J72 370 :M1.223 .122(penalized.  Highly specialized declarations may actually make programs run )Jf0_12 sf.309(slower)Af3_12 sf.892 .089( than less)J72 382 :M1.789 .179(specialized declarations, because poor implementations of )Jf8_10 sf.449(subtypep)Af3_12 sf1.148 .115( may not be capable of)J72 394 :M-.109(correctly interpreting the more complex type specifier expressions.)A72 410 :M.329 .033(Thus, a high-quality )Jf8_10 sf.101(subtypep)Af3_12 sf.347 .035( implementation is a prerequisite for a high-quality Common Lisp)J72 422 :M.185 .019(implementation, especially when the host processor is an architecture not well suited for dynamic)J72 434 :M.194 .019(typing.  Yet the level of )Jf8_10 sf.085(subtypep)Af3_12 sf.34 .034( implementation among current commercial Common Lisp's is)J72 446 :M.243 .024(not high.  Informal tests on various implementations showed problems ranging from ignorance\321)J72 458 :M2.452 .245(almost always returning "don't know"\321to inconsistency\321violating the transitivity of the)J72 470 :Mf8_10 sf.195(subtypep)Af3_12 sf.54 .054( relation.  However, even the best ones fail to decide the basic set of axioms covering)J72 482 :M.057 .006(Common Lisp datatypes [CL84,p.33].)J72 498 :M.673 .067(This paper gives a )Jf0_12 sf1.445 .144(decision procedure)Jf3_12 sf.35 .035( for )Jf8_10 sf.263(subtypep)Af3_12 sf.802 .08(, which will answer any question posed to)J72 510 :Mf8_10 sf-.065(subtypep)Af3_12 sf-.049( that does not include the )Af8_10 sf-.065(satisfies)Af3_12 sf-.049( clause.  This restriction is forced by the fact that the)A72 522 :M-.075(general solution to )Af8_10 sf-.097(subtypep)Af3_12 sf-.073( with the )Af8_10 sf-.097(satisfies)Af3_12 sf-.078( clause is recursively undecidable.)A72 538 :M.501 .05(We describe the datatypes of Common Lisp in section 2, describe the language of type specifier)J72 550 :M.218 .022(expressions in section 3, and discuss the possible meanings of Common Lisp datatypes in section)J72 562 :M.225 .022(4.  In section 5 and 6, we gain additional insight into the nature of the Common Lisp type system)J72 574 :M.077 .008(and )Jf8_10 sf.032(subtypep)Af3_12 sf.081 .008( by showing where an )Jf0_12 sf.107 .011(ad hoc)Jf3_12 sf.091 .009( approach to deciding )Jf8_10 sf.032(subtypep)Af3_12 sf.079 .008( fails, and we see why)J-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 590.24 -.24 .24 215.24 590 .24 72 590 @a72 607 :Mf3_9 sf.216(1)Af3_12 sf0 3 rm.894 .089(The new function )J0 -3 rmf8_10 sf0 3 rm.288(upgraded-array-element-type)A0 -3 rmf3_12 sf0 3 rm.778 .078( is supposed to fix this problem, but only)J0 -3 rm72 622 :M.257 .026(succeeds in hiding the problem at a lower level.  Since this new function is required to be lattice-)J72 634 :M-.016(monotonic [CL90,67-68], and since the upgraded type of )Af8_10 sf-.019('bit)Af3_12 sf-.014( is required to be )Af8_10 sf-.019('bit)Af3_12 sf-.018( [CL90,p.33],)A72 646 :M-.028(we can use this function to test for the emptiness of an arbitrary type specifier\321a problem we later)A72 658 :M-.036(show to be equivalent to )Af8_10 sf-.045(subtypep)Af3_12 sf(.)S72 674 :Mf8_10 sf(\(defun type-null \(x\))S72 685 :M.006 .001(  \(values \(and \(eq 'bit \(upgraded-array-element-type `\(or bit ,x\)\)\))J72 696 :M(               \(not \(typep 0 x\)\))S72 707 :M(               \(not \(typep 1 x\)\)\))S72 718 :M(          t\)\))Sendp%%Page: 3 3%%BeginPageSetupinitializepage(Henry Baker; page: 3 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(3)S72 81 :M.914 .091(by considering other hard questions that could be decided by using )Jf8_10 sf.3(subtypep)Af3_12 sf.847 .085( as a subroutine.)J72 93 :M1.727 .173(Section 7 deals with the )Jf8_10 sf.66(subtypep)Af3_12 sf2.101 .21( decision procedure itself, while section 8 indicates its)J72 105 :M.006 .001(complexity.  Finally, section 9 discusses the sensitivity of the decision procedure to the particulars)J72 117 :M-.044(of the Common Lisp, and section 10 concludes.)A72 139 :Mf4_12 sf4.124 .412(2.\312\312Common Lisp data types)J72 155 :Mf3_12 sf-.086(Before we can decide the solution to the type containment problems of Common Lisp, we must first)A72 167 :M1.734 .173(understand its type system.  Common Lisp [CL90] has a moderately complex type system,)J72 179 :M.148 .015(including limited precision integers, unlimited precision integers, rational numbers, floating-point)J72 191 :M1.171 .117(numbers in four different formats, complex numbers of various types and sizes, characters of)J72 203 :M2.93 .293(considerable diversity, a host of specialized types such as )Jf8_10 sf.946(compiled-function)Af3_12 sf2.856 .286('s and)J72 215 :Mf8_10 sf.08(readtable)Af3_12 sf.243 .024('s, arrays of various ranks, sizes and element types, and user-defined )Jf8_10 sf.08(structure)Af3_12 sf.241 .024('s and)J72 227 :Mf8_10 sf.606(class)Af3_12 sf1.29 .129('es \()Jf0_12 sf.529(records)Af3_12 sf2.063 .206( in other languages\).  Common Lisp prescribes certain containment and)J72 239 :M.136 .014(disjointedness relations among the built-in types for )Jf0_12 sf.028(all)Af3_12 sf.15 .015( implementations, and allows certain other)J72 251 :M-.081(containment and disjointedness relations to depend upon the implementation [CL90,p.37-41].)A72 267 :M.694 .069(For example, Common Lisp prescribes that the types )Jf8_10 sf.212(real)Af3_12 sf.608 .061( \(which contains both )Jf8_10 sf.212(rational)Af3_12 sf.553 .055( and)J72 279 :Mf8_10 sf(float)Sf3_12 sf(\) and )Sf8_10 sf(complex)Sf3_12 sf-.005( shall be pairwise disjoint subtypes of )Af8_10 sf(number)Sf3_12 sf-.006(.  However, depending upon the)A72 291 :M1.77 .177(implementation, there may be numeric elements which are )Jf0_12 sf.433(not)Af3_12 sf1.16 .116( real or complex.  In fact, an)J72 303 :M.361 .036(interesting question for a "portable" Common Lisp program to ask an implementation is whether)J72 315 :M1.026 .103(there are any numbers other than )Jf8_10 sf.357(real)Af3_12 sf.555 .055( and )Jf8_10 sf.357(complex)Af3_12 sf.977 .098( numbers.  This question can be posed to)J72 327 :Mf8_10 sf-.023(subtypep)Af3_12 sf-.019( by asking whether )Af8_10 sf-.023(number)Af3_12 sf-.017( is a subset of the union of )Af8_10 sf-.023(real)Af3_12 sf-.018( and )Af8_10 sf-.023(complex)Af3_12 sf(.)S72 343 :M.17 .017(The Common Lisp type system has its nits.  For example, while ")Jf8_10 sf.06(3/1)Af3_12 sf.244 .024("\321the rational number with)J72 355 :M1.228 .123(numerator )Jf8_10 sf.282(3)Af3_12 sf.869 .087( and denominator )Jf8_10 sf.282(1)Af3_12 sf.726 .073(\321is a member of )Jf8_10 sf.282(rational)Af3_12 sf.735 .074(, because )Jf8_10 sf.282(3/1)Af3_12 sf.652 .065( is an integer, and all)J72 367 :M-.078(integers are rational numbers, ")Af8_10 sf-.099(#C\(3/1 0\))Af3_12 sf-.085("\321the complex number with real part )Af8_10 sf-.099(3/1)Af3_12 sf-.092( and imaginary)A72 379 :M-.065(part )Af8_10 sf-.09(0)Af3_12 sf-.078(\321is not a member of )Af8_10 sf-.09(\(complex\312rational\))Af3_12 sf-.07(, because )Af8_10 sf-.09(#C\(3/1\3120\))Af3_12 sf-.071( is normalized to the rational)A72 391 :M1.76 .176(number )Jf8_10 sf.453(3/1)Af3_12 sf1.251 .125(, and the Common Lisp standard says that the types )Jf8_10 sf.453(rational)Af3_12 sf.704 .07( and )Jf8_10 sf.453(complex)Af3_12 sf1.024 .102( are)J72 403 :M1.433 .143(disjoint, and therefore that )Jf8_10 sf.458(\(complex\312rational\))Af3_12 sf1.277 .128(\321a subtype of )Jf8_10 sf.458(complex)Af3_12 sf1.808 .181(\321is disjoint from)J72 415 :Mf8_10 sf.09(rational)Af3_12 sf.221 .022(, as well.)J72 431 :M-.074(Figure 1 is a chart classifying Common Lisp datatypes into 5 different "kingdoms".)A72 448 :M-.181(flat elementary types)A216 448 :Mf8_10 sf.107(symbol)Af3_12 sf.089 .009(, )Jf8_10 sf.107(character)Af3_12 sf.089 .009(, )Jf8_10 sf.107(readtable)Af3_12 sf.089 .009(, )Jf8_10 sf.107(complex)Af3_12 sf.274 .027(, etc.)J72 460 :M-.125(numeric ranges)A216 460 :Mf8_10 sf.066(\(integer\312*\312*\))Af3_12 sf.055 .005(, )Jf8_10 sf.066(\(ratio\312*\312*\))Af3_12 sf.055 .005(, )Jf8_10 sf.066(\(short-float\312*\312*\))Af3_12 sf.168 .017(, etc.)J72 472 :M-.097(array types)A216 472 :Mf8_10 sf(\(array\312)Sf0_12 sf(rep-type1)Sf8_10 sf<CA2A29>Sf3_12 sf(, )Sf8_10 sf(\(array\312)Sf0_12 sf(rep-type2)Sf8_10 sf<CA282ACA332929>Sf3_12 sf(, etc.)S72 484 :Mf8_10 sf-.093(defstruct)Af3_12 sf-.079( type hierarchy)A216 484 :Mf0_12 sf-.122(structure-name-1)Af3_12 sf-.07(, )Af0_12 sf-.122(structure-name-2)Af3_12 sf-.108(, etc.)A72 496 :M-.149(CLOS type partial order)A216 496 :Mf0_12 sf-.065(class-name-1)Af3_12 sf-.037(, )Af0_12 sf-.065(class-name-2)Af3_12 sf-.056(, etc.)A178 512 :M-.039(Figure 1.  Chart of Common Lisp data type kingdoms.)A72 534 :Mf4_12 sf4.451 .445(3.\312\312Common Lisp type specifier expressions)J72 550 :Mf3_12 sf1.255 .125(Type containment questions in Common Lisp are posed by calling )Jf8_10 sf.381(subtypep)Af3_12 sf1.067 .107( with two "type)J72 562 :M.339 .034(specifiers", which are expressions in a formal language.  These type specifier expressions denote)J72 574 :M.505 .05(the types whose containment is to be decided.  The power of )Jf8_10 sf.186(subtypep)Af3_12 sf.473 .047( is directly related to the)J72 586 :M1.526 .153("expressiveness" of this type specifier language; on the other hand, the more expressive the)J72 598 :M-.096(language, the more difficult it is to decide the questions.)A72 614 :M.361 .036(The Common Lisp type system allows for the construction of "type specifier" expressions which)J72 626 :M-.064(include the basic type symbols, as well as a number of operations involving those type symbols and)A72 638 :M.168 .017(\(recursively\) other type specifier expressions.  Thus, type specifiers consist of basic type symbols)J72 650 :M1.002 .1(such as )Jf8_10 sf.443(integer)Af3_12 sf.369 .037(, )Jf8_10 sf.443(float)Af3_12 sf.369 .037(, )Jf8_10 sf.443(character)Af3_12 sf1.188 .119(, numeric ranges such as )Jf8_10 sf.443(\(integer\3123\3126\))Af3_12 sf1.5 .15(, meaning the)J72 662 :M.942 .094(integers {)Jf8_10 sf.242(3)Af3_12 sf.121(,)Af8_10 sf.242(4)Af3_12 sf.121(,)Af8_10 sf.242(5)Af3_12 sf.121(,)Af8_10 sf.242(6)Af3_12 sf.584 .058(}, and array types such as )Jf8_10 sf.242(\(array\312float\312\(3\312*\)\))Af3_12 sf.964 .096(, meaning all 2-dimensional)J72 674 :M.067 .007(arrays whose containers are specialized to hold floating point numbers, and whose first dimension)J72 686 :M(must be )Sf8_10 sf(3)Sf3_12 sf.006 .001(.  Furthermore, a type can be specified by the )Jf8_10 sf(member)Sf3_12 sf( construct, where )Sf8_10 sf(\(member\312)Sf9_10 sf(a)Sf8_10 sf<CA>Sf9_10 sf(b)Sf8_10 sf<CA>Sf9_10 sf(c)Sf8_10 sf<29>S72 698 :Mf3_12 sf.673 .067(is just the finite set of Lisp objects {)Jf9_10 sf.279(a)Af3_12 sf.139(,)Af9_10 sf.279(b)Af3_12 sf.139(,)Af9_10 sf.279(c)Af3_12 sf.769 .077(}.  A type can also be specified operationally using a)J72 710 :M1.355 .136(predicate, as in )Jf8_10 sf.507(\(satisfies\312oddp\))Af3_12 sf1.391 .139(, meaning all Lisp objects )Jf0_12 sf.451(x)Af3_12 sf1.011 .101( such that )Jf8_10 sf.507(\(oddp\312)Af0_12 sf.451(x)Af8_10 sf.507<29>Af3_12 sf1.077 .108( is true.)Jendp%%Page: 4 4%%BeginPageSetupinitializepage(Henry Baker; page: 4 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(4)S72 81 :M.624 .062(Finally, simple type specifiers can be composed into compound type specifiers by means of the)J72 93 :M.198 .02(connectives )Jf8_10 sf.044(and)Af3_12 sf(, )Sf8_10 sf.044(or)Af3_12 sf.074 .007(, and )Jf8_10 sf.044(not)Af3_12 sf(.)S72 109 :M.528 .053(The Common Lisp type system allows the basic type system to be extended by the user in three)J72 121 :M.781 .078(ways through the use of )Jf8_10 sf.295(deftype)Af3_12 sf.246 .025(, )Jf8_10 sf.295(defstruct)Af3_12 sf.498 .05(, and )Jf8_10 sf.295(defclass)Af3_12 sf.51 .051(.  The first, )Jf8_10 sf.295(deftype)Af3_12 sf.679 .068(, is simply a)J72 133 :M1.114 .111(macro facility for type specifier expressions; thus, no new functionality is introduced through)J72 145 :Mf8_10 sf.044(deftype)Af3_12 sf.121 .012(, but brevity is facilitated.  The other two ways of type system extension, )Jf8_10 sf.044(defstruct)Af3_12 sf.116 .012( and)J72 157 :M.411 .041(CLOS's )Jf8_10 sf.103(defclass)Af3_12 sf.297 .03(, allow the creation of new types of Lisp objects which are disjoint from every)J72 169 :M-.045(other type \(except when otherwise specified\).  As we will later show, the change in functionality of)A72 181 :M-.102(the type system introduced by )Af8_10 sf-.125(defstruct)Af3_12 sf-.1( types is minimal and relatively self-contained.)A72 197 :M.16 .016(Common Lisp has recently been extended with the "Common Lisp Object System", or CLOS, for)J72 209 :M.771 .077(short [Bobrow88].  CLOS objects \()Jf0_12 sf.188(instances)Af3_12 sf.543 .054(\) are elements of )Jf0_12 sf.184(classes)Af3_12 sf.719 .072(, which are different from)J72 221 :M.49 .049(Common Lisp )Jf0_12 sf.107(types)Af3_12 sf.394 .039(, but which map into the Common Lisp type system.  Loosely speaking, this)J72 233 :M.947 .095(mapping from classes to types strips all )Jf0_12 sf.265(intensional)Af3_12 sf1.004 .1( meaning from the class, and produces the)J72 245 :Mf0_12 sf-.094(extensional)Af3_12 sf-.086( set of elements \(called )Af0_12 sf-.094(instances)Af3_12 sf-.086(\) of the class.  Given this interpretation, we will see that)A72 257 :M.724 .072(CLOS usually causes no problems for the )Jf8_10 sf.236(subtypep)Af3_12 sf.719 .072( decision procedure, as we can continue to)J72 269 :M-.078(work with only the )Af0_12 sf-.079(type)Af3_12 sf-.071( structure and not the )Af0_12 sf-.075(class)Af3_12 sf-.08( structure of CLOS objects.)A72 285 :M1.657 .166(Common Lisp also defines two additional type specifier constructs: )Jf8_10 sf.477(function)Af3_12 sf.742 .074( and )Jf8_10 sf.477(values)Af3_12 sf(.)S72 297 :M.563 .056(However, these constructs are expressly prohibited from calls to )Jf8_10 sf.168(typep)Af3_12 sf.447 .045(, and hence from calls to)J72 309 :Mf8_10 sf.097(subtypep)Af3_12 sf.315 .032( [CL90,p.57].  If these specifiers were not prohibited by Common Lisp from appearing)J72 321 :M.941 .094(in calls to )Jf8_10 sf.477(subtypep)Af3_12 sf1.365 .136(, they would make a decision procedure for )Jf8_10 sf.477(subtypep)Af3_12 sf1.396 .14( impossible.  For)J72 333 :M.361 .036(example, )Jf8_10 sf.088(subtypep)Af3_12 sf.281 .028( could then have been asked about the functional equivalence of two lambda-)J72 345 :M-.035(expressions, a problem which is known to be undecidable.)A72 362 :M-.108(Type Names)A158 362 :Mf8_10 sf.159(integer)Af3_12 sf.132 .013(, )Jf8_10 sf.159(number)Af3_12 sf.132 .013(, )Jf8_10 sf.159(symbol)Af3_12 sf.132 .013(, )Jf8_10 sf.159(null)Af3_12 sf.132 .013(, )Jf8_10 sf.159(t)Af3_12 sf.405 .041(, etc.)J72 374 :M-.1(Numeric Ranges)A158 374 :Mf8_10 sf.211(\(integer\312)Af0_12 sf.203(low)Af3_10 sf.088<CA>Af0_12 sf.187(high)Af8_10 sf.211<29>Af3_12 sf.175 .018(, )Jf8_10 sf.211(\(float\312)Af0_12 sf.203(low)Af3_10 sf.088<CA>Af0_12 sf.187(high)Af8_10 sf.211<29>Af3_12 sf.538 .054(, etc.)J72 386 :M-.128(Arrays)A158 386 :Mf8_10 sf.061(\(array\312bit\312\(3\312*\)\))Af3_12 sf.051 .005(, )Jf8_10 sf.061(\(string\312)Af0_12 sf.046(size)Af8_10 sf.061<29>Af3_12 sf.155 .016(, etc.)J72 398 :M-.099(Individuals)A158 398 :Mf8_10 sf.232(\(member\312)Af0_12 sf.196(object1)Af3_10 sf.097<CA>Af0_12 sf.196(object2)Af3_10 sf.097<CA>Af3_12 sf.116(...)Af8_10 sf<29>S72 410 :Mf3_12 sf-.145(Predicates)A158 410 :Mf8_10 sf-.174(\(satisfies )Af0_12 sf-.156(predicate-name)Af8_10 sf<29>S72 422 :Mf3_12 sf-.132(Connectives)A158 422 :Mf8_10 sf(\(not\312)Sf0_12 sf.006(specifier)Af8_10 sf<29>Sf3_12 sf(, )Sf8_10 sf(\(and\312)Sf0_12 sf.006(specifier1)Af3_10 sf<CA>Sf0_12 sf.006(specifier2)Af8_10 sf<29>Sf3_12 sf(, )Sf8_10 sf<286F72CA>Sf0_12 sf.006(specifier1)Af3_10 sf<CA>Sf0_12 sf.006(specifier2)Af8_10 sf<29>S158 438 :Mf3_12 sf-.028(Figure 2.  Chart of Common Lisp "type specifier" expressions.)A72 460 :Mf4_12 sf2.929 .293(4.\312\312The meaning of a Common Lisp "type")J72 476 :Mf3_12 sf.516 .052(So far, we have a notion of a datatype and a language for specifying datatypes, but have not yet)J72 488 :M.501 .05(related the two.  In this section, we give meaning to type specifier expressions by modelling the)J72 500 :M-.091(syntactic constructs of the language with operations on datatypes.)A72 516 :M-.082(There are several ways to interpret the notion of )Af0_12 sf-.088(type)Af3_12 sf-.08(.  One can interpret )Af0_12 sf-.088(type)Af3_12 sf-.071( as a )Af0_12 sf-.078(set)Af3_12 sf-.086( of elements, in)A72 528 :M.842 .084(which it has the )Jf0_12 sf.303(extensional)Af3_12 sf.931 .093( meaning of a set\321an )Jf0_12 sf1.822 .182(extensional type)Jf3_12 sf.799 .08( is no more or less than an)J72 540 :M.041 .004(unordered list of its elements.  One can also interpret a )Jf0_12 sf.013(type)Af3_12 sf.04 .004( as a member of a mathematical )Jf0_12 sf.013(lattice)A72 552 :Mf3_12 sf.434 .043(\(see Appendix I\) in which the subtype relation is a purely formal concept, and in which the type)J72 564 :M.597 .06(names themselves have some meaning; i.e., this is an )Jf0_12 sf.16(intensional)Af3_12 sf.535 .054( notion of type [Scott76].  The)J72 576 :M-.093(types-as-lattices concept has been utilized for years as a representation of the )Af0_12 sf-.12(meaning)Af3_12 sf-.106( of a program,)A72 588 :M.586 .059(and by compilers for performing data flow analysis \(including )Jf0_12 sf.832 .083(type inference)Jf3_12 sf.561 .056( [Kaplan80]\).  The)J72 600 :M.485 .048(Common Lisp standard says in no uncertain terms that "a data type is a \(possibly infinite\) )Jf0_12 sf.125(set)Af3_12 sf.304 .03( of)J72 612 :M1.047 .105(Lisp objects" \([CL90,p.12], italics added for emphasis\).  Thus, in determining the meaning of)J72 624 :Mf8_10 sf-.02(subtypep)Af3_12 sf-.017(, a Common Lisp implementor is required to implement the )Af0_12 sf-.016(extensional)Af3_12 sf-.012(, or )Af0_12 sf(set)Sf3_12 sf-.016(, notion of)A72 636 :M-.047(type, and hence answer )Af8_10 sf-.056(subtypep)Af3_12 sf-.046( questions from an extensional point of view.)A72 652 :M-.005(How do these notions of intensional and extensional types differ in practice?  One way the notions)A72 664 :M.837 .084(differ is in whether )Jf8_10 sf.324(subtypep)Af3_12 sf.835 .084( questions are to be answered for )Jf0_12 sf.234(this)Af3_12 sf.964 .096( implementation, or for )Jf0_12 sf.342(all)A72 676 :Mf3_12 sf.345 .035(Common Lisps.  Thus, one Common Lisp may implement a numeric type which is not )Jf8_10 sf.113(real)Af3_12 sf.295 .03( and)J72 688 :M.395 .04(not )Jf8_10 sf.181(complex)Af3_12 sf.698 .07( \(e.g., exact representations of irrational extensions implemented through symbolic)J72 700 :M1.46 .146(algebraic techniques [Loos83]\), hence in this implementation, )Jf8_10 sf.385(number)Af3_12 sf1.093 .109( is not intensionally or)J72 712 :M.079 .008(extensionally the same as the union of )Jf8_10 sf.028(real)Af3_12 sf.043 .004( and )Jf8_10 sf.028(complex)Af3_12 sf.083 .008(.  However, if no such numeric elements)Jendp%%Page: 5 5%%BeginPageSetupinitializepage(Henry Baker; page: 5 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(5)S72 81 :M2.067 .207(exist in another implementation of Common Lisp, then in that implementation, )Jf8_10 sf.608(number)Af3_12 sf.276 .028( )Jf0_12 sf.811(is)A72 93 :Mf3_12 sf-.019(extensionally the same as the union of )Af8_10 sf-.024(real)Af3_12 sf-.019( and )Af8_10 sf-.024(complex)Af3_12 sf-.019(, even though )Af8_10 sf-.024(number)Af3_12 sf-.014( is )Af0_12 sf-.02(not)Af3_12 sf-.02( intensionally)A72 106 :M-.055(the same.  )A12 f5_1 :p259.513 :m-.058(Common Lisp clearly intends this extensional view of )Af0_12 sf12 f6_1 :p24.363 :m-.058(types)Af3_12 sf(.)Sf3_9 sf0 -3 rm(2)S0 3 rm72 122 :Mf3_12 sf.919 .092(Thus, the extensional notion of types is equivalent to the notion of containment of sets, so the)J72 134 :M.114 .011(familiar laws of )Jf0_12 sf.219 .022(Boolean algebra)Jf3_12 sf.121 .012( hold \(see Appendix I\).  Since Boolean algebras are also lattices,)J72 146 :M-.002(the lattice ")AcFf1_12 sf-.002<A3>Asf-.002(" operation becomes equivalent to )Af0_12 sf(subset)Sf3_12 sf-.002(, which is therefore the model for )Af8_10 sf(subtypep)Sf3_12 sf(.)S72 158 :M1.732 .173(Additionally, the lattice operations of )Jf0_12 sf1.999 .2(least upper bound)Jf3_12 sf.796 .08( and )Jf0_12 sf2.176 .218(greatest lower bound)Jf3_12 sf2.15 .215( become)J72 170 :M-.097(equivalent to the )Af0_12 sf-.115(union)Af3_12 sf-.098( and )Af0_12 sf-.099(intersection)Af3_12 sf-.099( of sets, respectively, and these can also be utilized wherever)A72 182 :M-.048(lattice operations are required \(e.g., for type inference [Kaplan80], [Beer88]\).)A72 198 :M-.019(Several additional complications regarding )Af8_10 sf-.023(subtypep)Af3_12 sf-.019( are more easily dealt with using the Boolean)A72 210 :M.32 .032(algebra interpretation of types, due to its isomorphism with the standard Boolean algebra of )Jf0_12 sf.076(sets)Af3_12 sf(:)S72 222 :M.02 .002(namely, the ability to ask questions about particular elements \(utilizing the )Jf8_10 sf(member)Sf3_12 sf.022 .002( construct\), and)J72 234 :M.205 .021(the ability to talk about the complement of a set \(using the )Jf8_10 sf.079(not)Af3_12 sf.262 .026( construct\).  Such questions would)J72 246 :M-.124(have to be dealt with on an )Af0_12 sf-.142(ad hoc)Af3_12 sf-.115( basis with a lattice interpretation, or not at all.)A72 262 :M.524 .052(The algebraic laws for the manipulation of Boolean algebras are simpler and more familiar than)J72 274 :M.122 .012(those of lattices \(see Appendix I\).  The intuition most people have of lattice manipulations is very)J72 286 :M.493 .049(restricted, and one must be very careful not to use Boolean thought processes when they are not)J72 298 :M-.008(appropriate.  For example, most people would assume that it is appropriate to )Af0_12 sf-.007(distribute)Af3_12 sf-.008( \("multiply)A72 310 :M.594 .059(out"\) )Jf8_10 sf.209(and)Af3_12 sf.367 .037( over )Jf8_10 sf.209(or)Af3_12 sf.576 .058( in the type specifier expression )Jf8_10 sf.209(\(and\312float\312\(or\312single-float\312null\)\))Af3_12 sf.359 .036( to)J72 322 :M.218 .022(produce the result: )Jf8_10 sf.071(single-float)Af3_12 sf.219 .022(.  In the obvious data-type lattice, however, the answer without)J72 334 :M-.016(the distribution would have been )Af8_10 sf-.02(float)Af3_12 sf-.017(.  This curious result obtains because the obvious Common)A72 346 :M.253 .025(Lisp type lattice is )Jf0_12 sf.096(non-modular)Af3_12 sf.223 .022( and hence not )Jf0_12 sf.076(distributive;)Af3_12 sf.311 .031( therefore it cannot be Boolean, since)J72 358 :M-.146(Boolean lattices are distributive [MacLane67].)A72 380 :Mf4_12 sf4.01 .401(5.\312\312Current implementations of )Jf7_10 sf1.04(subtypep)A72 396 :Mf3_12 sf.07 .007(The Common Lisp standards committee noted that "[)Jf8_10 sf.02(subtypep)Af3_12 sf.065 .007( questions involving] )Jf8_10 sf.02(and)Af3_12 sf(, )Sf8_10 sf(or)Sf3_12 sf(, )Sf8_10 sf.02(not)Af3_12 sf(,)S72 408 :M.562 .056(and )Jf8_10 sf.232(member)Af3_12 sf.679 .068( are \311 very messy to deal with" [CL90,p.97-98].  We agree that the Common Lisp)J72 420 :M.096 .01(type system itself is very messy, but this messiness can be dealt with through a uniform bit-vector)J72 432 :M-.015(representation in which the messiness is confined to the contents of these bit-vectors.  However, in)A72 444 :M-.059(order to understand the need for this representation, it is instructive to examine the )Af0_12 sf-.069(ad hoc)Af3_12 sf-.075( approach)A72 456 :M-.135(typical of current implementations.)A-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 558.24 -.24 .24 215.24 558 .24 72 558 @a72 575 :Mf3_9 sf.185(2)Af3_12 sf0 3 rm.796 .08(There could also conceivably be an alternative )J0 -3 rmf0_12 sf0 3 rm.247(modal)A0 -3 rmf3_12 sf0 3 rm.748 .075( view of Common Lisp types, where the)J0 -3 rm72 590 :M-.046(modal constructs "may" and "must" would represent the differences in implementations \(or )Af0_12 sf-.051(worlds)Af3_12 sf(,)S72 602 :M3.724 .372(see [Hughes68]\).  "May" would be interpreted as "there could conceivably exist an)J72 614 :M-.073(implementation", and "must" would be interpreted as "for all conceivable implementations".  Under)A72 626 :M1.908 .191(this modal view, there would be )Jf0_12 sf.596(undecidable)Af3_12 sf.305 .03( )Jf8_10 sf.671(subtypep)Af3_12 sf1.92 .192( questions even in the absence of)J72 638 :Mf8_10 sf.429(satisfies)Af3_12 sf1.268 .127(, because there would be specifiers )Jf0_12 sf.334(t1)Af3_12 sf.667 .067( and )Jf0_12 sf.334(t2)Af3_12 sf1.176 .118( such that the answer to the question)J72 650 :Mf8_10 sf.428(\(subtypep\312)Af0_12 sf.333(t1)Af8_10 sf.428<CA>Af0_12 sf.333(t2)Af8_10 sf.428<29>Af3_12 sf1.396 .14( would differ depending upon the implementation, and hence it would be)J72 662 :M-.067(impossible for )Af8_10 sf-.083(subtypep)Af3_12 sf-.068( to answer with certainty any question for which)A72 678 :Mf8_10 sf( \(or\312\(must\312\(subtypep\312)Sf9_10 sf(t1)Sf8_10 sf<CA>Sf9_10 sf(t2)Sf8_10 sf(\)\)\312\(must\312\(not\312\(subtypep\312)Sf9_10 sf(t1)Sf8_10 sf<CA>Sf9_10 sf(t2)Sf8_10 sf<29292929>S72 693 :Mf3_12 sf-.063(was not true.  We reject this modal view as not being useful for a program to want to query because)A72 705 :M1.048 .105(most programs would be more interested in )Jf0_12 sf.24(this)Af3_12 sf1.175 .117( implementation\321i.e., the one the program is)J72 717 :M-.019(running on, or being compiled for.)Aendp%%Page: 6 6%%BeginPageSetupinitializepage(Henry Baker; page: 6 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(6)S72 85 :Mf8_10 sf(\(defun o-t-subtypep \(x y\))S72 96 :M.872 .087(  )Jf7_10 sf5.831 .583(; o-t-subtypep = "obviously-trivial-subtypep")J72 107 :Mf8_10 sf(  \(cond)S72 118 :M.004 0(    \(\(and \(eq x 'fixnum\) \(eq y 'float\)\))J317 118 :Mf7_10 sf3.449 .345(; Do all pairs of type symbols.)J72 129 :Mf8_10 sf(     nil\))S72 140 :M(    \(\(and \(eq x \311\) \(eq y \311\)\))S317 140 :Mf7_10 sf4.068 .407(; ad nauseum.)J72 151 :Mf8_10 sf(     t/nil\))S72 162 :M(    \(\(eq x nil\) t\))S317 162 :Mf7_10 sf4.185 .419(; 1st arg empty disjunction.)J72 173 :Mf8_10 sf(    \(\(eq \(car x\) 'or\))S317 173 :Mf7_10 sf4.097 .41(; 1st arg disjunction easy.)J72 184 :Mf8_10 sf(     \(every #'\(lambda \(nx\))S72 195 :M.002 0(               \(o-t-subtypep nx y\)\))J72 206 :M(            \(cdr x\)\)\))S72 217 :M(    \(\(eq \(car x\) 'member\))S317 217 :Mf7_10 sf4.713 .471(; ditto.)J72 228 :Mf8_10 sf(     \(every #'\(lambda \(xelt\))S72 239 :M(               \(typep xelt y\)\))S72 250 :M(            \(cdr x\)\)\))S72 261 :M(    \(\(eq y t\) t\))S317 261 :Mf7_10 sf4.185 .419(; 2nd arg empty conjunction.)J72 272 :Mf8_10 sf(    \(\(eq \(car y\) 'and\))S317 272 :Mf7_10 sf4.097 .41(; 2nd arg conjunction easy.)J72 283 :Mf8_10 sf(     \(every #'\(lambda \(ny\))S72 294 :M.002 0(               \(o-t-subtypep x ny\)\))J72 305 :M(            \(cdr y\)\)\))S72 316 :M(    \(\(and \(eq \(car x\) 'not\))S317 316 :Mf7_10 sf5.374 .537(; Contrapositive easy.)J72 327 :Mf8_10 sf(          \(eq \(car y\) 'not\)\))S72 338 :M.004 0(     \(o-t-subtypep \(cadr y\) \(cadr x\)\))J72 349 :M(    \(\(eq x t\) ???\))S317 349 :Mf7_10 sf4.185 .419(; 1st arg empty conjunction.)J72 360 :Mf8_10 sf(    \(\(and \(eq \(car x\) 'and\))S317 360 :Mf7_10 sf3.88 .388(; Partial for 1st arg conjunct.)J72 371 :Mf8_10 sf(          \(some #'\(lambda \(nx\))S72 382 :M.002 0(                   \(o-t-subtypep nx y\)\))J72 393 :M(                \(cdr x\)\)\))S72 404 :M(     t\))S72 415 :M(    \(\(eq y nil\) ???\))S317 415 :Mf7_10 sf4.185 .419(; 2nd arg empty disjunction.)J72 426 :Mf8_10 sf(    \(\(and \(eq \(car y\) 'or\))S317 426 :Mf7_10 sf3.88 .388(; Partial for 2nd arg disjunct.)J72 437 :Mf8_10 sf(          \(some #'\(lambda \(ny\))S72 448 :M.002 0(                   \(o-t-subtypep x ny\)\))J72 459 :M(                \(cdr y\)\)\))S72 470 :M(     t\))S72 481 :M(    \(\(eq \(car y\) 'member\) ???\))S72 492 :M(    \(...\))S317 492 :Mf7_10 sf3.577 .358(; ???)J72 507 :Mf3_12 sf.02 .002(In this example, we see that the hacker approach fails to make progress after the )Jf0_12 sf.006(monotonicity)Af3_12 sf( rule)S72 519 :M-.026(has been used in every conceivable way.  In order to make any further progress, we must make use)A72 531 :M.579 .058(of the other properties of Boolean algebras, and this will require breaking up the problem along)J72 543 :M-.048(different dimensions.)A72 559 :M-.085(The incompleteness of the )Af0_12 sf-.092(ad hoc)Af3_12 sf-.079( approach is not its only problem.  Its soundness is also difficult to)A72 571 :M.639 .064(demonstrate.  With a program of this complexity \(some implementations go on like this for 4-5)J72 583 :M1.006 .101(pages\), it is difficult to determine its correctness, and indeed some Common Lisp )Jf8_10 sf.326(subtypep)Af3_12 sf.371('s)A72 595 :M.082 .008(violate the basic axioms of a )Jf0_12 sf.143 .014(partial order)Jf3_12 sf.09 .009(\321like transitivity.  Yet even after all of this work, most)J72 607 :M-.108(implementations still cannot decide the basic propositions that the Common Lisp specifications pose)A72 619 :M.182 .018(as axioms.)J72 641 :Mf4_12 sf3.012 .301(6.\312\312What is the power of )Jf7_10 sf1.087(subtypep)Af4_12 sf(?)S72 657 :Mf3_12 sf.379 .038(In this section, we explain the difficulties in properly implementing )Jf8_10 sf.118(subtypep)Af3_12 sf.377 .038(, by showing what)J72 669 :M.414 .041(other questions that can be decided using )Jf8_10 sf.139(subtypep)Af3_12 sf.433 .043( as a subroutine.  This "reduction" technique)J72 681 :M.761 .076(thus proves that deciding )Jf8_10 sf.244(subtypep)Af3_12 sf.635 .064( is at least as hard as deciding any of these other questions.)J72 693 :M12 f5_1 :p389 :m-.073(These reductions, however, depend critically on the "set" interpretation for "type".)Aendp%%Page: 7 7%%BeginPageSetupinitializepage(Henry Baker; page: 7 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(7)S72 85 :M-.017(Using )Af8_10 sf-.019(subtypep)Af3_12 sf-.016(, one can ask whether:)A72 97 :M.514 .051(\312\245\312a type is empty \()Jf8_10 sf.205(nil)Af3_12 sf<29>S72 109 :M.709 .071(\312\245\312two types are disjoint)J72 121 :M.754 .075(\312\245\312two types are equal)J72 133 :M.017 .002(\312\245\312an object is an element of a given type)J72 145 :M.23 .023(\312\245\312two objects are identical \()Jf8_10 sf.072(eql)Af3_12 sf<29>S72 157 :M-.003(\312\245\312an object is a member of a given finite set)A72 169 :M.063 .006(\312\245\312one finite set is a subset of another finite set)J72 181 :M.736 .074(\312\245\312a number is positive)J72 193 :M.228 .023(\312\245\312one number is less than or equal to another.)J72 209 :M-.06(The code below shows each of these reductions of the given question to a )Af8_10 sf-.073(subtypep)Af3_12 sf-.064( question.)A72 225 :Mf8_10 sf.006 .001(\(defun type-null \(x\) \(subtypep x nil\)\))J72 247 :M.006 .001(\(defun type-disjoint \(x y\) \(subtypep `\(and ,x ,y\) nil\)\))J72 269 :M(\(defun type-equal \(x y\))S72 280 :M.006 .001(  \(multiple-value-bind \(x<=y okxy\) \(subtypep x y\))J72 291 :M.005 .001(    \(multiple-value-bind \(y<=x okyx\) \(subtypep y x\))J72 302 :M.004 0(      \(values \(and x<=y y<=x\) \(and okxy okyx\)\)\)\)\))J72 324 :M.006 .001(\(defun typep \(x y\) \(values \(subtypep `\(member ,x\) y\)\)\))J72 346 :M.006 .001(\(defun eql \(x y\) \(values \(type-equal `\(member ,x\) `\(member ,y\)\)\)\))J72 368 :M.006 .001(\(defun member \(x y\) \(values \(subtypep `\(member ,x\) `\(member ,@y\)\)\)\))J72 390 :M.006 .001(\(defun subsetp \(x y\) \(values \(subtypep `\(member ,@x\) `\(member ,@y\)\)\)\))J72 412 :M.006 .001(;;; The following are restricted to rational numbers only.)J72 423 :M.006 .001(\(defun plusp \(x\) \(values \(subtypep `\(rational ,x *\) '\(rational \(0\) *\)\)\)\))J72 445 :M.006 .001(\(defun <= \(x y\) \(values \(subtypep `\(rational * ,x\) `\(rational * ,y\)\)\)\))J72 460 :Mf3_12 sf-.13(One can even perform "pattern-matched" database retrieval by storing the database records as a large)A72 472 :M-.046(union of arrays of equal rank whose declared dimensions encode the data; )Af8_10 sf-.056(subtypep)Af3_12 sf-.051( can determine)A72 484 :M.309 .031(if a given pattern-encoded-as-array-type matches any of the arrays in the union.  The code below)J72 496 :M-.029(implements this form of database retrieval using )Af8_10 sf-.036(subtypep)Af3_12 sf-.028(.  It works by storing the data records as)A72 508 :M1.043 .104(elements of a relation.  A query consisting of a record without ")Jf8_10 sf.379(*)Af3_12 sf1.284 .128(" components is decided by)J72 520 :M.007 .001(determining whether the element sought is )Jf0_12 sf(not)Sf3_12 sf( in the )Sf0_12 sf(complement)Sf3_12 sf.005 .001( of the union of stored records; if)J72 532 :M.111 .011(so, then it )Jf0_12 sf.037(is)Af3_12 sf.139 .014( in the database.  A query consisting of a record with ")Jf8_10 sf.056(*)Af3_12 sf.233 .023(" components defines another)J72 544 :M1.299 .13(relation on the same domain as that of the database.  If this query relation is not completely)J72 556 :M-.12(contained within the complement of the stored relation, then there exists an element of the query that)A72 568 :M-.019(is )Af0_12 sf-.027(not)Af3_12 sf-.022( in the )Af0_12 sf-.031(complement)Af3_12 sf-.025( of the union of the database records, hence )Af0_12 sf(is)Sf3_12 sf-.025( in the union, and hence )Af0_12 sf(is)Sf3_12 sf-.032( in)A72 580 :M-.016(one of the records.)A72 596 :Mf8_10 sf(\(defvar *database* nil\))S72 618 :M(\(defun store-record \(record\))S72 629 :M.005 .001(  ; record = \(<i> <j> ... <n>\), i,j,k non-negative integers.)J72 640 :M.006 .001(  \(push `\(array t ,record\) *database*\)\))J72 662 :M(\(defun retrieve-record \(record\))S72 673 :M.005 .001(  ; record = \(<i/*> <j/*> ... <n/*>\), i,j,k non-negative integers)J72 684 :M.005 .001(  \(not \(subtypep `\(array t ,record\))J72 695 :M.003 0(                 `\(not \(or ,@*database*\)\)\)\)\))Jendp%%Page: 8 8%%BeginPageSetupinitializepage(Henry Baker; page: 8 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(8)S72 85 :M.405 .041(However, there are certain questions one )Jf0_12 sf.112(cannot)Af3_12 sf.238 .024( ask with )Jf8_10 sf.123(subtypep)Af3_12 sf.08 .008(.  )Jf8_10 sf.123(subtypep)Af3_12 sf.364 .036( cannot be asked)J72 97 :M.144 .014(what )Jf0_12 sf.037(size)Af3_12 sf.123 .012( a set is \(other than whether it is empty\); it cannot be asked to do arithmetic, it cannot be)J72 109 :M-.038(asked hypothetical questions.  As a result, a decision procedure for )Af8_10 sf-.048(subtypep)Af3_12 sf-.04( does not have to deal)A72 121 :M1.248 .125(with alternation of quantifiers, Skolem functions, or any other device that could cause multi-)J72 133 :M-.123(exponential inefficiency in a decision procedure.)A72 149 :M.33 .033(Before going into the details of the implementation of )Jf8_10 sf.11(subtypep)Af3_12 sf.245 .024(, we notice that )Jf8_10 sf.11(subtypep)Af3_12 sf.361 .036( could)J72 161 :M.008 .001(have been defined in terms of the simpler type specifier predicate )Jf8_10 sf(type-null)Sf3_12 sf( \(given below\), if the)S72 173 :M-.089(language designers had been more confident of an efficient implementation.  \()Af0_12 sf-.118(NB:)Af3_12 sf-.055( )Af8_10 sf-.11(type-null)Af3_12 sf-.09( is not)A72 185 :M.567 .057(the same as )Jf8_10 sf.245(null)Af3_12 sf.636 .064(, since the argument for )Jf8_10 sf.245(type-null)Af3_12 sf.725 .073( is evaluated as a type-specifier, while the)J72 197 :M-.063(argument for )Af8_10 sf-.076(null)Af3_12 sf-.06( is evaluated as a Lisp expression.\))A72 213 :Mf8_10 sf(\(defun subtypep \(x y\))S72 224 :M.005 .001(  ; TYPE-NULL determines if its argument is)J72 235 :M.004 0(  ;  a type specifier for the empty type.)J72 246 :M(  \(type-null `\(and ,x \(not ,y\)\)\)\))S72 267 :Mf4_12 sf3.637 .364(7.\312\312The )Jf7_10 sf1.033(subtypep)Af4_12 sf4.533 .453( decision procedure)J72 283 :Mf3_12 sf.192 .019(Our decision procedure for )Jf8_10 sf.058(subtypep)Af3_12 sf.174 .017( will divide and conquer.  We will utilize separate decisions)J72 296 :M1.331 .133(procedures for the )Jf0_12 sf.325(disjoint)Af3_12 sf1.331 .133( "kingdoms" of data types in the Common Lisp type system.)Jf3_9 sf0 -3 rm.325(3)A0 3 rmf3_12 sf.628 .063(  By)J72 308 :M-.124(utilizing the fact that the Boolean algebra for the Common Lisp type system is the )Af0_12 sf-.142(Cartesian product)A72 320 :Mf3_12 sf.771 .077(of the Boolean algebras for each of these disjoint "kingdoms" of types, we will then be able to)J72 332 :M-.071(handle the general case.  \(This approach is analogous to the use of the Chinese Remainder Theorem)A72 344 :M-.092(to solve problems involving integers by mapping the problems into several homomorphic images.\))A72 360 :M.265 .027(In many cases, )Jf8_10 sf.097(subtypep)Af3_12 sf.249 .025( will depend upon )Jf8_10 sf.097(typep)Af3_12 sf.183 .018( for its answer.  )Jf8_10 sf.097(typep)Af3_12 sf.297 .03( itself may be extremely)J72 372 :M.321 .032(complex in the general case\321especially when CLOS types are involved.  Nevertheless, )Jf8_10 sf.093(typep)Af3_12 sf.141 .014( is)J72 384 :M-.015(required by Common Lisp to be a decision procedure, so we can depend upon )Af8_10 sf-.017(typep)Af3_12 sf-.015('s answers.)A72 406 :Mf4_12 sf4.809 .481(7.1\312\312Implementing )Jf7_10 sf.842(subtypep)Af4_12 sf3.179 .318( for primitive elementary types)J72 422 :Mf3_12 sf1.1 .11(Once we have focussed on the )Jf0_12 sf.293(set)Af3_12 sf1.156 .116( interpretation of data type, it should be possible to answer)J72 434 :M.5 .05(subtype questions by simply comparing the membership of the sets.  However, for the Common)J72 446 :M.116 .012(Lisp datatypes with large or infinite sets \(e.g., )Jf8_10 sf.041(integer)Af3_12 sf.148 .015(\), this implementation is either impractical)J72 458 :M1.083 .108(or impossible.  The work of the comparison process can be reduced by noting that due to the)J72 470 :M.443 .044(limitations of the language of type specifications involved, most elements of the various sets are)J72 482 :Mf0_12 sf.036(indistinguishable)Af3_12 sf.137 .014(, and that any member of such a group of indistinguishable elements will always)J72 494 :M-.041(be treated the same under all the set operations.  These sets of indistinguishable elements are called)A72 506 :Mf0_12 sf.695 .07(equivalence classes)Jf3_12 sf.382 .038(.  With the exception of ranges, arrays and user-defined types, the number of)J72 518 :M1.412 .141(equivalence classes for Common Lisp types is )Jf0_12 sf.297(finite)Af3_12 sf1.24 .124(.  Thus, for the built-in types, excluding)J72 530 :M.745 .075(ranges, arrays and user-defined types, we can accurately answer any )Jf8_10 sf.227(subtypep)Af3_12 sf.643 .064( question with a)J72 542 :M-.05(simple subset test on two finite sets.  With this reduction of the comparison problem, implementing)A72 554 :Mf8_10 sf-.105(subtypep)Af3_12 sf-.08( involves the selection of a )Af0_12 sf-.086(representative)Af3_12 sf-.087( element from each of the equivalence classes of)A72 566 :M.845 .085(elements, and performing Boolean operations on these sets of representatives instead of on the)J72 578 :M.341 .034(whole sets.)J72 594 :M.391 .039(The next step is to choose correct representative elements from the equivalence classes.  We can)J72 606 :M.23 .023(choose representative elements using the same principle that medical students use to organize the)J72 618 :M-.03(wide variety of diseases and symptoms: )Af0_12 sf-.028(differential diagnosis.)Af3_12 sf-.033(  We need each element to somehow)A72 630 :M.737 .074(be different from each other element, in the sense that some set \(type\) includes one but not the)J-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 649.24 -.24 .24 215.24 649 .24 72 649 @a72 666 :Mf3_9 sf.258(3)Af3_12 sf0 3 rm1.329 .133(In some implementations, )J0 -3 rmf8_10 sf0 3 rm.345(defstruct)A0 -3 rmf3_12 sf0 3 rm.536 .054( and )J0 -3 rmf8_10 sf0 3 rm.345(defclass)A0 -3 rmf3_12 sf0 3 rm1.12 .112( types may overlap with the elementary)J0 -3 rm72 681 :M2.471 .247(Common Lisp types\321e.g., )Jf8_10 sf.603(stream)Af3_12 sf1.711 .171(.  Since we utilize the same mechanism for these three)J72 693 :M.662 .066(kingdoms, we can collapse these three kingdoms into one for the implementation of )Jf8_10 sf.208(subtypep)Af3_12 sf(.)S72 705 :M1.375 .137(However, we insist that numeric ranges and arrays be disjoint from each other and from the)J72 717 :M-.028(previous three kingdoms.)Aendp%%Page: 9 9%%BeginPageSetupinitializepage(Henry Baker; page: 9 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(9)S72 81 :M1.042 .104(other.  If we choose extra representatives from an equivalence class, they will slow down our)J72 93 :M1.187 .119(decision procedure slightly, but will not cause any incorrect answers.  However, if we fail to)J72 105 :M1.438 .144(choose an element which distinguishes between two sets, then those sets may be incorrectly)J72 117 :M1.861 .186(determined by )Jf8_10 sf.527(subtypep)Af3_12 sf1.34 .134( to be equivalent, when in fact they are not.  This problem will be)J72 129 :M-.076(examined later in more detail, under the )Af8_10 sf-.096(member)Af3_12 sf-.078( construct and user-defined type discussions.)A72 145 :M-.052(In the case of the built-in Common Lisp types, the choice of representatives is straightforward.  We)A72 157 :M.238 .024(must select at least one representative member of each built-in type \(assuming that they have any)J72 169 :M.468 .047(members at all\); a )Jf8_10 sf.185(fixnum)Af3_12 sf.184 .018(, a )Jf8_10 sf.185(bignum)Af3_12 sf.184 .018(, a )Jf8_10 sf.185(ratio)Af3_12 sf.184 .018(, a )Jf8_10 sf.185(short-float)Af3_12 sf.184 .018(, a )Jf8_10 sf.185(single-float)Af3_12 sf.184 .018(, a )Jf8_10 sf.185(character)Af3_12 sf(,)S72 181 :M.793 .079(etc.  We may need some additional elements when there are complex relationships; e.g., in the)J72 193 :M4.623 .462(characters, where we need a )Jf8_10 sf1.569(base-character)Af3_12 sf3.688 .369(, a non-base )Jf8_10 sf1.569(character)Af3_12 sf3.647 .365(, and an)J72 205 :Mf8_10 sf(extended-character)Sf3_12 sf( which is not a )Sf8_10 sf(character)Sf3_12 sf(.)S72 221 :M.491 .049(How many representatives are required?  For the built-in types, not including ranges and arrays,)J72 233 :M.413 .041(fewer than 30 elements are required.  Applying the standard trick of representing finite sets with)J72 245 :M-.012(integers interpreted as bit-vectors, then mapping union, intersection and complement onto )Af8_10 sf-.015(logior)Af3_12 sf(,)S72 257 :Mf8_10 sf.199(logand)Af3_12 sf.336 .034(, and )Jf8_10 sf.199(lognot)Af3_12 sf.575 .058(, we can represent these sets using relatively small integers which fit into a)J72 269 :M2.493 .249(single machine word\321i.e., )Jf8_10 sf.632(fixnum)Af3_12 sf1.497 .15('s.  Thus, not only can we answer )Jf8_10 sf.632(subtypep)Af3_12 sf2.678 .268( questions)J72 281 :M.199 .02(involving the basic Common Lisp types accurately, we can also answer them quickly using a few)J72 293 :M-.086(logical operations on word-size quantities.)A72 309 :M.305 .031(An example of an implementation of )Jf8_10 sf.097(subtypep)Af3_12 sf.293 .029( for built-in datatypes using this technique can be)J72 321 :M-.032(found in Appendix II.)A72 343 :Mf4_12 sf3.138 .314(7.2\312\312How to handle the )Jf7_10 sf1.008(MEMBER)Af4_12 sf4.508 .451( construct)J72 359 :Mf3_12 sf1.08 .108(The )Jf8_10 sf.419(member)Af3_12 sf1.264 .126( construct adds complexity to our problem by rendering the )Jf0_12 sf1.435 .143(a priori)Jf3_12 sf1.279 .128( selection of)J72 371 :M.9 .09(representatives, as described above, inadequate.  Instead of asking questions about anonymous)J72 383 :Mf8_10 sf.532(short-float)Af3_12 sf.591 .059( or )Jf8_10 sf.532(base-character)Af3_12 sf1.772 .177( elements, one can now ask questions about specifically)J72 395 :Mf0_12 sf.175(mentioned)Af3_12 sf.456 .046( elements.  Using the )Jf8_10 sf.19(member)Af3_12 sf.636 .064( construct, one can also ask questions about anonymous)J72 407 :M-.074(arbitrary finite sets of Lisp objects, with no reference to the rest of the Common Lisp type system at)A72 419 :M-.018(all.  Both of these forms of question can be seen in our emulation of )Af8_10 sf-.024(typep)Af3_12 sf-.018( and )Af8_10 sf-.024(subsetp)Af3_12 sf-.019( in section)A72 431 :M1(5.)A72 447 :M1.651 .165(The trick to efficiently handling )Jf8_10 sf.532(member)Af3_12 sf.632 .063( is to )Jf0_12 sf2.233 .223(include the mentioned elements)Jf3_12 sf1.721 .172( as additional)J72 459 :M.189 .019(representatives for our finite sets.  This requires two passes through the type specifier expression:)J72 471 :M2.176 .218(the first to find all elements mentioned in )Jf8_10 sf.804(member)Af3_12 sf2.822 .282( constructs and make them additional)J72 483 :M.101 .01(representatives; and the second to evaluate the type specifier expression using Boolean operations)J72 495 :M1.076 .108(on bit-vectors.  The only complication involves small sets \(such as )Jf8_10 sf.356(null)Af3_12 sf.996 .1(, which has only one)J72 507 :M.518(element\321)Af8_10 sf.498(nil)Af3_12 sf1.351 .135(\), and obvious elements such as the )Jf8_10 sf.498(fixnum)Af3_12 sf1.27 .127( 0 \(zero\).  To handle finite subset)J72 519 :M-.005(questions in which the )Af0_12 sf(only)Sf3_12 sf-.005( clauses are )Af8_10 sf(member)Sf3_12 sf-.005( constructs, we have to )Af0_12 sf(register)Sf3_12 sf-.005( our representatives.)A72 531 :M.135 .013(By )Jf0_12 sf.049(registration)Af3_12 sf.212 .021( we mean determining, in advance, the canonical bit-position within the bit-vector)J72 543 :M1.28 .128(which will represent the registered element.  This registration procedure makes sure that, for)J72 555 :M.516 .052(example, the type specifier )Jf8_10 sf.159(\(member\312nil\))Af3_12 sf.474 .047( will have exactly the same representation as the type)J72 567 :M-.018(specifier )Af8_10 sf-.025(null)Af3_12 sf(.)S72 583 :M.165 .017(An additional problem with )Jf8_10 sf.049(member)Af3_12 sf.141 .014( is that one could conceivably ask whether a type consisted of)J72 595 :M.768 .077(exactly one particular element; if the element mentioned just happened to be the representative)J72 607 :M.099 .01(chosen, our implementation of )Jf8_10 sf.028(subtypep)Af3_12 sf.089 .009( would give out the wrong answer.  Therefore, whenever)J72 619 :M1.39 .139(an element is explicitly mentioned in )Jf8_10 sf.453(member)Af3_12 sf1.352 .135(, and it was previously used as the anonymous)J72 631 :M-.109(representative of other elements, we must somehow generate an alternative element \(if one exists\) to)A72 643 :M-.043(be used as the new anonymous representative.  This procedure will ensure that the type system will)A72 655 :M-.09(not give out wrong answers under these conditions.  We will call this situation the )Af0_12 sf-.093(aliasing)Af3_12 sf-.11( problem.)A72 671 :M-.1(The aliasing problem is relatively easily solved.  The aliasing problem cannot happen with numbers,)A72 683 :M.22 .022(because the interval representation \(as discussed later\) handles the general case.  With most other)J72 695 :M-.101(Lisp object types, the Lisp reader generates a brand-new object which is guaranteed not to alias with)A72 707 :M.009 .001(any other object of the same type, hence the representative for that type can never become aliased.)Jendp%%Page: 10 10%%BeginPageSetupinitializepage(Henry Baker; page: 10 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(10)S72 81 :M2.771 .277(From this, we can see that the only possible aliasing problems are with )Jf8_10 sf.98(symbol)Af3_12 sf2.958 .296('s and)J72 94 :Mf8_10 sf.324(character)Af3_12 sf.177('s.)Af3_9 sf0 -3 rm(4)S0 3 rm72 110 :Mf3_12 sf.506 .051(The aliasing problem for symbols can be dealt with by either utilizing a very long symbol name)J72 122 :M.329 .033(\(e.g., )Jf8_10 sf.123(anonymous)Af3_12 sf.224 .022( itself, or )Jf8_10 sf.123(rumpelstiltskin)Af3_12 sf.362 .036(\), or by utilizing a name guaranteed to be unknown)J72 134 :M-.074(to the caller of )Af8_10 sf-.105(subtypep)Af3_12 sf-.115(\321an )Af0_12 sf-.089(un-interned)Af3_12 sf-.103( symbol.)A72 150 :M.08 .008(The aliasing problem is the most severe for )Jf0_12 sf.024(characters)Af3_12 sf.086 .009(, because the set of characters is \(normally\))J72 162 :M-.022(finite, and it is conceivable that a user will want to utilize the Common Lisp type system to answer)A72 174 :M1.091 .109(complex questions about sets of explicitly-named characters \(e.g., "upper-case", "lower-case",)J72 186 :M1.369 .137("digit", "alphabetic", etc.\).  Thus, during the element registration procedure, if a character is)J72 198 :M1.443 .144(registered that was previously the anonymous representative, then another character must be)J72 210 :M.043 .004(generated that has not yet been mentioned.  This requires an )Jf0_12 sf.014(enumerator)Af3_12 sf.041 .004( for the various subsets of)J72 222 :M1.329 .133(characters: )Jf8_10 sf.319(character)Af3_12 sf.266 .027(, )Jf8_10 sf.319(base-character)Af3_12 sf.539 .054(, and )Jf8_10 sf.319(extended-character)Af3_12 sf.986 .099(, which generates a new)J72 234 :M.756 .076(character that has not yet been mentioned.  Another alternative is to pre-register )Jf0_12 sf.176(all)Af3_12 sf1.085 .108( characters,)J72 246 :M.017 .002(although this would slow down )Jf8_10 sf(subtypep)Sf3_12 sf.016 .002( for the vast majority of questions which did not involve)J72 258 :M1.769 .177(characters at all.  A compromise solution would be to temporarily\321for a particular call to)J72 270 :Mf8_10 sf-.141(subtypep)Af3_12 sf-.115(\321register all characters when )Af0_12 sf-.136(any)Af3_12 sf-.113( character is explicitly mentioned.)A72 286 :M.509 .051(The example implementation of )Jf8_10 sf.137(subtypep)Af3_12 sf.44 .044( in Appendix II includes a registration procedure, and)J72 298 :M-.072(therefore handles )Af8_10 sf-.09(member)Af3_12 sf-.073( correctly.)A72 320 :Mf4_12 sf3.872 .387(7.3\312\312How to handle numeric intervals)J72 336 :Mf3_12 sf1.54 .154(Interval type specifiers such as )Jf8_10 sf.508(\(integer\3123\312\(7\)\))Af3_12 sf1.679 .168( \(which means those integers between 3,)J72 348 :M-.023(inclusive, and 7, exclusive; i.e., {3,4,5,6}\), cause problems because there is no )Af0_12 sf-.022(a priori )Af3_12 sf-.023(finite set of)A72 360 :M.812 .081(representatives which could answer all interval questions.  Also, it is not at all obvious how to)J72 372 :M.566 .057(generate an appropriate set of representatives at run-time.  Therefore, we will have to develop a)J72 384 :M.276 .028(different representation from the bit-vector representation we have used so far, in order to handle)J72 396 :M-.112(numeric interval type specifiers.)A72 412 :M-.015(The general representation for numeric interval type specifiers that we will use is an ordered union)A72 424 :M.289 .029(of disjoint simple intervals.  In our representation, a simple interval is a single clause of the form)J72 436 :Mf8_10 sf.507<28>Af0_12 sf.439(ntype)Af8_10 sf.507<CA>Af0_12 sf.489(low)Af8_10 sf.507<CA>Af0_12 sf.451(high)Af8_10 sf.507<29>Af3_12 sf1.156 .116(, where )Jf0_12 sf.439(ntype)Af3_12 sf.834 .083( is one of \()Jf8_10 sf.507(integer)Af3_12 sf.423 .042(, )Jf8_10 sf.507(ratio)Af3_12 sf.423 .042(, )Jf8_10 sf.507(short-float)Af3_12 sf.423 .042(, )Jf8_10 sf.507(single-float)Af3_12 sf(,)S72 449 :Mf8_10 sf.233(double-float)Af3_12 sf.194 .019(, )Jf8_10 sf.233(long-float)Af3_12 sf.408 .041(\) and )Jf0_12 sf.225(low)Af3_12 sf.117(,)Af0_12 sf.207(high)Af3_12 sf.716 .072( are the range end-points.)Jf3_9 sf0 -3 rm.175(5)A0 3 rmf3_12 sf.554 .055(  In the ordered union the)J72 461 :M.703 .07(simple intervals are not allowed to )Jf0_12 sf.213(touch)Af3_12 sf.651 .065( one another, where )Jf0_12 sf.21(touching)Af3_12 sf.635 .063( is defined as abutting so)J72 473 :M.576 .058(closely that the two simple intervals could have been coalesced into one.  This representation is)J72 485 :M.659 .066(closed under the Boolean operations of finite union, finite intersection and complement.  All of)J72 497 :M-.053(these operations are essentially )Af0_12 sf-.055(linear)Af3_12 sf-.053( in the size of the unions, since they involve a simple )Af0_12 sf-.077(merging)A72 509 :Mf3_12 sf-.009(process for the ordered unions.)A72 525 :M-.051(There is a slight complication in the definition of "touch" when doing unions in the various number)A72 537 :M4.703 .47(formats.  For example, )Jf8_10 sf1.588(\(ratio\3122/3\312\(1\)\))Af3_12 sf.722 .072( )Jf0_12 sf1.386(touches)Af3_12 sf.722 .072( )Jf8_10 sf1.588(\(ratio\312\(1\)\31213/2\))Af3_12 sf5.402 .54(, while)J72 549 :Mf8_10 sf.253(\(ratio\3122/3\312\(7/8\)\))Af3_12 sf.573 .057( does not touch )Jf8_10 sf.253(\(ratio\312\(7/8\)\31213/2\))Af3_12 sf.613 .061(.  Touching is not a property of the)J72 561 :Mf0_12 sf.13(end-points)Af3_12 sf.406 .041( of a simple interval, but of whether there are any numbers )Jf0_12 sf.664 .066(in between)Jf3_12 sf.431 .043( the two simple)J72 573 :M.664 .066(intervals.  )Jf8_10 sf.253(1)Af3_12 sf.573 .057( is between )Jf8_10 sf.253(\(ratio\3122/3\312\(1\)\))Af3_12 sf.394 .039( and )Jf8_10 sf.253(\(ratio\312\(1\)\31213/2\))Af3_12 sf.395 .04(, but )Jf8_10 sf.253(1)Af3_12 sf.323 .032( is an )Jf8_10 sf.253(integer)Af3_12 sf.482 .048(, not a)J72 585 :Mf8_10 sf.679(ratio)Af3_12 sf1.319 .132(, so there are no )Jf8_10 sf.679(ratio)Af3_12 sf1.747 .175('s between the two sets, thus they )Jf0_12 sf.679(do)Af3_12 sf1.122 .112( touch.  )Jf8_10 sf.679(7/8)Af3_12 sf2.036 .204( is between)J-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 608.24 -.24 .24 215.24 608 .24 72 608 @a72 625 :Mf3_9 sf(4)Sf3_12 sf0 3 rm.198 .02(Some Common Lisp readers )J0 -3 rmf0_12 sf0 3 rm.047(coalesce)A0 -3 rmf3_12 sf0 3 rm.206 .021( [CL90,p.694] all quoted expressions, meaning that quoted)J0 -3 rm72 640 :M.103 .01(lists which )Jf0_12 sf.028(print)Af3_12 sf.094 .009( the same, may actually )Jf0_12 sf.034(be)Af3_12 sf.077 .008( the same \()Jf8_10 sf.036(eq)Af3_12 sf.108 .011(\); since coalescing is done in a bottom-up)J72 652 :M.674 .067(fashion, sub-expressions are also coalesced.  In such a case, one may have to resort to the ")Jf8_10 sf.243(#,)Af3_12 sf(")S72 664 :M-.106(notation of Common Lisp to guarantee non-aliased representatives from the reader.)A72 678 :Mf3_9 sf.714(5)Af3_12 sf0 3 rm3.33 .333(Our representation is a slight generalization of the Common Lisp subrange specifier)J0 -3 rm72 693 :M.433 .043([CL90,p.61-62], because we do not require that )Jf0_12 sf.114(ntype)Af1_10 sf.157<CA>Af3_12 sf.127({)Af0_12 sf.127(low)Af3_12 sf.066(,)Af0_12 sf.117(high)Af3_12 sf.364 .036(}, but allow the endpoints to be)J72 705 :M-.019(any orderable numbers; this representation is well-defined due to a recent change in Common Lisp)A72 717 :M-.027(making numeric comparisons precise [CL90,p.290].)Aendp%%Page: 11 11%%BeginPageSetupinitializepage(Henry Baker; page: 11 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(11)S72 81 :Mf8_10 sf.552(\(ratio\3122/3\312\(7/8\)\))Af3_12 sf.858 .086( and )Jf8_10 sf.552(\(ratio\312\(7/8\)\31213/2\))Af3_12 sf1.139 .114(, but since )Jf8_10 sf.552(7/8)Af3_12 sf.571 .057( is a )Jf8_10 sf.552(ratio)Af3_12 sf1.567 .157(, the two simple)J72 93 :M-.054(intervals )Af0_12 sf-.062(do not)Af3_12 sf-.066( touch.)A72 109 :M-.093(The one complication remaining is the handling of different types of numbers.  By keeping different)A72 121 :M2.738 .274(unions of intervals in the 6 different number classes \()Jf8_10 sf.932(integer)Af3_12 sf.777 .078(, )Jf8_10 sf.932(ratio)Af3_12 sf.777 .078(, )Jf8_10 sf.932(short-float)Af3_12 sf(,)S72 134 :Mf8_10 sf.077(single-float)Af3_12 sf.064 .006(, )Jf8_10 sf.077(double-float)Af3_12 sf.064 .006(, )Jf8_10 sf.077(long-float)Af3_12 sf.051<29>Af3_9 sf0 -3 rm.058(6)A0 3 rmf3_12 sf.239 .024( we can handle not only all straight-forward cases,)J72 146 :M-.055(but also all intersections, unions, and complements as well.)A72 162 :M.571 .057(Consider the following example.  We know that )Jf8_10 sf.185(rational)Af3_12 sf.408 .041( is the disjoint union of )Jf8_10 sf.185(integer)Af3_12 sf.482 .048( and)J72 174 :Mf8_10 sf-.058(ratio)Af3_12 sf-.045(, so we can represent the simple interval )Af8_10 sf-.058(\(rational\312\(2/3\)\31213/2\))Af3_12 sf-.072( by)A72 190 :Mf8_10 sf-.025(\(or\312\(integer\312\(2/3\)\31213/2\)\312\(ratio\312\(2/3\)\31213/2\)\))Af3_12 sf-.019(, or after simplification,)A72 202 :Mf8_10 sf.028(\(or\312\(integer\3121\3126\)\312\(ratio\312\(2/3\)\31213/2\)\))Af3_12 sf(,)S72 218 :M.736 .074(where the integers {1,2,3,4,5,6} are represented in the first set, and the )Jf0_12 sf.213(non-integer)Af3_12 sf.64 .064( rationals )Jf0_12 sf.196(r)Af3_12 sf(,)S72 230 :M.125<322F33CA3CCA>Af0_12 sf.125(r)Af3_12 sf.474 .047<CA>JcFf1_12 sf.047<A3>Asf.474 .047(\31213/2, are represented in the second set.  Notice that)J72 246 :Mf8_10 sf-.023(\(and\312rational\312\(not\312\(integer\3121\3126\)\))Af3_12 sf-.025( becomes)A72 258 :Mf8_10 sf.012 .001(\(or\312\(integer\312*\3120\)\312\(integer\3127\312*\)\312\(ratio\312* *\)\),)J72 273 :Mf3_12 sf.826 .083(which means all the non-positive integers, plus the integers greater than 6, plus all non-integer)J72 286 :M-.026(rational numbers.)Af3_9 sf0 -3 rm(7)S0 3 rm72 302 :Mf3_12 sf-.028(Using this union of disjoint simple intervals representation, we can canonicalize )Af8_10 sf-.036(member)Af3_12 sf-.031( constructs)A72 315 :M.32 .032(into equivalent numeric ranges.)Jf3_9 sf0 -3 rm.058(8)A0 3 rmf3_12 sf.201 .02(  This simplifies the processing of )Jf8_10 sf.077(member)Af3_12 sf.264 .026( type specifier clauses.)J72 327 :M-.04(As an example of this process, we transform )Af8_10 sf-.048(\(member 3 2/3 3.4s0\))Af3_12 sf-.044( into)A72 343 :Mf8_10 sf.006 .001(\(or \(integer 3 3\) \(ratio 2/3 2/3\) \(short-float 3.4 3.4\)\).)J72 358 :Mf3_12 sf-.069(There are some technical problems which arise with floating-point number type specifiers.  In order)A72 370 :M.565 .057(to represent these numbers as numeric intervals \(with "open" and "closed" end-points\), we have)J72 382 :M-.111(implicitly assumed that floating-point numbers within each floating-point format are )Af0_12 sf-.111(totally ordered)Af3_12 sf(.)S72 394 :M.683 .068(This means that for any two floating-point numbers x,y of the same format, either x<y, x>y, or)J72 406 :M-.084(x=y; exactly one of these three conditions must hold.)A72 422 :M.966 .097(Requiring that floating point numbers be totally ordered has several implications.  First, if the)J72 434 :M.62 .062(underlying implementation supports the IEEE floating point standard [IEEE82], with its "not-a-)J72 446 :M.126 .013(numbers" \("NaN's"\), then the set of supported bit-patterns of the floating-point format may not be)J72 458 :M-.005(totally ordered.  For example, a )Af0_12 sf-.005(projective)Af3_12 sf-.005(, or unsigned, infinity, is not totally ordered with respect)A72 470 :M.475 .048(to the normal floating point values.  One result of the existence of these "NaN's" is that the type)J72 482 :M-.011(specifier )Af8_10 sf-.015(single-float)Af3_12 sf-.011( is no longer identical to the type specifier )Af8_10 sf-.015(\(single-float\312*\312*\))Af3_12 sf-.013(, because)A72 494 :M1.139 .114(the first contains the NaN's, while the second contains only the finite floating point numbers.)J72 506 :M-.018(\(Note that the IEEE NaN's +)AcFf1_12 sf-.018<A5>Asf-.018( and -)AcFf1_12 sf-.018<A5>Asf-.018( are also not included in )Af8_10 sf-.023(\(single-float\312*\312*\))Af3_12 sf(.\))S-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 519.24 -.24 .24 215.24 519 .24 72 519 @a72 536 :Mf3_9 sf(6)Sf3_12 sf0 3 rm.136 .014(In the case where one or more of the differently named floating-point types are actually identical)J0 -3 rm72 551 :M4.323 .432(\("aliased"\), we map the named type into the representational type.  For example,)J72 563 :Mf8_10 sf.14(\(short-float\312*\312*\))Af3_12 sf.312 .031( may map into )Jf8_10 sf.14(\(single-float\312*\312*\))Af3_12 sf.428 .043( during canonicalization if there is no)J72 575 :M-.033(separate )Af8_10 sf-.042(short-float)Af3_12 sf-.037( type.)A72 589 :Mf3_9 sf(7)Sf3_12 sf0 3 rm.205 .02(In our representation of rational ranges, we have assumed that )J0 -3 rmf8_10 sf0 3 rm.067(rational)A0 -3 rmf1_10 sf0 3 rm.061<BA>A0 -3 rmf8_10 sf0 3 rm.067(integer)A0 -3 rmf1_10 sf0 3 rm.085<C8>A0 -3 rmf8_10 sf0 3 rm.067(ratio)A0 -3 rmf3_12 sf0 3 rm.121 .012(, as in)J0 -3 rm72 604 :M-.069(most Common Lisp implementations.  Common Lisp may allow for implementations with rationals)A72 616 :M.63 .063(which are not integers or ratios [CL90,p.39], but standard mathematics requires that these other)J72 628 :M.544 .054(numbers )Jf0_12 sf.108(act)Af3_12 sf.436 .044( like integers and ratios\321i.e., they can be compared using <,=,>,etc., and arithmetic)J72 640 :M1.522 .152(can be performed using +,-,*,etc.  Our scheme ignores the differences between these "fake")J72 652 :M.514 .051(integers/ratios and "real" integers/ratios, and treats them both as if they were "true" integers and)J72 664 :M-.075(ratios.  In this sense our scheme ignores the )Af0_12 sf-.081(representation)Af3_12 sf-.077( of a number and focuses on its )Af0_12 sf-.084(value)Af3_12 sf(.)S72 678 :Mf3_9 sf.088(8)Af3_12 sf0 3 rm.406 .041(This canonicalization relies on )J0 -3 rmf8_10 sf0 3 rm.117(type-of)A0 -3 rmf3_12 sf0 3 rm.39 .039( [CL90,p.65-67] to produce the correct number type for)J0 -3 rm72 693 :M.612 .061(labelling the single-point simple "interval".  This usage neatly finesses the problem of "aliased")J72 705 :M2.477 .248(floating-point types, where an implementation may call a single floating-point type both)J72 717 :Mf8_10 sf.018(short-float)Af8_12 sf( )Sf3_12 sf.044 .004(and )Jf8_10 sf.018(single-float)Af3_12 sf(.)Sendp%%Page: 12 12%%BeginPageSetupinitializepage(Henry Baker; page: 12 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(12)S72 86 :M.233 .023(Second, the total order on floating-point numbers must be consistent with )Jf8_10 sf.072(eql)Af3_12 sf.166 .017(, rather than )Jf8_12 sf.087(=)Af3_12 sf.198 .02(, else)J72 98 :M1.334 .133(the canonicalization of )Jf8_10 sf.385(\(member\312)Af3_12 sf.385(x)Af8_10 sf.385<29>Af3_12 sf.609 .061( into )Jf8_10 sf.385(\(single-float\312)Af3_12 sf.385(x)Af8_10 sf.385<CA>Af3_12 sf.385(x)Af8_10 sf.385<29>Af3_12 sf.889 .089( is not valid.  This is because)J72 111 :Mf8_10 sf.106(member)Af3_12 sf.228 .023( is defined in terms of )Jf8_10 sf.106(eql)Af8_12 sf.116 .012( )Jf3_12 sf.335 .033([CL84,p.44], while intervals are defined in terms of )Jf8_12 sf.128(<)Af3_12 sf.089 .009(, )Jf8_12 sf.128(>)Af3_12 sf.296 .03(, and)J72 124 :M.224 .022(=.  The only )Jf0_12 sf.108(numeric)Af3_12 sf.291 .029( value this should cause trouble for is )Jf0_12 sf.502 .05(minus zero)Jf3_12 sf.112 .011( \()Jf8_10 sf.115(-0.0)Af3_12 sf.067(\).)Af3_9 sf0 -3 rm.086(9)A0 3 rmf3_12 sf.052 .005(  )Jf8_10 sf.115(-0.0)Af3_12 sf.342 .034( causes real)J72 136 :M-.068(headaches because it cannot be distinguished from )Af8_10 sf-.084(0.0)Af3_12 sf-.07( by the numeric comparison predicates \(=, <,)A72 148 :M1.012 .101(>, etc.\), but it )Jf0_12 sf.492(can)Af3_12 sf1.386 .139( be distinguished by )Jf8_10 sf.511(eql)Af3_12 sf1.707 .171( [CL84,p.79].  The determination of the numeric)J72 161 :M.171 .017(intervals such as )Jf8_10 sf.06(\(float\3120.0\3121.0\))Af3_12 sf.191 .019( is performed by the standard numeric ordering predicates \()Jf8_12 sf.072(<)Af3_12 sf(,)S72 174 :Mf8_12 sf.381(<=)Af3_12 sf.737 .074(, etc.\), while )Jf8_10 sf.318(\(member\312-0.0\))Af3_12 sf.647 .065( is defined to use )Jf8_10 sf.318(eql)Af3_12 sf1.021 .102( for its determination [CL84,p.44].  Our)J72 186 :M-.047(canonicalizing procedure above would represent )Af8_10 sf-.056(\(member\312-0.0\))Af3_12 sf-.038( as )Af8_10 sf-.056(\(single-float\312-0.0\312-0.0\))Af3_12 sf(,)S72 198 :M.939 .094(which is exactly the same set as )Jf8_10 sf.373(\(single-float\3120.0\3120.0\))Af3_12 sf1.327 .133(\321i.e., {)Jf8_10 sf.373(-0.0)Af3_12 sf.186(,)Af8_10 sf.373(0.0)Af3_12 sf2.074 .207(}\321because the)J72 210 :M1.859 .186(numeric ordering predicates cannot distinguish between )Jf8_10 sf.473(0.0)Af3_12 sf.736 .074( and )Jf8_10 sf.473(-0.0)Af3_12 sf1.121 .112(.  In other words, our)J72 222 :M-.014(representation\321as presented so far\321cannot handle the singleton set {)Af8_10 sf-.017(-0.0)Af3_12 sf-.014(}.  The simplest way to)A72 235 :M.204 .02(fix this problem is to define a new set of ordering predicates \()Jf8_12 sf.091(<)Af3_12 sf.08 .008(', )Jf8_12 sf.091(<=)Af3_12 sf.186 .019(', etc.\), which )Jf0_12 sf.073(can)Af3_12 sf.336 .034( distinguish)J72 247 :M.902 .09(between )Jf8_10 sf.227(0.0)Af3_12 sf.352 .035( and )Jf8_10 sf.227(-0.0)Af3_12 sf.645 .064(, and then to use these predicates in the internal workings of our ordered)J72 259 :M1.398 .14(union operations.  When canonicalizing using these predicates, we must be careful to fix up)J72 271 :M.673 .067(intervals which came in from )Jf0_12 sf.183(outside)Af3_12 sf.101 .01( )Jf8_10 sf.222(subtypep)Af3_12 sf.536 .054( and involve )Jf8_10 sf.222(0.0)Af3_12 sf.673 .067( as an end-point before further)J72 283 :M1.259 .126(processing.  This is necessary since these intervals implicitly include )Jf8_10 sf.39(-0.0)Af3_12 sf.825 .083( due to the lack of)J72 295 :M.18 .018(resolution of the standard comparison functions.  This "fixup" would add )Jf8_10 sf.056(-0.0)Af3_12 sf.139 .014( to the interval; for)J72 307 :M2.345 .234(example, converting )Jf8_10 sf.557(\(float\3120.0\3121.0\))Af3_12 sf.882 .088( into )Jf8_10 sf.557(\(float\312-0.0\3121.0\))Af3_12 sf1.51 .151(.  \(Needless to say, many)J72 319 :M-.059(computer scientists wish that )Af8_10 sf-.075(-0.0)Af3_12 sf-.065( would go quietly away.\))A72 335 :M1.82 .182(Thus, to handle floating-point numbers correctly, we must handle NaN's as a discrete type)J72 347 :M12.192 1.219(separately from the normal floating point numeric ranges \(i.e.,)J72 359 :Mf8_10 sf.103(\(and\312single-float\312\(not\312\(float\312*\312*\)\)\))Af3_12 sf.249 .025( contains the )Jf8_10 sf.103(single-float)Af3_12 sf.265 .027( NaN's and is treated as)J72 371 :M.157 .016(an elementary type disjoint from )Jf8_10 sf.049(\(single-float\312*\312*\))Af3_12 sf.149 .015(\), while within the numeric ranges we use)J72 383 :M-.07(an ordering predicate which is consistent with )Af8_10 sf-.088(eql)Af3_12 sf(.)S72 399 :M.126 .013(So far we have talked only about )Jf8_10 sf.049(rational)Af3_12 sf.076 .008( and )Jf8_10 sf.049(float)Af3_12 sf.128 .013( numbers, but not about )Jf8_10 sf.049(complex)Af3_12 sf.213 .021( numbers.)J72 411 :M4.667 .467(It was not clear in Common Lisp-84 whether type specifier expressions such as)J72 423 :Mf8_10 sf.032(\(complex\312fixnum\))Af3_12 sf.035 .004( or )Jf8_10 sf.032(\(complex\312\(integer\312-10\31210\)\))Af3_12 sf.081 .008( were legal, and if legal, how they were to)J72 435 :M.92 .092(be interpreted.  The only requirement was that both the real and imaginary parts of a complex)J72 447 :M2.482 .248(number were of the same type [CL84,p.19].  Common Lisp-90 provides a new function)J72 459 :Mf8_10 sf.092(upgraded-complex-part-type)Af3_12 sf.332 .033( [CL90,p.68], which legitimizes and defines type specifiers such)J72 471 :M.132 .013(as )Jf8_10 sf.079(\(complex\312\(integer\312-10\31210\)\))Af3_12 sf.166 .017(.  If the range of the function )Jf8_10 sf.082(upgraded-complex-part-type)A72 483 :Mf3_12 sf.798 .08(is the set {)Jf8_10 sf.396(rational)Af3_12 sf.33 .033(, )Jf8_10 sf.396(short-float)Af3_12 sf.33 .033(, )Jf8_10 sf.396(single-float)Af3_12 sf.33 .033(, )Jf8_10 sf.396(double-float)Af3_12 sf.33 .033(, )Jf8_10 sf.396(long-float)Af3_12 sf1.103 .11(}, then the)J72 495 :M-.008(various subsets of )Af8_10 sf-.01(complex)Af3_12 sf-.008( can be easily handled by a small number of representatives and treated)A72 507 :M.658 .066(as discrete types.  If, however, the range of this upgrading function includes subranges of these)J72 519 :M.23 .023(types, then in order to properly implement a decision procedure for )Jf8_10 sf.076(subtypep)Af3_12 sf.198 .02(, we are required to)J72 531 :M.32 .032(represent unions of )Jf0_12 sf.084(rectangles)Af3_12 sf.286 .029( on the complex plane, and while this is straight-forward, it is very)J72 543 :M-.022(tedious.  \(Note, however, that similar algorithms already exist in most computer graphics "window)A72 555 :M.124(systems".\))A72 571 :M-.101(The Common Lisp non-complex )Af0_12 sf-.105(numbers)Af3_12 sf-.085( are thus seen to be the Cartesian product of the 6 numeric)A72 583 :M-.088(types mentioned above, where each numeric type can be represented by an ordered union of disjoint)A72 595 :M-.029(simple intervals.  Once we can put the simple range type specifiers into a canonic form which is an)A72 607 :M.166 .017(ordered union of disjoint simple intervals, we can then combine them using )Jf8_10 sf.053(and)Af3_12 sf.175 .017( \(intersection\), )Jf8_10 sf.106(or)A72 619 :Mf3_12 sf-.05(\(union\) and )Af8_10 sf-.061(not)Af3_12 sf-.045( \(complement\).  It is then trivial to test it for emptiness, i.e., determine )Af8_10 sf-.061(type-null)Af3_12 sf(.)S72 641 :Mf4_12 sf6.436 .644(7.4\312\312Handling arrays)J72 657 :Mf3_12 sf.289 .029(Type specifiers for array types utilize the following form: )Jf8_10 sf.093(\(array\312)Af0_12 sf.079(element-type)Af8_10 sf.093<CA>Af0_12 sf.09(bounds)Af8_10 sf.093<29>Af3_12 sf.342 .034(, where)J72 669 :Mf0_12 sf-.044(element-type)Af3_12 sf-.04( is another type specifier expression and )Af0_12 sf-.05(bounds)Af3_12 sf-.043( is a form specifying what information)A72 681 :M-.015(is known about the bounds of this array.  Specifiers such as )Af8_10 sf-.019(string)Af3_12 sf-.015( and )Af8_10 sf-.019(bit-vector)Af3_12 sf-.018( are expanded)A-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 697.24 -.24 .24 215.24 697 .24 72 697 @a72 714 :Mf3_9 sf-.083(9)Af3_12 sf0 3 rm-.089(The various infinities are not numeric values.)A0 -3 rmendp%%Page: 13 13%%BeginPageSetupinitializepage(Henry Baker; page: 13 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(13)S72 82 :M1.342 .134(into )Jf8_10 sf.557(\(array\312string-char\312\(*\)\))Af3_9 sf0 -3 rm.418(10)A0 3 rmf3_12 sf.867 .087( and )Jf8_10 sf.557(\(array\312bit\312\(*\)\))Af3_12 sf1.379 .138(, as if they had been defined by)J72 94 :Mf8_10 sf-.107(deftype)Af3_12 sf-.085(.  We actually use an internal form for array type specifiers which incorporates "simplicity")A72 107 :M.274<28>Af8_10 sf.411(simple)Af3_12 sf.347(/non-)Af8_10 sf.411(simple)Af8_12 sf.493<29>Af3_12 sf1.553 .155( information as another component; this complication adds additional)J72 119 :M-.111(complexity but no additional insight.)A72 135 :M3.018 .302(The type specifier )Jf8_10 sf.99(\(array\312)Af0_12 sf.843(element-type)Af8_10 sf.99<CA>Af0_12 sf.953(bounds)Af8_10 sf.99<29>Af3_12 sf3.253 .325( can actually be canonicalized into)J72 147 :Mf8_10 sf.056(\(array\312)Af0_12 sf.05(x)Af8_10 sf.056<CA>Af0_12 sf.054(bounds)Af8_10 sf.056<29>Af3_12 sf.129 .013(, where )Jf0_12 sf.05(x)Af3_12 sf.173 .017( is the "smallest" of the finite number of array-element-types that the)J72 159 :M.469 .047(implementation provides which is large enough to hold )Jf0_12 sf.12(element-type)Af3_12 sf.462 .046( \(here "smallest" and "large)J72 171 :M.081 .008(enough" refer to )Jf8_10 sf.028(subtypep)Af3_12 sf.07 .007( recursively\).  )Jf0_12 sf.025(Element-type)Af3_12 sf.067 .007( can also be the lexical element "*".  In this)J72 183 :M-.034(case the expression represents the union of array types )Af8_10 sf-.043(\(array\312)Af0_12 sf(x)Sf8_10 sf<CA>Sf0_12 sf-.042(bounds)Af8_10 sf<29>Sf3_12 sf-.035(, where )Af0_12 sf(x)Sf3_12 sf-.036( ranges over all)A72 195 :M-.122(of the array-element-types that the implementation supports.)A72 211 :M1.309 .131(The bounds specifier can be "*", meaning no information, ")Jf0_12 sf.406(n)Af3_12 sf1.293 .129(", meaning all rank-)Jf0_12 sf.406(n)Af3_12 sf1.09 .109( arrays, or)J72 223 :M.19("\()Af0_12 sf.37(m)Af3_12 sf.128<CA>Af0_12 sf.257(n)Af3_12 sf.128(...)Af0_12 sf.257(p)Af3_12 sf.768 .077(\)", meaning all arrays with bounds \()Jf0_12 sf.37(m)Af3_12 sf.128<CA>Af0_12 sf.257(n)Af3_12 sf.128(...)Af0_12 sf.257(p)Af3_12 sf.552 .055(\).  Finally, one or more of the )Jf0_12 sf.37(m)Af3_12 sf.214 .021(, )Jf0_12 sf.257(n)Af3_12 sf.428 .043(, ...)Jf0_12 sf.257(p)Af3_12 sf.646 .065( can)J72 235 :M-.045(be "*", meaning "no information for this dimension".  Clearly, )Af8_10 sf-.056(\(array\312)Af0_12 sf(x)Sf8_10 sf-.056<CA2A29>Af3_12 sf-.046( is the countable union)A72 247 :M1.014 .101(of )Jf8_10 sf.609(\(array\312)Af0_12 sf.54(x)Af8_10 sf.609<CA>Af0_12 sf.338(i)Af8_10 sf.609<29>Af3_12 sf1.789 .179(, for all non-negative integers )Jf0_12 sf.338(i)Af3_12 sf.507 .051(, )Jf8_10 sf.609(\(array\312)Af0_12 sf.54(x)Af8_10 sf.609<CA282A2929>Af3_12 sf1.646 .165( is the countable union of)J72 259 :Mf8_10 sf.159(\(array\312)Af0_12 sf.141(x)Af8_10 sf.159<CA28>Af0_12 sf.088(j)Af8_10 sf.159<2929>Af3_12 sf.466 .047(, for all non-negative integers )Jf0_12 sf.088(j)Af3_12 sf.267 .027(, and )Jf8_10 sf.159(\(array\312)Af0_12 sf.141(x)Af8_10 sf.159<CA2834CA2A2929>Af3_12 sf.428 .043( is the countable union of)J72 271 :Mf8_10 sf-.036(\(array\312)Af0_12 sf(x)Sf8_10 sf-.036<CA2834CA>Af0_12 sf(j)Sf8_10 sf-.036<2929>Af3_12 sf-.027(, for all non-negative integers )Af0_12 sf(j)Sf3_12 sf-.028(, etc.)A72 287 :M-.004(A decision procedure for array type specifier expressions is complicated by the fact that )Af8_10 sf(subtypep)S72 299 :Mf3_12 sf-.06(can ask some difficult questions about arrays, such as:)A72 315 :Mf8_10 sf.007 .001(\(subtypep '\(array short-float \(3 4\)\))J72 326 :M.004 0(          '\(and \(array * \(* 4\)\) \(array single-float \(3 *\)\)\)\))J72 341 :Mf3_12 sf.313 .031(The answer is )Jf0_12 sf.096(true)Af3_12 sf.338 .034( for an implementation in which )Jf8_10 sf.119(short-floats)Af3_12 sf.184 .018( and )Jf8_10 sf.119(single-floats)Af3_12 sf.306 .031( have the)J72 353 :M-.022(same representation.  The question is complicated by whether the implementation utilizes different)A72 365 :M-.07(type )Af0_12 sf-.075(containers)Af3_12 sf-.068( in the different arrays, and also whether )Af8_10 sf-.089(subtypep)Af3_12 sf-.074( is smart about array bounds.)A72 381 :M2.532 .253(We first note that an implementation usually implements arrays of a finite number )Jf0_12 sf.719(k)Af3_12 sf1.462 .146( of)J72 393 :Mf0_12 sf.29(element-type)Af3_12 sf.868 .087('s and maps all other arrays into those )Jf0_12 sf.302(k)Af3_12 sf1.024 .102( different kinds of arrays.  Common Lisp)J72 405 :M.231 .023(requires )Jf0_12 sf.056(k)Af3_12 sf.195 .019( to be at least 3\321general arrays, character arrays, and bit-arrays [CL84,p.29]\).  We will)J72 417 :M.065 .007(treat each of the )Jf0_12 sf(k)Sf3_12 sf.108 .011( implementation-dependent array-types similarly but separately.  Within each of)J72 430 :M-.046(those array types, we need to handle each of the different possible array-bounds cases.)Af3_9 sf0 -3 rm-.088(11)A0 3 rm72 446 :Mf3_12 sf.45 .045(In order to handle the different possibilities of array-bounds, we must choose representatives for)J72 458 :M-.012(every array )Af0_12 sf-.013(rank)Af3_12 sf-.01( \(at least up to )Af8_10 sf-.014(array-rank-limit)Af3_12 sf-.012(\), and then within that rank, choose appropriate)A72 470 :M2.237 .224(representatives.  If Common Lisp allowed only type specifiers such as: )Jf8_10 sf.708(\(array\312*\3123\))Af3_12 sf1.278 .128( or)J72 482 :Mf8_10 sf.826(\(array\312*\312*\))Af3_12 sf2.391 .239(, then rank differences would be the only issue, and we could choose our)J72 495 :M.686 .069(representatives in advance: associate the integer 2)Jf3_9 sf0 -3 rm.08(i)A0 3 rmf3_12 sf.471 .047( with rank i, and the integer -1 with rank "*".)J72 507 :M.141 .014(Under this scheme, using two's-complement integers, -1 would represent )Jf0_12 sf.027(all)Af3_12 sf.108 .011( of the different ranks)J72 519 :M-.041([0,)AcFf1_12 sf-.041<A5>Asf-.041(\), while each particular rank would be associated with a positive power of 2.  This preselection)A72 531 :M.112 .011(strategy for representatives will not work, however, for those more complex questions allowed by)J72 543 :M-.019(Common Lisp, an example of which was shown above.)A72 559 :M-.044(We are thus led to a strategy by which appropriate representatives are chosen after a particular type)A72 571 :M.524 .052(specifier expression is examined.  We will continue to utilize integers \(as infinite bit-vectors\) to)J-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 584.24 -.24 .24 215.24 584 .24 72 584 @a72 601 :Mf3_9 sf.149(10)Af3_12 sf0 3 rm.841 .084(Although )J0 -3 rmf8_10 sf0 3 rm.198(string-char)A0 -3 rmf3_12 sf0 3 rm.596 .06( is no longer a defined Common Lisp type [CL90,p.460], we here use)J0 -3 rm72 616 :M(")Sf8_10 sf-.05(string-char)Af3_12 sf-.041(" to mean the union of possible string element types.  We could alternatively expand)A72 628 :M.084(")Af8_10 sf.103(string)Af3_12 sf.292 .029(" as "the union of [the] one or more specialized vector types" that are used to implement)J72 640 :M.895 .089(strings [CL90,p.460].)J72 654 :Mf3_9 sf(11)Sf3_12 sf0 3 rm-.009(Some Common Lisp array implementations may remember the precise actual array element type)A0 -3 rm72 669 :M.744 .074(that was used when the array was created\321i.e., the function )Jf8_10 sf.254(upgraded-array-element-type)A72 681 :Mf3_12 sf.428 .043(produces a canonical representation of the given argument type.  Such an implementation would)J72 693 :M.707 .071(appear to have an infinite number of different )Jf8_10 sf.243(array-element-type)Af3_12 sf.444 .044('s.  In this case, )Jf8_10 sf.277(subtypep)A72 705 :Mf3_12 sf.687 .069(must  keep track of the )Jf8_10 sf.308(array-element-type)Af3_12 sf.915 .091('s actually mentioned, as we do for the different)J72 717 :M-.055(dimensions, rather than attempting to canonically represent all possible )Af8_10 sf-.069(array-element-type)Af3_12 sf-.057('s.)Aendp%%Page: 14 14%%BeginPageSetupinitializepage(Henry Baker; page: 14 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(14)S72 81 :M-.029(represent array bounds, but we will allocate more than one bit position for any array bounds whose)A72 93 :M.402 .04(integer indices are )Jf0_12 sf.123(mentioned)Af3_12 sf.392 .039( in the type specifier expression; e.g., \(3\3124\), \(3\312*\), and \(*\3124\), above.)J72 105 :M.144 .014(In the particular case above, we will require a single representative for the bounds \(\), \(*\),  \(*\312*\312*\),)J72 117 :M.37 .037(\(*\312*\312*\312*\), etc., but we will require the following 4 representatives for the rank-two bounds: \(3\3124\),)J72 129 :M.47 .047(\(3\312@\), \(@\3124\), and \(@\312@\).  We use "@" to represent the "@nonymous" representative of the un-)J72 141 :M-.02(mentioned bounds.)A72 157 :M.45 .045(We find that only \(3\3124\) belongs to the set represented by the specifier "\(3\3124\)", but both \(3\3124\) and)J72 169 :M1.217 .122(\(3\312@\) belong to the set "\(3\312*\)", both \(3\3124\) and \(@\3124\) belong to "\(*\3124\)", and all four elements)J72 181 :M.508 .051(belong to "\(*\312*\)".  In other words, array bounds specifiers like "\(3\312*\)" represent )Jf0_12 sf.125(slices)Af3_12 sf.473 .047( through a)J72 193 :M.107 .011(multidimensional rectangular box of bits, each of which is a particular representative for the array)J72 205 :M1.945 .195(bounds mentioned in its coordinate position.  The process of choosing representatives and)J72 217 :M-.131(allocating bit-positions is similar to, but much more complicated than that for )Af0_12 sf-.133(registering)Af3_12 sf-.147( elements in)A72 229 :M.722 .072(a )Jf8_10 sf.624(member)Af3_12 sf1.641 .164( construct.  In general, the number of bit positions required for rank r is equal to)J72 241 :M.149(\(d)Af3_9 sf0 3 rm.134(1)A0 -3 rmf3_12 sf.16(+1\)\(d)Af3_9 sf0 3 rm.134(2)A0 -3 rmf3_12 sf.134(+1\)...\(d)Af3_9 sf0 3 rm.089(r)A0 -3 rmf3_12 sf.511 .051(+1\), where the d)Jf3_9 sf0 3 rm.075(i)A0 -3 rmf3_12 sf.546 .055( are the number of distinct integers mentioned in dimension i)J72 254 :M-.067(\(not counting "*"\).  In the case where no specific dimensions are mentioned, the formula gives 1 bit)A72 266 :M.334 .033(position, which is equivalent to the unmentionable bounds \(@\312@\312\311\312@\).)J72 282 :M.273 .027(In the example above, we will need 1 bit position for arrays of rank 0, 1 bit position for arrays of)J72 294 :M.015 .002(rank 1, 4 bit positions for arrays of rank 2, and 1 bit position for arrays of rank 3 and above.  Rank)J72 306 :M.815 .082(0 is mapped into bit position 0, rank 1 is mapped into bit position 1, rank 2 is mapped into bit)J72 318 :M1.001 .1(positions 2-5, rank 3 is mapped into bit position 6 and so forth for higher ranks.  For the row)J72 330 :M.043 .004(dimensions, we assign "3" the index 0 and "@" the index 1; for the column dimensions, we assign)J72 342 :M-.023("4" the index 0 and "@" the index 1; we utilize the same row-major order as Common Lisp.  Thus,)A72 354 :M1.512 .151(the encoding for )Jf8_10 sf.522(\(array\312*\312\(3\3124\)\))Af3_12 sf1.612 .161( \(ignoring the element-types\) is )Jf8_10 sf.522(#B00000100)Af3_12 sf.58 .058( or )Jf8_10 sf.522(+4)Af3_12 sf1.306 .131(; the)J72 366 :M.908 .091(encoding for )Jf8_10 sf.281(\(array\312*\312\(3\312*\)\))Af3_12 sf.273 .027( is )Jf8_10 sf.281(#B00001100)Af3_12 sf.312 .031( or )Jf8_10 sf.281(+12)Af3_12 sf.699 .07(; the encoding for )Jf8_10 sf.281(\(array\312*\312\(*\3124\)\))Af3_12 sf.43 .043( is)J72 378 :Mf8_10 sf.815(#B00010100)Af3_12 sf.905 .091( or )Jf8_10 sf.815(+20)Af3_12 sf2.025 .203(; the encoding for )Jf8_10 sf.815(\(array\312*\312\(*\312*\)\))Af3_12 sf.792 .079( is )Jf8_10 sf.815(#B00111100)Af3_12 sf.905 .091( or )Jf8_10 sf.815(+60)Af3_12 sf1.794 .179(.  Since)J72 390 :Mf8_10 sf.787(\(logand\31212\31220\))Af3_12 sf.888(=)Af8_10 sf.787(4)Af3_12 sf2.677 .268(, the two type specifier expressions are equivalent \(not considering)J72 403 :M-.018(element-type and simplicity\).  \(Notice that )Af8_10 sf-.023(\(array\312*\3123\))Af3_12 sf-.018( is encoded as 2)Af3_9 sf0 -3 rm(6)S0 3 rmf3_12 sf-.019(=64, while )Af8_10 sf-.025(\(array\312*\312*\))A72 415 :Mf3_12 sf(is encoded as -1.\))S72 431 :M.796 .08(We do not even require the use of an entire integer for our bit-vector, since for any given type)J72 443 :M.509 .051(specifier expression, only a finite number of different array ranks are actually mentioned.  If we)J72 455 :M-.104(allocate 1 more bit position than the highest rank actually mentioned, then we will be sure to include)A72 467 :M-.095(at least one representative for all the higher-ranked arrays.  Using this technique, we can allocate the)A72 479 :M-.074(array bounds bit-vectors for all different specialized element-types and simplicities as subsequences)A72 491 :M-.021(of a single bit-vector.  Furthermore, this array bit-vector could be a portion of the bit-vector for the)A72 503 :M-.081(basic non-array type information.)A72 519 :M.191 .019(Handling the )Jf8_10 sf.058(member)Af3_12 sf.203 .02( construct with elements which are array objects is somewhat problematical.)J72 531 :M.553 .055(Unless a type specifier is constructed at run-time, it is impossible to ask a non-trivial )Jf8_10 sf.222(subtypep)A72 543 :Mf3_12 sf-.084(question about array objects.  This is due to the fact that the types of arrays created by the reader are)A72 555 :M1.561 .156(defined by Common Lisp [CL84, p.346-357] as being simple vectors of element-types )Jf8_10 sf.453(bit)Af3_12 sf(,)S72 568 :Mf8_10 sf.023(string-char)Af3_12 sf.026 .003( or )Jf8_10 sf(t)Sf3_12 sf.067 .007(, or simple arrays of element-type )Jf8_10 sf(t)Sf3_12 sf(.)Sf3_9 sf0 -3 rm(12)S0 3 rmf3_12 sf.061 .006(  However, the simulation of )Jf8_10 sf.023(typep)Af3_12 sf.075 .007( using)J72 580 :Mf8_10 sf.434(subtypep)Af3_12 sf1.129 .113( above requires the ability to handle any type of object within a )Jf8_10 sf.434(member)Af3_12 sf1.806 .181( construct,)J72 592 :M-.085(including array objects.)A72 608 :M.229 .023(Handling actual array objects in a )Jf8_10 sf.079(member)Af3_12 sf.26 .026( construct is possible using our algorithm by increasing)J72 620 :M-.065(the number of bits within the subsequence of the bit-vector which are allocated to the actual bounds)A72 632 :M.871 .087(of the given array.  In other words, if an array of actual dimensions \(3\3124\) were mentioned in a)J72 644 :Mf8_10 sf.065(member)Af3_12 sf.186 .019( construct, then we would need to allocate at least two bits for arrays of dimension "\(3\3124\)")J72 656 :M-.099(in the bit-vector; one bit for this specifically mentioned array, and one bit for all the anonymous, un-)A-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 673.24 -.24 .24 215.24 673 .24 72 673 @a72 690 :Mf3_9 sf3.609(12)Af3_12 sf0 3 rm14.285 1.429(The one type of non-trivial question one could ask is)J0 -3 rm72 705 :Mf8_10 sf.023(\(type-equal\312\(member\312"a"\)\312\(member\312"a"\)\))Af3_12 sf.066 .007(, i.e., does the reader share constant strings or not?)J72 717 :M-.041(This issue was discussed before in the footnote on the ")Af8_10 sf-.052(member)Af3_12 sf-.043(" section.)Aendp%%Page: 15 15%%BeginPageSetupinitializepage(Henry Baker; page: 15 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(15)S72 81 :M-.033(mentioned arrays of the same dimensions.  However, for non-)Af8_10 sf-.04(simple)Af3_12 sf-.032( arrays, the actual dimensions)A72 93 :M.109 .011(may not be well-defined, because they can be changed by )Jf8_10 sf.037(adjust-array)Af3_12 sf.063 .006( if they are )Jf8_10 sf.037(adjustable)Af3_12 sf(.)S72 105 :M-.048(\(This is the only situation within Common Lisp-84 [CL84] where an object can change its type and)A72 117 :M-.11(remain )Af8_10 sf-.127(eq)Af3_12 sf-.101( to itself\321a highly undesirable situation.\))A72 133 :M1.774 .177(For these reasons, we recommend against including array objects as elements in a )Jf8_10 sf.682(member)A72 145 :Mf3_12 sf.237 .024(construct, or trying to handle this case in a more algorithmic manner, until Common Lisp defines)J72 157 :M-.136(the semantics more completely.)A72 179 :Mf4_12 sf4.498 .45(7.5\312\312Handling user-defined data types)J72 195 :Mf3_12 sf.718 .072(There are three kinds of user-defined data types in Common Lisp\321)Jf8_10 sf.217(deftype)Af3_12 sf.444 .044( types, )Jf8_10 sf.244(defstruct)A72 207 :Mf3_12 sf-.013(types and )Af8_10 sf-.016(defclass)Af3_12 sf-.013( \(CLOS\) types.  )Af8_10 sf-.016(deftype)Af3_12 sf-.013( types are easily dismissed as type specifier "macros")A72 219 :M2.13 .213(which are expanded every time they appear, and expand into non-recursive type specifier)J72 231 :M.473 .047(expressions.  Thus, )Jf8_10 sf.149(deftype)Af3_12 sf.431 .043( types are used for brevity only, and do not require much additional)J72 243 :M.102 .01(machinery to handle properly.  In this manner, many Common Lisp built-in type specifiers can be)J72 255 :M.19 .019(treated as )Jf8_10 sf.073(deftype)Af3_12 sf.076<2773D1>Af8_10 sf.073(bit)Af3_12 sf.061 .006(, )Jf8_10 sf.073(\(mod\312)Af0_12 sf.073(n)Af8_10 sf.073<29>Af3_12 sf.061 .006(, )Jf8_10 sf.073(\(signed-byte\312)Af0_12 sf.057(s)Af8_10 sf.073<29>Af3_12 sf.061 .006(, )Jf8_10 sf.073(\(string\312)Af0_12 sf.055(size)Af8_10 sf.073<29>Af3_12 sf.276 .028(, etc.\321an approach used)J72 267 :M-.104(by many Common Lisp implementations.)A72 283 :Mf8_10 sf-.027(defstruct)Af3_12 sf-.021( types are so called, because they are defined by the user with the )Af8_10 sf-.027(defstruct)Af3_12 sf-.022( construct,)A72 295 :M.136 .014(which defines a new "structured" type with components \(like a )Jf0_12 sf.039(record)Af3_12 sf.109 .011( in other languages\).  If one)J72 307 :Mf8_10 sf.321(defstruct)Af3_12 sf.95 .095( type "extends" another by including all of its components, then the second type is)J72 319 :M.141 .014(considered a subtype of the first.  Objects for a particular )Jf8_10 sf.052(defstruct)Af3_12 sf.173 .017( type, also called "instances")J72 331 :M.126 .013(of the )Jf8_10 sf.067(defstruct)Af3_12 sf.252 .025( type, are normally created using an automatically-defined, specialized function)J72 343 :Mf8_10 sf.203(make-<typename>)Af3_12 sf.56 .056(.  CLOS types are those types added by CLOS as new classes are defined by)J72 355 :Mf8_10 sf.502(defclass)Af3_12 sf1.35 .135(.  For the purposes of our decision procedure, )Jf8_10 sf.502(defclass)Af3_12 sf1.552 .155( types act analogously to)J72 367 :Mf8_10 sf.048(defstruct)Af3_12 sf.157 .016( types.)J72 383 :Mf8_10 sf-.069(defstruct)Af3_12 sf-.054( and )Af8_10 sf-.069(defclass)Af3_12 sf-.057( types are more troublesome than )Af8_10 sf-.069(deftype)Af3_12 sf-.057( types, because they materially)A72 395 :M-.006(extend the Common Lisp type system at run-time.  As a result, they introduce some ambiguities in)A72 407 :M.114 .011(the interpretation of )Jf8_10 sf.036(subtypep)Af3_12 sf.075 .007(.  For example, if )Jf8_10 sf.036(foo)Af3_12 sf.037 .004( is a )Jf8_10 sf.036(defstruct)Af3_12 sf.086 .009( type, and no instances of )Jf8_10 sf.054(foo)A72 419 :Mf3_12 sf.816 .082(have yet been created using the function )Jf8_10 sf.277(make-foo)Af3_12 sf.783 .078(, what should be the answer to the question)J72 431 :Mf8_10 sf.323(\(subtypep\312'foo\312nil\))Af3_12 sf.757 .076(?  At the time the question is asked, the answer is yes \()Jf8_10 sf.323(t)Af3_12 sf.819 .082(\), but once an)J72 443 :M-.032(instance has been created, the answer should be no \()Af8_10 sf-.039(nil)Af3_12 sf-.03(\).  Unfortunately, if one requires )Af8_10 sf-.045(subtypep)A72 455 :Mf3_12 sf.084 .008(to accurately answer any such question regarding user-defined type elements, )Jf8_10 sf.024(subtypep)Af3_12 sf.067 .007( would be)J72 467 :M.139 .014(required to be able to enumerate all elements of the given type.  This process could require a very)J72 479 :M-.079(long time, and would be unnecessary in all but the most perverse circumstances.)A72 495 :M-.051(It is unreasonable to expect Common Lisp's )Af8_10 sf-.062(subtypep)Af3_12 sf-.049( predicate to register as representatives every)A72 507 :M1.286 .129(instance of a )Jf8_10 sf.533(defstruct)Af3_12 sf1.692 .169( datatype ever created.  Yet without such a registration procedure,)J72 519 :Mf8_10 sf(subtypep)Sf3_12 sf.017 .002( will never be able to properly answer all possible questions about those objects.  This is)J72 531 :M1.143 .114(because the user can always remember each created instance himself, and then ask\321utilizing)J72 543 :Mf8_10 sf.517(member)Af3_12 sf1.418 .142(\321whether the list of instances was equal to the entire set; )Jf8_10 sf.517(subtypep)Af3_12 sf1.424 .142( would have to)J72 555 :M1.809 .181(remember all the instances itself in order to answer correctly.  However, if we change the)J72 567 :M.3 .03(interpretation of user-defined data types slightly, we can correctly answer all questions regarding)J72 579 :M-.055(user-defined data types.)A72 595 :M.141 .014(We propose that )Jf8_10 sf.048(defstruct)Af3_12 sf.149 .015( itself always create at least one "dummy" anonymous instance of the)J72 607 :M.093 .009(data type.  Since the user cannot become acquainted with this "dummy" instance, he will never be)J72 619 :M.553 .055(able to ask a )Jf8_10 sf.286(type-equal)Af3_12 sf.936 .094( question, but only a type containment question.  Every user-defined)J72 631 :M1.775 .178(datatype is then non-empty at birth, since the "dummy" anonymous element is created and)J72 643 :M.496 .05(registered with the type system.  Yet since every call to )Jf8_10 sf.186(make-xxx)Af3_12 sf.645 .064( creates a brand-new instance)J72 655 :M.527 .053(never before seen, the user can never ask the precise question about exactly which instances are)J72 667 :M-.098(elements of the type.)A72 683 :M.962 .096(This policy is reasonable, since it is already followed for the built-in types\321it would be most)J72 695 :M1.326 .133(unusual if a Common Lisp system did not create at least one element of each of the built-in)J72 707 :M.417 .042(datatypes at initialization or system construction time.  \(We have already seen a similar problem)Jendp%%Page: 16 16%%BeginPageSetupinitializepage(Henry Baker; page: 16 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(16)S72 81 :M1.75 .175(with )Jf8_10 sf.647(symbol)Af3_12 sf2.204 .22('s\321we need a symbol not mentioned or mentionable by the user\321hence the)J72 93 :Mf8_10 sf.296(rumpelstiltskin)Af3_12 sf1.032 .103( symbol.\)  Therefore, the existence of anonymous elements of user-defined)J72 106 :M-.066(datatypes which the user cannot name should not be unsettling.)Af3_9 sf0 -3 rm-.122(13)A0 3 rm72 122 :Mf3_12 sf-.062(Another interesting question arises from the need of all Lisp systems to perform garbage collection.)A72 134 :M.219 .022(Suppose that all instances of )Jf8_10 sf.075(foo)Af3_12 sf.244 .024( are garbage-collected; will )Jf8_10 sf.075(\(subtypep\312'foo\312nil\))Af3_12 sf.254 .025( now answer)J72 146 :M.53 .053(true?  If a "dummy" instance of )Jf8_10 sf.211(foo)Af3_12 sf.519 .052( is still held by the type system, then it will not be garbage-)J72 158 :M.391 .039(collected, and the answer will be "no".  This interpretation is equivalent to saying, "yes, the type)J72 170 :Mf8_10 sf-.105(foo)Af3_12 sf-.082( has elements, but they are not accessible".  Since the determination of accessibility is extremely)A72 182 :M-.011(expensive, requiring an immediate full garbage collection, a more efficient, and hence more useful)A72 194 :Mf8_10 sf-.139(subtypep)Af3_12 sf-.109( is obtained using the simpler interpretation of including inaccessible elements in the type.)A72 211 :M.258 .026(Handling )Jf8_10 sf.062(defclass)Af3_12 sf.157 .016( \(CLOS\) types is even easier for )Jf8_10 sf.062(subtypep)Af3_12 sf.164 .016( than handling )Jf8_10 sf.062(defstruct)Af3_12 sf.19 .019( types.)Jf3_9 sf0 -3 rm.093(14)A0 3 rm72 223 :Mf3_12 sf.692 .069(This is because CLOS is more explicit about the meaning of classes, as well as the mapping of)J72 235 :M1.557 .156(classes into types.  A class cannot be )Jf8_10 sf.619(type-equal)Af3_12 sf1.766 .177( to one of its superclasses or subclasses)J72 247 :M.884 .088([CL90,p.774], and CLOS goes on to require certain additional answers to )Jf8_10 sf.272(subtypep)Af3_12 sf1.153 .115( questions)J72 259 :M-.034(where certain built-in types are concerned.  The fact that a class cannot be )Af8_10 sf-.043(type-equal)Af3_12 sf-.035( to a sub- or)A72 271 :M.247 .025(super-class, guarantees that our technique of always registering a single dummy element for each)J72 284 :M-.005(different class will always work.)Af3_9 sf0 -3 rm(15)S0 3 rmf3_12 sf-.005(  That dummy element serves as a distinguishing element which)A72 297 :M-.038(distinguishes that class from every other class.)Af3_9 sf0 -3 rm-.074(16)A0 3 rm72 313 :Mf3_12 sf.104 .01(Our decision procedure does not handle certain cases where CLOS is used to extend the Common)J72 325 :M.311 .031(Lisp-84 primitive datatypes, specifically numbers and arrays, which )Jf8_10 sf.084(subtypep)Af3_12 sf.325 .032( handles specially.)J72 337 :M-.08(Let us first consider the problem of extended numbers.  If the numeric type which is being extended)A72 349 :M1.912 .191(has the )Jf0_12 sf.768(metaclass)Af3_12 sf.398 .04( )Jf8_10 sf.876(built-in-class)Af3_12 sf3.033 .303(\321the normal case\321then any extension is an error)J72 361 :M-.025([CL90,p.781].  If the numeric type has the metaclass )Af8_10 sf-.032(standard-class)Af3_12 sf-.025(, then the new type will be a)A72 373 :M-.046(proper subtype of its parent, which means that any numeric operations applicable to the parent type)A72 385 :M.953 .095(will be applicable to the new type.  This is because Common Lisp numeric operations are )Jf0_12 sf.419(not)A72 397 :Mf3_12 sf.594 .059("generic" [CL90,p.1024], and therefore cannot be specialized to operate differently for this new)J72 409 :M.277 .028(type.  However, this lack of specialization applies also to slots.  Since the numeric operations are)J-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 428.24 -.24 .24 215.24 428 .24 72 428 @a72 445 :Mf3_9 sf.027(13)Af3_12 sf0 3 rm.122 .012(Some )J0 -3 rmf8_10 sf0 3 rm.036(defstruct)A0 -3 rmf3_12 sf0 3 rm.109 .011( types are not intended to have instances, but are provided for the convenience)J0 -3 rm72 460 :M.505 .051(of two or more other )Jf8_10 sf.21(defstruct)Af3_12 sf.618 .062( types which "include" the first.  Since Common Lisp does not)J72 472 :M-.083(provide any mechanism for a programmer to enforce this intention, our scheme is consistent.)A72 486 :Mf3_9 sf.102(14)Af3_12 sf0 3 rm.374 .037(Note that in this paper, we show how to implement )J0 -3 rmf8_10 sf0 3 rm.136(subtypep)A0 -3 rmf3_12 sf0 3 rm.212 .021(, not )J0 -3 rmf8_10 sf0 3 rm.136(typep)A0 -3 rmf3_12 sf0 3 rm.33 .033(.  This means that we)J0 -3 rm72 501 :M.179 .018(depend upon a correct implementation of )Jf8_10 sf.053(typep)Af3_12 sf.132 .013( for the proper behavior of )Jf8_10 sf.053(subtypep)Af3_12 sf.132 .013(.  For CLOS)J72 513 :M1.14 .114(classes, the implementation of )Jf8_10 sf.328(typep)Af3_12 sf1.043 .104( might be quite involved and complicated.  Some CLOS)J72 526 :M4.709 .471(implementations might even find it advantageous to implement )Jf8_10 sf1.299(\(typep\312)Af8_12 sf1.559(x)Af8_10 sf1.299<CA>Af8_12 sf1.559(y)Af8_10 sf1.299<29>Af3_12 sf2.345 .234( as)J72 539 :Mf8_10 sf.285(\(values\312\(subtypep\312\(type-of\312)Af8_12 sf.342(x)Af8_10 sf.285<29CA>Af8_12 sf.342(y)Af8_10 sf.285<2929>Af3_12 sf.58 .058(, since the )Jf8_10 sf.285(subtypep)Af3_12 sf1.216 .122( implementation described here)J72 551 :M-.051(already provides the machinery to answer the hard questions.  However, the proper implementation)A72 563 :M-.034(of )Af8_10 sf-.047(typep)Af3_12 sf-.036( is outside the scope of this paper.)A72 577 :Mf3_9 sf.292(15)Af3_12 sf0 3 rm1.404 .14(CLOS defines )J0 -3 rmf8_10 sf0 3 rm.39(\(subtypep\312)A0 -3 rmf3_12 sf0 3 rm.346(c)A0 -3 rmf8_10 sf0 3 rm.39<CA>A0 -3 rmf3_12 sf0 3 rm.39(d)A0 -3 rmf8_10 sf0 3 rm.39<29>A0 -3 rmf3_12 sf0 3 rm.195<CA>A0 -3 rmf1_10 sf0 3 rm.357<BA>A0 -3 rmf3_12 sf0 3 rm.292<CA64>A0 -3 rmf1_10 sf0 3 rm.463<CE>A0 -3 rmf3_12 sf0 3 rm1.142 .114(cpl\(c\), where cpl\(c\) is the "class precedence list" of c)J0 -3 rm72 592 :M5.834 .583([CL90,p.774,780-781], i.e., cpl\(c\)\312)Jf1_10 sf1.061<BA>Af3_12 sf.951<CA7B78>Af1_10 sf1.378<CE>Af3_12 sf.858(Classes\312|\312)Af8_10 sf1.16(\(subtypep\312)Af3_12 sf1.03(c)Af8_10 sf1.16<CA>Af3_12 sf1.16(x)Af8_10 sf1.16<29>Af3_12 sf1.309(=)Af8_10 sf1.16(t)Af3_12 sf3.85 .385(}.  However,)J72 604 :Mf8_10 sf.16(\(subtypep)Af3_10 sf.067<CA>Af3_12 sf.142(c)Af3_10 sf.067<CA>Af3_12 sf.16(d)Af8_10 sf.16<29>Af3_12 sf.296 .03( if and only if d)Jf1_10 sf.19<CE>Af3_12 sf.425 .043(cpl\(c\) if and only if cpl\(c\))Jf1_10 sf.19<CA>Af3_12 sf.469 .047(cpl\(d\).  Since the bit-vectors for c,d)J72 616 :M-.048(encode information equivalent to the sets cpl\(c\),cpl\(d\), our comparing of the bit-vectors is formally)A72 628 :M-.13(equivalent to the CLOS definition.)A72 642 :Mf3_9 sf.166(16)Af3_12 sf0 3 rm.788 .079(Unlike the situation with structures, a Common Lisp programmer can \(obliquely\) express his)J0 -3 rm72 657 :M-.04(intention that no direct instances of a particular class be created, by overloading )Af8_10 sf-.052(make-instance)Af3_12 sf-.054( to)A72 669 :M.152 .015(signal an error.  In such a case, our dummy element is a bastard.  Since CLOS does not allow any)J72 681 :M.363 .036(subclass of this class to be )Jf8_10 sf.15(type-equal)Af3_12 sf.401 .04( to the class, even though the sets of \(direct and indirect\))J72 693 :M-.036(instances may in fact be the same, CLOS thus destroys the extensionality of types.  [McAllester86])A72 705 :M-.054(calls classes of this kind )Af0_12 sf-.059(uninstantiable classes)Af3_12 sf-.065(.  We believe that CLOS should allow a programmer)A72 717 :M-.034(to assert that a class is )Af8_10 sf-.049(uninstantiable)Af3_12 sf-.038(.  We discuss this issue again in Section 9.)Aendp%%Page: 17 17%%BeginPageSetupinitializepage(Henry Baker; page: 17 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(17)S72 81 :M.129 .013(not specialized, they cannot access any slots specific to the new type, and therefore their behavior)J72 93 :M1.508 .151(will be exactly the same as with instances of the parent type\321i.e., "normal" numbers.  The)J72 105 :M.864 .086(instances of the extended type will be numbers with some "hidden" slots which only we know)J72 117 :M.633 .063(about, and since most arithmetic operations will generate a new "normal" number, these hidden)J72 129 :M-.059(slots will not be propagated.  These "extended numbers" are thus essentially useless.)A72 145 :M.107 .011(A more interesting possibility is that posed by extending the )Jf8_10 sf.036(array)Af3_12 sf.108 .011( type/class.  Since the standard)J72 157 :M.381 .038(array manipulating functions are not "generic" [CL90,p.1024], we would have the same problem)J72 169 :M-.071(that we had with extended numbers\321the behavior of these functions could not be specialized to the)A72 181 :M1.584 .158(extended type.  However, array manipulations tend to create new array instances much less)J72 193 :M1.531 .153(frequently than numeric calculations create new numbers, so the lack of propagation of any)J72 205 :M-.064(extended type-specific slots would not be a problem.  The major problem for such an extended type)A72 217 :M-.044(is how an instance could be created.  )Af8_10 sf-.056(make-array)Af3_12 sf-.046( could not be used, since it would create a normal)A72 229 :M.063 .006(array type.  Since the array type is extensible, it is presumably an instance of )Jf8_10 sf.024(standard-class)Af3_12 sf.046 .005(, in)J72 241 :M.222 .022(which case there is an overloaded definition of )Jf8_10 sf.075(make-instance)Af3_12 sf.219 .022( which works for this type, which)J72 253 :M.061 .006(can be used to overload )Jf8_10 sf.023(make-instance)Af3_12 sf.06 .006( for the extended type.  Extending our )Jf8_10 sf.023(subtypep)Af3_12 sf.092 .009( decision)J72 265 :M-.096(procedure to handle such array types could be quite difficult.)A72 281 :M-.068(As a result of these observations, we expect that most CLOS implementations will have all numeric)A72 293 :M-.034(and array types "built-in", and hence incapable of extension/subclassing.  In such implementations,)A72 305 :M.22 .022(numbers and arrays will then be disjoint from all other CLOS classes, as well as from each other,)J72 317 :M.883 .088(and so our "divide and conquer" strategy for dealing with numbers and arrays will continue to)J72 329 :M.336(work.)A72 345 :M.652 .065(There is one other aspect of CLOS which is quite troublesome for our type system.  This is the)J72 357 :M.029 .003(possibility of an object )Jf0_12 sf.037 .004(changing its type)Jf3_12 sf.032 .003( dynamically during run-time.  With the sole exception of)J72 369 :M.025 .002(non-simple arrays, which can change their array bounds \(and hence their type\) dynamically, every)J72 381 :M.466 .047(other Common Lisp-84 object has a static type\321i.e., the type of an object does not change after)J72 393 :M.365 .036(creation.  The CLOS function )Jf8_10 sf.119(change-class)Af3_12 sf.266 .027( and the macro )Jf8_10 sf.119(defclass)Af3_12 sf.328 .033( can both modify the type)J72 405 :M.969 .097(system in such a way that an object's type can change dynamically.  Both operations have the)J72 417 :M-.069(possibility of inflicting major damage on the type system, and are therefore quite dangerous.  Given)A72 429 :M.026 .003(the major uses of )Jf8_10 sf.011(subtypep)Af3_12 sf.041 .004( in Common Lisp\321for declarations and storage allocation\321it appears)J72 441 :M-.097(that much is lost through these dynamically changing types.)A72 463 :Mf4_12 sf5.815 .581(7.6\312\312Handling )Jf4_10 sf1.238(SATISFIES)A72 479 :Mf3_12 sf.297 .03(The existence of )Jf8_10 sf.102(satisfies)Af3_12 sf.329 .033( clauses in a type specifier expression could be considered sufficient)J72 491 :M.461 .046(grounds for )Jf8_10 sf.151(subtypep)Af3_12 sf.443 .044( answering "can't determine".  We can handle many of the easier forms of)J72 503 :Mf8_10 sf.655(subtypep)Af3_12 sf1.833 .183( involving )Jf8_10 sf.655(satisfies)Af3_12 sf2.032 .203(, however, if we first expand the argument type specifier)J72 515 :M.939 .094(expressions in the manner indicated in the "obviously trivial" version of )Jf8_10 sf.298(subtypep)Af3_12 sf1.332 .133( previously)J72 527 :M-.034(described in section 5.  If this expansion is performed in the proper order, )Af8_10 sf-.044(subtypep)Af3_12 sf-.035( should at least)A72 539 :M-.091(be able to answer trivial questions such as:)A72 555 :Mf8_10 sf.001(\(subtypep\312'\(and\312integer\312\(satisfies\312oddp\)\)\312'integer\).)A72 570 :Mf3_12 sf-.005(While this is not a decision procedure, this set of heuristics should be capable of handling many of)A72 582 :M-.067(the easier questions; it may also slightly speed up questions not involving )Af8_10 sf-.086(satisfies)Af3_12 sf(.)S72 598 :M.594 .059(One could also extend the basic \(non-)Jf8_10 sf.191(satisfies)Af3_12 sf.609 .061(\) decision procedure to handle certain cases of)J72 610 :Mf8_10 sf.381(satisfies)Af3_12 sf.977 .098( as follows.  Treat each predicate symbol that occurs in a )Jf8_10 sf.381(satisfies)Af3_12 sf.912 .091( clause as an)J72 622 :Mf0_12 sf-.092(uninterpreted)Af3_12 sf-.092( type name, and use a decision procedure for uninterpreted monadic predicate symbols)A72 634 :M.388 .039([Church56] [Rackoff75] to decide the )Jf8_10 sf.11(subtypep)Af3_12 sf.289 .029( question.  Such an extended )Jf8_10 sf.11(subtypep)Af3_12 sf.438 .044( decision)J72 646 :M.101 .01(procedure would then be well-defined, and would answer "can't determine" only when the answer)J72 658 :M-.066(would depend upon the specific interpretation of the predicate symbol\321i.e., the actual semantics of)A72 670 :M.145 .015(the predicate.  This extended )Jf8_10 sf.049(subtypep)Af3_12 sf.171 .017( decision procedure would then be NP-complete, since we)Jendp%%Page: 18 18%%BeginPageSetupinitializepage(Henry Baker; page: 18 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(18)S72 82 :M-.05(could use it to do tautology-testing.)Af3_9 sf0 -3 rm-.049(17)A0 3 rmf3_12 sf-.054(  While strictly more powerful than the non-extended decision)A72 94 :M.264 .026(procedure, we do not recommend this approach, since the additional machinery could slow down)J72 106 :Mf0_12 sf-.031(every)Af3_12 sf( )Sf8_10 sf-.035(subtypep)Af3_12 sf-.028( decision, even when it did not involve )Af8_10 sf-.035(satisfies)Af3_12 sf(.)S72 128 :Mf4_12 sf4.101 .41(7.7\312\312Putting it all together)J72 144 :Mf3_12 sf-.05(In order to decide a )Af8_10 sf-.065(subtypep)Af3_12 sf-.053( question, we divide the whole question into several sub-questions by)A72 156 :M-.072(computing the homomorphic image of the type-specifier expressions for each of the kingdoms.  For)A72 168 :M4.578 .458(example, the homomorphic image of )Jf8_10 sf1.282(\(or\312symbol\312\(member\3123\)\312bit-vector\))Af3_12 sf1.959 .196( is)J72 180 :Mf8_10 sf.156(\(or\312symbol\312nil\312nil\))Af1_10 sf.143<BA>Af8_10 sf.156(symbol)Af3_12 sf.13 .013(, )Jf8_10 sf.156(\(integer\3123\3123\))Af3_12 sf.197 .02(, or )Jf8_10 sf.156(\(array\312bit\312*\))Af3_12 sf.495 .049(, etc., depending upon the)J72 192 :M-.034(kingdom being decided.  Each of these subquestions is then passed in turn to decision "experts" for)A72 204 :M.386 .039(each of the main type "kingdoms" of Common Lisp: flat or discrete types, numeric ranges, array)J72 216 :M1.039 .104(specifiers, and user-defined types.  The answer to the whole question is only true if )Jf0_12 sf.258(all)Af3_12 sf.72 .072( of the)J72 228 :M1.233 .123(kingdom experts answers true.  This conjunction results from the nature of the Lisp datatype)J72 240 :M-.091(Boolean algebra as the Cartesian product of the disjoint kingdoms.)A72 256 :M1.337 .134(Thus, we have shown how any )Jf8_10 sf.467(subtypep)Af3_12 sf1.307 .131( question without the )Jf8_10 sf.467(satisfies)Af3_12 sf1.371 .137( construct can be)J72 268 :M.858 .086(answered by building a constructive model of the types \(=\312sets\) involved, and then performing)J72 280 :M1.015 .102(Boolean operations on those sets.  It has also been shown that, if ranges are not involved, the)J72 292 :M-.005(representation of any type specifier expression can be a single binary integer, and that any subtype)A72 304 :M.54 .054(question can be answered with a single logical bit-vector computation.  The size in bits of these)J72 316 :M.135 .014(integers is relatively small in practice \(perhaps 50 bits\), although in the worst case, they can grow)J72 328 :M.186 .019(exponentially in the size of the type specifier expression \(due to the explosion of bits required for)J72 340 :M-.051(complex expressions involving higher-order arrays\).)A72 356 :M-.064(The independent computation for each of the classes of types: basic types, ranges and arrays, are all)A72 368 :M-.052(performed in parallel \(hence the ability to implement most of the work using bit-strings\).  Thus, the)A72 380 :M.044 .004(worst case for a )Jf0_12 sf.018(meet)Af3_12 sf.022 .002( or a )Jf0_12 sf.015(join)Af3_12 sf.049 .005( operation is the logical )Jf0_12 sf.019(and)Af3_12 sf.021 .002( or )Jf0_12 sf(or)Sf3_12 sf.05 .005( of several bit strings, along with a)J72 392 :M-.131(number of )Af0_12 sf-.136(range-meet)Af3_12 sf-.099( or )Af0_12 sf-.126(range-join)Af3_12 sf-.119( operations for each of the different numeric range types.)A72 408 :M.473 .047(The code to implement this )Jf8_10 sf.163(subtypep)Af3_12 sf.47 .047( decision procedure, in addition to being fast, is also quite)J72 420 :M.209 .021(small, typically requiring fewer lines of code than the )Jf8_10 sf.07(subtypep)Af3_12 sf.2 .02( that is most likely provided with)J72 432 :M.012 .001(most implementations \(e.g., 3 pages for Kyoto Common Lisp's )Jf8_10 sf(subtypep)Sf3_12 sf.011 .001(, 15 pages for Symbolics)J72 444 :M.081 .008(Common Lisp, 18 pages for Spice Common Lisp's )Jf8_10 sf.025(subtypep)Af3_12 sf.069 .007(\).  Furthermore, it works on even the)J72 456 :M.337 .034(most complicated type specifier expressions, eliminating the need to analyze some very complex)J72 468 :M.199 .02(code \(e.g., )Jf8_10 sf.072(hairy-subtypep)Af3_12 sf.232 .023( and friends\).)J72 484 :M.137 .014(As a side-effect of this effort, one also gets the lattice operations of )Jf8_10 sf.051(meet)Af3_12 sf.06 .006( \(= )Jf8_10 sf.051(and)Af3_12 sf.09 .009(\) and )Jf8_10 sf.051(join)Af3_12 sf.06 .006( \(= )Jf8_10 sf.051(or)Af3_12 sf<29>S72 496 :M.061 .006(for the Common Lisp type system, which can be used for type inference [Baker90].  Additionally,)J72 508 :M.319 .032(one gets a very interesting representation and manipulation package for range arithmetic that can)J72 520 :M.007 .001(handle ranges with holes; e.g., the domain of the reciprocal function 1/x.  Unfortunately, )Jf8_10 sf(meet)Sf3_12 sf( and)S72 532 :Mf8_10 sf-.081(join)Af3_12 sf-.066( produce their answers in a highly stylized canonical form, and converting from this form back)A72 544 :M1.294 .129(into a readable type specifier expression produces very complex and hard-to-understand type)J72 556 :M.41 .041(specifier expressions.  One can attempt to produce more readable expressions, but producing the)J72 568 :M.879 .088(shortest \(or simplest?\) type specifier expression equivalent to a particular canonical form is an)J72 580 :M-.068(NP-complete problem.)A-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 661.24 -.24 .24 215.24 661 .24 72 661 @a72 678 :Mf3_9 sf-.096(17)Af3_12 sf0 3 rm-.105(McAllester's boolean class system [McAllester86] utilizes a similar system to determine whether a)A0 -3 rm72 693 :M-.055(certain class in an intentionally specified class system is allowed to have any members.  His classes)A72 705 :M-.022(are defined by \(essentially\) uninterpreted monadic predicates among which certain subset relations)A72 717 :M-.028(are posited.)Aendp%%Page: 19 19%%BeginPageSetupinitializepage(Henry Baker; page: 19 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(19)S72 91 :Mf4_12 sf1.284(8.\312\312Complexity)A72 107 :Mf3_12 sf.039 .004(The time and space required to execute the decision procedure described above can be determined)J72 119 :M.844 .084(by examining each of the components.  We will measure complexity relative to the size of the)J72 131 :M-.061(arguments to )Af8_10 sf-.072(subtypep)Af3_12 sf-.058(.  The basic operations are as follows:)A72 143 :M.051 .005(\312\245\312splitting the problem into disjoint domains)J72 155 :M.214 .021(\312\245\312solving the problem for each domain)J72 167 :M.531 .053(\312\245\312putting the answers together)J72 183 :M.193 .019(Splitting the problem into disjoint domains requires work linear in the size of the input argument,)J72 195 :M1.03 .103(and putting the results back together is a simple conjunction whose size is proportional to the)J72 207 :M.942 .094(number of kingdoms.  This splitting leaves most of the complexity within the domain specific)J72 219 :M.038(decisions.)A72 235 :M-.036(Discrete types are the built-in elementary types, excluding numeric ranges and arrays.  We show in)A72 247 :M-.053(Appendix II an implementation of a decision procedure for discrete types which utilizes perhaps 30)A72 259 :M-.072(representatives for the built-in Common Lisp discrete types.  Decisions involving )Af8_10 sf-.09(member)Af3_12 sf-.082( can cause)A72 272 :M1.484 .148(the bit vectors to grow, but still in proportion to the )Jf0_12 sf.519(elements)Af3_12 sf2.666 .267( mentioned.)Jf3_9 sf0 -3 rm.445(18)A0 3 rmf3_12 sf1.305 .131(  The actual set)J72 284 :M1.111 .111(operations with the bit-vectors will be of approximately )Jf0_12 sf.292(quadratic)Af3_12 sf1.105 .11( complexity, since both the)J72 296 :M.279 .028(number of operations, as well as their size, will be proportional to the size of the input argument.)J72 308 :M.208 .021(The registering procedure itself can take anywhere from constant time per element registered to a)J72 320 :M-.079(time proportional to the total number of registered elements; this will be implementation dependent.)A72 332 :M-.04(This implementation dependency arises because during the registration of an element, we must call)A72 344 :Mf8_10 sf-.095(typep)Af3_12 sf-.075( for each discrete type known to the system, so that their bit-vectors can be updated.)A72 360 :M-.029(Numeric range decisions generally involve the manipulations of ordered unions of intervals, where)A72 372 :M-.046(the size of the unions is relatively small.  However, one could construct examples where the unions)A72 384 :M.912 .091(attain lengths which are exponential in the size of the input argument.  These cases are highly)J72 396 :M-.022(artificial, however, because they involve continually subdividing intervals into smaller and smaller)A72 408 :M-.082(pieces.  In the typical case, the unions are extremely short\321generally one or two intervals.)A72 424 :M.288 .029(Array type decisions involve the manipulations of relatively short bit-vectors.  However, one can)J72 436 :M.182 .018(construct artificial examples where the lengths of the bit-vectors are exponential in the size of the)J72 448 :M1.296 .13(input argument.  A certain amount of this complexity is forced, since we can ask the sort of)J72 460 :M1.22 .122(database retrieval question posed in section 6 using array types.  However, we consider such)J72 472 :M-.081(examples artificial, since they arise from arrays of high rank and widely varying dimensions.)A72 488 :M3.06 .306(User-defined type decisions \(without )Jf8_10 sf.783(member)Af3_12 sf2.383 .238(\) involve the manipulation of a number of)J72 500 :M-.035(representatives which is proportional to the number of user-defined types.  Note, however, that any)A72 512 :M-.047(work in registering these representatives is not charged to )Af8_10 sf-.06(subtypep)Af3_12 sf-.05(, because these types cannot be)A72 524 :M.479 .048(defined within a call to )Jf8_10 sf.19(subtypep)Af3_12 sf.55 .055(.  While the amount of work involved in registration might be)J72 536 :M-.051(substantial, charging it to the creation of the type rather than to )Af8_10 sf-.069(subtypep)Af3_12 sf-.057( is reasonable.  \(The work)A72 548 :M1.398 .14(of registering representatives is also likely to be completely swamped by the other activities)J72 560 :M1.297 .13(involved in the creation of a type.\)  If there are a large number of built-in types, the normal)J72 572 :M.247 .025(expectation is that once defined, these types remain relatively constant, while )Jf8_10 sf.075(subtypep)Af3_12 sf.197 .02( could be)J72 584 :M.155 .015(called a large number of times.  Thus, the amount of work charged to )Jf8_10 sf.058(subtypep)Af3_12 sf.119 .012( is at most a large)J72 596 :M-.107(constant times the size of the input specifier.)A72 612 :M.732 .073(Including actual objects in a )Jf8_10 sf.254(member)Af3_12 sf.737 .074( construct will cause the registration of those objects to be)J72 624 :M.154 .015(charged to )Jf8_10 sf.054(subtypep)Af3_12 sf.146 .015(, however.  In such cases, a significant amount of work may have to be done)J72 636 :M.935 .094(if there are a large number of user-defined types, as the work to register is proportional to the)J72 648 :M-.033(number of user-defined types.)A-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 683.24 -.24 .24 215.24 683 .24 72 683 @a72 700 :Mf3_9 sf.307(18)Af3_12 sf0 3 rm1.15 .115(The set of representatives need grow only as the )J0 -3 rmf0_12 sf0 3 rm.359(logarithm)A0 -3 rmf3_12 sf0 3 rm.982 .098( of the number of types, since )J0 -3 rmf0_12 sf0 3 rm(n)S0 -3 rm72 717 :Mf3_12 sf-.078(representatives can distinguish 2)Af0_10 sf0 -3 rm-.082(n)A0 3 rmf3_12 sf-.078( different types.)Aendp%%Page: 20 20%%BeginPageSetupinitializepage(Henry Baker; page: 20 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(20)S72 85 :M.136 .014(In summary, the typical user of )Jf8_10 sf.049(subtypep)Af3_12 sf.14 .014( will see its execution taking an amount of time linearly)J72 97 :M-.018(proportional to the size of the input specifiers, while heavy users of )Af8_10 sf-.023(member)Af3_12 sf-.019( and user-defined types)A72 109 :M.568 .057(will experience a more quadratic performance.  Only the most perverse user will experience the)J72 122 :M-.063(exponential worst case behavior of this algorithm.)Af3_9 sf0 -3 rm-.117(19)A0 3 rm72 144 :Mf4_12 sf4.102 .41(9.\312\312Implications for future type systems)J72 160 :Mf3_12 sf-.023(The decision procedure developed for Common Lisp depends critically upon the exact language of)A72 172 :M.305 .03(type specifiers.  Changes in the type system in the direction of more specificity or changes in the)J72 184 :M.755 .075(combining operators allowing more generality would have a profound effect on the ability of a)J72 196 :M.259 .026(mechanical procedure to decide )Jf8_10 sf.071(subtypep)Af3_12 sf.233 .023( questions.  For example, the equivalence of functional)J72 208 :M1.989 .199(types is undecidable, so any change in the direction of Scheme [Rees86] for allowing the)J72 220 :M-.103(comparison of functions will make the problem intractable for Common Lisp.)A72 236 :M-.046(On the other hand, Common Lisp's use of )Af8_10 sf-.055(eql)Af3_12 sf-.042( semantics for the )Af8_10 sf-.055(member)Af3_12 sf-.048( type specifier makes many)A72 248 :M-.088(problems trivially decidable\321for example, those of "equivalent" functions.  Whether )Af8_10 sf-.107(eql)Af3_12 sf-.1( semantics)A72 260 :M-.067(is the most practical semantics within )Af8_10 sf-.085(subtypep)Af3_12 sf-.074( is not known.)A72 276 :M.384 .038(The attempt by CLOS to overload the predicate )Jf8_10 sf.125(subtypep)Af3_12 sf.395 .039( with the meaning "subclassp" is quite)J72 288 :M.496 .05(unfortunate.  Common Lisp already has a precise meaning for )Jf8_10 sf.159(subtypep)Af3_12 sf1.017 .102(\321extensional subset\321)J72 300 :M-.027(while CLOS attempts to convert it into a predicate about intensions.  This CLOS meaning destroys)A72 312 :M-.108(the possibility of building )Af0_12 sf-.118(abstract)Af3_12 sf-.117( data types whose implementation is hidden, because the ability to)A72 324 :M-.061(test for "subclassp" means the ability to determine the superclasses of a class, and hence the slots of)A72 336 :M1.977 .198(the class.  The CLOS meaning thereby confuses membership \("is-a"\) with implementation)J72 348 :M-.063(\("composed-from"\).  For example, one should not be able to deduce that a "set" is a "sequence" just)A72 360 :M.009 .001(because one happens to use a "sequence" to implement a "set".  We suggest that CLOS implement)J72 373 :M.932 .093(instead a predicate )Jf8_12 sf.364(subclassp)Af3_12 sf.984 .098(, and base method selection on this predicate, while allowing)J72 385 :Mf8_10 sf-.119(defclass)Af3_12 sf-.095( to independently specify extensional inclusion of the generated type.)A72 401 :M-.059(We also suggest that Common Lisp provide an "uninstantiable" specification for user-defined types)A72 413 :M-.062(which specifies when a new type is not allowed to have any direct instances, so that the intention of)A72 425 :M-.065(user-defined types which are partitioned into subtypes which have direct instances can be specified.)A72 437 :M.257 .026(This terminology is introduced by McAllester in his very interesting paper [McAllester86] which)J72 449 :M-.045(provides a consistent interpretation for inheritance in a class system which has been completed into)A72 461 :M-.095(a Boolean algebra.)A72 477 :M.685 .068(The current Common Lisp type specifier system does not provide the best possible information)J72 489 :M.404 .04(regarding types in declarations for use in highly optimizing compilers.  For example, one cannot)J72 501 :M-.013(specify ranges which are bounded by a run-time variable in Common Lisp.  Such type information)A72 513 :M1.069 .107(is highly useful in Ada, for example, for removing redundant run-time range checks [Ada83].)J72 525 :M-.05(Common Lisp curiously does not provide descriptive information about the types of items in its list)A72 537 :M-.117(structures, yet this information can be invaluable in producing highly efficient code for manipulating)A72 549 :M1.458 .146(lists [Milner78].  Unfortunately, neither of these capabilities can be handled by the decision)J72 561 :M-.066(procedure described here.)A72 577 :M-.063(However, there are a few type specifier changes which )Af0_12 sf-.068(could)Af3_12 sf-.064( be handled by our techniques.  One of)A72 589 :M-.003(these is the ability to describe the "alignment" of an integer as being divisible by 2, 4, 8, etc.  Such)A72 601 :M2.458 .246(information would be extremely valuable in compiling the most efficient code for RISC)J72 613 :M-.103(architectures which can access objects only on certain address alignments.)A72 629 :M.674 .067(The current Common Lisp type system does not provide for any kind of )Jf0_12 sf.191(context)Af3_12 sf.627 .063( marker for the)J72 641 :M.188 .019(interpretation of )Jf8_10 sf.053(typep)Af3_12 sf.083 .008( and )Jf8_10 sf.053(subtypep)Af3_12 sf.151 .015( questions.  Such a context marker would be very helpful in)J-4096 -4095 -1 1 -4094 -4095 1 -4096 -4096 @a72 661.24 -.24 .24 215.24 661 .24 72 661 @a72 678 :Mf3_9 sf.044(19)Af3_12 sf0 3 rm.19 .019(This exponential behavior is caused only by the perverse use of arrays.  Unlike [McAllester86],)J0 -3 rm72 693 :M-.07(in which certain questions are co-NP complete because questions are asked about )Af0_12 sf-.06(all)Af3_12 sf-.068( interpretations)A72 705 :M.952 .095(of a system of subsets, our procedure is fast because it is asking about a )Jf0_12 sf.301(particular)Af3_12 sf1.051 .105( system of)J72 717 :M.191(subsets.)Aendp%%Page: 21 21%%BeginPageSetupinitializepage(Henry Baker; page: 21 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(21)S72 81 :M1.35 .135(distinguishing between compile-time and run-time type environments, especially where user-)J72 93 :M.414 .041(defined types are involved.  The lack of such a context marker makes the algorithm for deciding)J72 105 :Mf8_10 sf-.061(subtypep)Af3_12 sf-.046( a lot easier, but a lot less useful.  This is because the important issue within a compiler is)A72 117 :M-.089(what values a object could take on in the environment of the run-time system, not what values it can)A72 129 :M.459 .046(take on in the compile-time environment.  As a result of this omission, Common Lisp compilers)J72 141 :M1.165 .117(will almost certainly utilize a different )Jf8_10 sf.381(subtypep)Af3_12 sf1.172 .117( than the standard run-time version, and the)J72 153 :M.138 .014(compile-time version will have to be less precise in order to allow for the differences between the)J72 165 :M-.133(compile-time and the run-time environments.)A72 187 :Mf4_12 sf1.333(10.\312\312Conclusions)A72 203 :Mf3_12 sf.212 .021(Logicians have long known that two logical systems related to the Common Lisp type system are)J72 215 :M-.045(known to be decidable: the first-order theory of uninterpreted sets [Church56] [Rackoff75], and the)A72 227 :M.838 .084(first-order theory of rational order [Ferrante77] [Ferrante75] \(a much easier version of Tarski's)J72 239 :M1.124 .112(theory of )Jf0_12 sf1.559 .156(real closed fields)Jf3_12 sf1.21 .121( [Tarski51]\).  It is almost obvious that these two results make the)J72 251 :M1.206 .121(Common Lisp type system \(without )Jf8_10 sf.342(satisfies)Af3_12 sf1.085 .108(\) decidable.  However, both of these decision)J72 263 :M-.107(procedures have multiply-exponential time bounds, and are of theoretical interest only.)A72 279 :M.261 .026(The decision procedure described here is similar to that for the first-order theory of uninterpreted)J72 291 :M.509 .051(sets in that it builds a constructive )Jf0_12 sf.194(model)Af3_12 sf.605 .06( using objects gleaned from the input arguments.  This)J72 303 :M-.09(procedure is very much cleaned up, however,  for efficient implementation.  Our decision procedure)A72 315 :M-.063(for intervals is new, although it is a reasonably obvious extension of standard interval arithmetic.  It)A72 327 :M1.012 .101(has not been described before most likely because programming it in Fortran is too painful to)J72 339 :M-.149(contemplate.)A72 361 :Mf4_12 sf.645(Acknowledgments)A72 377 :Mf3_12 sf-.015(Jeff Hirsch provided invaluable help in editing earlier versions of this paper.  We are also indebted)A72 389 :M-.116(to Carolyn Talcott and Richard Gabriel who refereed this paper and gave many valuable criticisms.)A72 411 :Mf4_12 sf.672(References)A72 434 :Mf3_10 sf.409 .041(Ada83.  )Jf0_10 sf.701 .07(Reference Manual for the Ada\250 Programming Language)Jf3_10 sf.74 .074(.  ANSI/MIL-STD-1815A-1983, US GPO, Wash,)J89 445 :M.895 .089(DC, 1983.)J72 456 :M.065 .007(Aho86.  Aho, Alfred V.; Sethi, Ravi; and Ullman, Jeffrey D.  )Jf0_10 sf.105 .01(Compilers: Principles, Techniques, and Tools)Jf3_10 sf.071 .007(.  Addison-)J89 467 :M.235 .024(Wesley, 1986.)J72 478 :M.226 .023(Baker90.  Baker, Henry G.  "The Nimble Type Inferencer for Common Lisp-84".  Submitted to )Jf0_10 sf.266 .027(ACM Trans. on Prog.)J89 489 :M.499 .05(Langs. and Systems.)J72 500 :Mf3_10 sf.681 .068(Bauer74.  Bauer, Alan M., and Saal, Harry J.  "Does APL really need run-time checking?"  )Jf0_10 sf1.076 .108(Software Practice and)J89 511 :M.055(Experience)Af3_10 sf.274 .027(, v.4, 1974,pp.129-138.)J72 522 :M-.001(Beer88.  Beer, Randall D.  "The compile-time type inference and type checking of Common Lisp programs: a technical)A89 533 :M.85 .085(summary".  TR 88-116, Ctr. for Automation and Intelligent Sys. Research, Case Western Reserve Univ., May)J89 544 :M.125(1988.)A72 555 :M1.114 .111(Bobrow88.  Bobrow, et al.  "Common Lisp Object System Specification X3J13", )Jf0_10 sf1.645 .165(ACM SIGPLAN Notices)Jf3_10 sf1.043 .104(, v.23,)J89 566 :M.335 .033(Sept. 1988; also )Jf0_10 sf.452 .045(Lisp and Symbolic Computation 1)Jf3_10 sf.428 .043(, 3-4, pp245-394; also X3J13 Document 88-002R, June 1988.)J72 577 :M.651 .065(Borning82.  Borning, Alan H. and Ingalls, Daniel H. H.  "A Type Declaration and Inference System for Smalltalk")J89 588 :Mf0_10 sf.775 .077(ACM POPL 9)Jf3_10 sf.854 .085(, 1982, pp.133-141.)J72 599 :M.2 .02(Budd88.  Budd, Timothy.  )Jf0_10 sf.285 .028(An APL Compiler)Jf3_10 sf.244 .024(.  Springer-Verlag, NY, 1988.)J72 610 :M.241 .024(Church56.  Church, A.  )Jf0_10 sf.341 .034(Introduction to Mathematical Logic, Vol. I.)Jf3_10 sf.303 .03(  Princeton University Press, 1956.)J72 621 :M.376 .038(CL84.  Steele, Guy L., Jr.  )Jf0_10 sf.741 .074(Common Lisp: The Language)Jf3_10 sf.476 .048(.  Digital Press, 1984.)J72 632 :M.259 .026(CL90.  Steele, Guy L., Jr.  Common Lisp: The Language, Second Edition.  Digital Press, Bedford, MA, 1990.)J72 643 :M.599 .06(Ferrante, J., and Rackoff, C.  "A decision procedure for the first order theory of real addition with order".  )Jf0_10 sf.881 .088(SIAM J.)J89 654 :M.773 .077(Comput. 4)Jf3_10 sf.661 .066(, 1 \(1975\),69-76.)J72 665 :M.042 .004(Ferrante, J. and Geiser, J.  "An efficient decision procedure for the theory of rational order".  )Jf0_10 sf.054 .005(Theor. Computer Sci. 4)Jf3_10 sf(, 2)S89 676 :M(\(1977\),227-234.)S72 687 :M.287 .029(Hughes68.  Hughes, G.E., and Cresswell, M.J.  )Jf0_10 sf.346 .035(An Introduction to Modal Logic)Jf3_10 sf.267 .027(.  Methuen and Co., 1968.)J72 698 :M.666 .067(IEEE82.  Floating-Point Working Group 754 of the Microprocessor Standards Committee.  "A Standard for Binary)J89 709 :M.471 .047(Floating-Point Arithmetic".  IEEE, 345 E. 47'th St., New York, NY 10017, 1982.)Jendp%%Page: 22 22%%BeginPageSetupinitializepage(Henry Baker; page: 22 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(22)S72 81 :Mf3_10 sf.739 .074(Loos83.  Loos, R.  "Computing in Algebraic Extensions".  In Buchberger, et al. )Jf0_10 sf1.154 .115(Computer Algebra: Symbolic and)J89 92 :M.154 .015(Algebraic Computation, Second Edition)Jf3_10 sf.121 .012(.  Springer-Verlag, New York, 1983, pp.173-187.)J72 103 :M.764 .076(Kaplan80.  Kaplan, Marc A., and Ullman, Jeffrey D.  "A Scheme for the Automatic Inference of Variable Types".)J89 114 :M.65 .065(JACM 27,1, Jan. 1980, pp.128-145.)J72 125 :M.526 .053(Ma, Kwan-Liu, and Kessler, Robert R.  "TICL\321A Type Inference System for Common Lisp".  )Jf0_10 sf.181(SW\321Prac.&Exper.)A89 136 :M.151(20)Af3_10 sf.902 .09(,6 \(June\3121990\),593-623.)J72 147 :M.099 .01(MacLane67.  MacLane, Saunders and Birkhoff, Garrett.  )Jf0_10 sf.036(ALGEBRA)Af3_10 sf.094 .009(.  Macmillan, 1967.)J72 158 :M1.597 .16(McAllester, David, and Zabih, Ramin.  "Boolean Classes".  )Jf0_10 sf1.793 .179(Proc. '86 OOPSLA, Sigplan Notices 21)Jf3_10 sf2.079 .208(,11 \(Nov.)J89 169 :M.026(1986\),417-423.)A72 180 :M.434 .043(Milner78.  Milner, Robin.  "A Theory of Type Polymorphism in Programming"  )Jf0_10 sf.145(JCSS)Af3_10 sf.607 .061( 17, 1978,pp.348-375.)J72 191 :M.428 .043(Morris73.  Morris, J.H.  "Types are Not Sets".  )Jf0_10 sf.903 .09(ACM POPL)Jf3_10 sf.689 .069(, 1973, pp.120-124.)J72 202 :M1.556 .156(Rackoff75.  Rackoff, C.W.  "The complexity of theories of the monadic predicate calculus".  IRIA Rep. 136,)J89 213 :M-.014(Roquencourt, France, 1975.)A72 224 :M.296 .03(Rees86.  Rees, J. and Clinger, W., et al.  "Revised Report on the Algorithmic Language Scheme".  )Jf0_10 sf.625 .062(SIGPLAN Notices)J89 235 :M.091(21)Af3_10 sf.276 .028(, 12 \(Dec. 1986\), 37-79.)J72 246 :M.474 .047(Scott76.  Scott, D.  "Data types as lattices".  )Jf0_10 sf.843 .084(SIAM J. Computing)Jf3_10 sf.648 .065(, 5,3 \(Sept. 1976\), 522-587.)J72 257 :M.602 .06(Steele78.  Steele, Guy L., Jr.  )Jf0_10 sf.936 .094(Rabbit: A Compiler for SCHEME \(A Study in Compiler Optimization\))Jf3_10 sf.884 .088(.  AI-TR-474,)J89 268 :M.009 .001(Artificial Intelligence Laboratory, MIT, May 1978.)J72 279 :M.435 .044(Suzuki81.  Suzuki, Norihisa.  "Inferring Types in Smalltalk".  )Jf0_10 sf.414 .041(ACM POPL 8, )Jf3_10 sf.135(1981,pp.187-199.)A72 290 :M1.04 .104(Tarski51.  Tarski, A.  )Jf0_10 sf1.637 .164(A Decision Method for Elementary Algebra and Geometry)Jf3_10 sf1.125 .113(, 2nd ed., Univ. of Cal. Press,)J89 301 :M-.042(Berkeley, 1951.)A72 322 :Mf4_12 sf4.032 .403(Appendix\312I.\312\312Axioms for Lattices and Boolean Algebras [MacLane67].)J72 338 :Mf3_12 sf-.143(A )Af0_12 sf-.105(lattice)Af3_12 sf-.117( is a set U together with a predicate )AcFf1_12 sf-.117<A3>Asf-.117( on U.)A72 354 :M.266 .027(For all x, x )JcFf1_12 sf.027<A3>Asf.266 .027( x.)J344 354 :M-.164(\(Reflexivity\))A72 370 :M.149 .015(If x )JcFf1_12 sf.015<A3>Asf.149 .015( y and y )JcFf1_12 sf.015<A3>Asf.149 .015( x, then x = y.)J344 370 :M-.177(\(Antisymmetry\))A72 386 :M.115 .012(If x )JcFf1_12 sf.012<A3>Asf.115 .012( y and y )JcFf1_12 sf.012<A3>Asf.115 .012( z, then x )JcFf1_12 sf.012<A3>Asf.115 .012( z.)J344 386 :M-.152(\(Transitivity\))A72 402 :M-.064(Define x )Af1_10 sf-.078<D9>Af3_12 sf-.056( y to be )Af0_12 sf-.066(greatest lower bound)Af3_12 sf-.06( of x,y under )AcFf1_12 sf-.06<A3>Asf-.06(.  Define x )Af1_10 sf-.078<DA>Af3_12 sf-.056( y to be )Af0_12 sf-.066(least upper bound)Af3_12 sf-.067( of x,y)A72 414 :M.644 .064(under )JcFf1_12 sf.064<A3>Asf.644 .064(.)J72 430 :M.115 .012(x )Jf1_10 sf.093<D9>Af3_12 sf.11 .011( x = x, x )Jf1_10 sf.093<DA>Af3_12 sf.122 .012( x = x)J344 430 :M-.136(\(Idempotency\))A72 446 :M.079 .008(x )Jf1_10 sf.064<D9>Af3_12 sf.069 .007( y = y )Jf1_10 sf.064<D9>Af3_12 sf.071 .007( x, x )Jf1_10 sf.064<DA>Af3_12 sf.069 .007( y = y )Jf1_10 sf.064<DA>Af3_12 sf.087 .009( x)J344 446 :M-.19(\(Commutativity\))A72 462 :M(x )Sf1_10 sf<D9>Sf3_12 sf( \(y )Sf1_10 sf<D9>Sf3_12 sf( z\) = \(x )Sf1_10 sf<D9>Sf3_12 sf( y\) )Sf1_10 sf<D9>Sf3_12 sf( z, x )Sf1_10 sf<DA>Sf3_12 sf( \(y )Sf1_10 sf<DA>Sf3_12 sf( z\) = \(x )Sf1_10 sf<DA>Sf3_12 sf( y\) )Sf1_10 sf<DA>Sf3_12 sf( z)S344 462 :M-.165(\(Associativity\))A72 478 :M(x )Sf1_10 sf<D9>Sf3_12 sf( \(x )Sf1_10 sf<DA>Sf3_12 sf.021 .002( y\) = x )Jf1_10 sf<DA>Sf3_12 sf( \(x )Sf1_10 sf<D9>Sf3_12 sf.025 .003( y\) = x)J344 478 :M-.089(\(Absorption\))A72 494 :M-.033(x )Af1_10 sf<D9>Sf3_12 sf-.032( y = x if and only if x )Af1_10 sf<DA>Sf3_12 sf-.034( y = y if and only if x )AcFf1_12 sf-.034<A3>Asf-.034( y)A344 494 :M-.054(\(Consistency\))A72 510 :M.008 .001(If y )JcFf1_12 sf.001<A3>Asf.008 .001( z, then x )Jf1_10 sf<D9>Sf3_12 sf( y )ScFf1_12 sf<A3>Ssf( x )Sf1_10 sf<D9>Sf3_12 sf( z and x )Sf1_10 sf<DA>Sf3_12 sf( y )ScFf1_12 sf<A3>Ssf( x )Sf1_10 sf<DA>Sf3_12 sf( z)S344 510 :M-.178(\(Monotonicity\))A72 526 :M(x )Sf1_10 sf<D9>Sf3_12 sf.031 .003( \(y )Jf1_10 sf<DA>Sf3_12 sf.036 .004( z\) )JcFf1_12 sf.004<B3>Asf.036 .004( \(x )Jf1_10 sf<D9>Sf3_12 sf.031 .003( y\) )Jf1_10 sf<DA>Sf3_12 sf.031 .003( \(x )Jf1_10 sf<D9>Sf3_12 sf.056 .006( z\),)J344 526 :M-.172(\(Distributive )Af0_12 sf-.174(in)Af3_12 sf-.187(equalities\))A72 542 :M(x )Sf1_10 sf<DA>Sf3_12 sf( \(y )Sf1_10 sf<D9>Sf3_12 sf-.01( z\) )AcFf1_12 sf-.01<A3>Asf-.01( \(x )Af1_10 sf<DA>Sf3_12 sf( y\) )Sf1_10 sf<D9>Sf3_12 sf( \(x )Sf1_10 sf<DA>Sf3_12 sf( z\))S72 558 :M.06 .006(If x )JcFf1_12 sf.006<A3>Asf.06 .006( z, then x )Jf1_10 sf<DA>Sf3_12 sf.042 .004( \(y )Jf1_10 sf<D9>Sf3_12 sf.048 .005( z\) )JcFf1_12 sf.005<A3>Asf.048 .005( \(x )Jf1_10 sf<DA>Sf3_12 sf.042 .004( y\) )Jf1_10 sf<D9>Sf3_12 sf.059 .006( z.)J344 558 :M-.176(\(Modular )Af0_12 sf-.153(in)Af3_12 sf-.175(equality\))A72 590 :M-.156(A )Af0_12 sf-.144(Boolean algebra)Af3_12 sf-.111( is a lattice with )Af1_10 sf-.176(^)Af3_12 sf-.136( and T which is modular, distributive and complemented.)A72 606 :M(If x )ScFf1_12 sf<A3>Ssf( z, then x )Sf1_10 sf<DA>Sf3_12 sf( \(y )Sf1_10 sf<D9>Sf3_12 sf( z\) = \(x )Sf1_10 sf<DA>Sf3_12 sf( y\) )Sf1_10 sf<D9>Sf3_12 sf( z)S344 606 :M-.179(\(Modularity\))A72 622 :M(x )Sf1_10 sf<D9>Sf3_12 sf.023 .002( \(y )Jf1_10 sf<DA>Sf3_12 sf.027 .003( z\) = \(x )Jf1_10 sf<D9>Sf3_12 sf.023 .002( y\) )Jf1_10 sf<DA>Sf3_12 sf.023 .002( \(x )Jf1_10 sf<D9>Sf3_12 sf.04 .004( z\),)J344 622 :M-.176(\(Distributivity\))A72 638 :M(x )Sf1_10 sf<DA>Sf3_12 sf-.015( \(y )Af1_10 sf<D9>Sf3_12 sf-.016( z\) = \(x )Af1_10 sf<DA>Sf3_12 sf-.015( y\) )Af1_10 sf<D9>Sf3_12 sf-.015( \(x )Af1_10 sf<DA>Sf3_12 sf( z\))S72 654 :M-.021(Let x' denote the )Af0_12 sf-.027(complement)Af3_12 sf-.023( of x.)A344 654 :M-.177(\(Complemented\))A72 670 :M.57 .057(x )Jf1_10 sf.458<D9>Af3_12 sf.505 .05( x' = )Jf1_10 sf.5(^)Af3_12 sf.475 .047(, x )Jf1_10 sf.458<DA>Af3_12 sf.672 .067( x' = T, x'' = x)J72 686 :M.793 .079(\(x )Jf1_10 sf.478<D9>Af3_12 sf.62 .062( y\)' = x' )Jf1_10 sf.478<DA>Af3_12 sf.63 .063( y', \(x )Jf1_10 sf.478<DA>Af3_12 sf.62 .062( y\)' = x' )Jf1_10 sf.478<D9>Af3_12 sf.738 .074( y')J344 686 :M-.218(\(DeMorgan\))Aendp%%Page: 23 23%%BeginPageSetupinitializepage(Henry Baker; page: 23 of 23)setjob%%EndPageSetup-31 -31 :TgS 31 31 552 730 rC72 49 :Mf0_12 sf.587 .059(Lisp and Symbolic Computation)Jf3_12 sf.061 .006( )Jf4_12 sf.135(5)Af3_12 sf.614 .061(,3 \(Sept.\3121992\), 157-190.)J72 753 :M-.093(\251 1989 Nimble Computer Corporation)A432 753 :M(23)S72 91 :Mf4_12 sf4.457 .446(Appendix\312II.\312\312Simple implementation of )Jf7_10 sf.894(subtypep)Af4_12 sf2.47 .247( for a trivial type system)J72 107 :Mf3_12 sf1.155 .115(The following code is purely pedagogical; no production system would implement )Jf8_10 sf.374(subtypep)A72 119 :Mf3_12 sf2.46 .246(exactly this way.  In particular, we apologize for the use of side-effects.  However, for)J72 131 :M1.822 .182("anonymous" types created by )Jf8_10 sf.506(member)Af3_12 sf1.37 .137(, one must either register them for the current call to)J72 143 :Mf8_10 sf-.027(subtypep)Af3_12 sf-.022(, or register them once and for all.  Depending upon the situation, either version could be)A72 155 :M-.074(more efficient: the temporary registration policy would be better if the type is only used once, while)A72 167 :M-.045(the permanent registration policy would be better if the type is used many times\321e.g., if )Af8_10 sf-.065(subtypep)A72 179 :Mf3_12 sf-.087(were called with the anonymous type within a loop.)A72 195 :Mf8_10 sf.012 .001(\(defconstant *standard-type-specifiers*)J72 206 :M.006 .001(  '\(FIXNUM BIGNUM FLOAT RATIO COMPLEX INTEGER RATIONAL CHARACTER)J72 217 :M(    NULL SYMBOL KEYWORD LIST etc.\))S72 228 :M.005 0(  "List of all built-in type names"\))J72 250 :M(\(defconstant *representatives*)S72 261 :M.005 0(  '\(0 43574358734543 1.0 3/4 #C\(1 1\) #\\S nil t :foo)J72 272 :M.005 0(    #\(1 2\) "Foo" #*10110 #2A\(\(1 2\) \(3 4\)\) #.*standard-input*\))J72 283 :M.006 .001(  "List of representatives for all equivalence classes"\))J72 305 :M(\(defun rep-bit \(elt\))S72 316 :M.005 .001(  "Return a bit-vector with bit set for this element")J72 327 :M.006 .001(  \(let \(\(pos \(position elt *representatives*\)\)\))J72 338 :M(    \(if pos \(ash 1 pos\))S72 349 :M.005 0(        \(progn \(nconc *representatives* `\(,elt\)\) \(rep-bit elt\)\)\)\)\))J72 371 :M(\(defun register \(elt\))S72 382 :M.005 .001(  "Register this element with all known types; return rep-bit")J72 393 :M.007 .001(  \(dolist \(typ *standard-type-specifiers*\))J72 404 :M(    \(if \(and \(typep elt typ\))S72 415 :M.003 0(             \(zerop \(logand \(rep-bit elt\) \(eval typ\)\)\)\))J72 426 :M.004 0(        \(incf \(symbol-value typ\) \(rep-bit elt\)\)\)\))J72 437 :M(  \(rep-bit elt\)\))S72 459 :M(\(defun elements \(&rest elts\))S72 470 :M.005 .001(  "Register elements and return OR of element bits")J72 481 :M.006 .001(  \(reduce #'logior \(mapcar #'register elts\)\)\))J72 503 :M.007 .001(\(dolist \(typ *standard-type-specifiers*\) \(set typ 0\)\))J72 525 :M.008 .001(\(apply #'elements *representatives*\) ; Register all representatives)J72 547 :M(\(defun subtypep \(x y\))S72 558 :M.006 .001(  "Predicate for subtype testing; map into bit-vector algebra")J72 569 :M.005 0(  \(let \(\(exp \(sublis '\(\(and . logand\) \(or . logior\))J72 580 :M.002 0(                       \(not . lognot\) \(member . elements\)\))J72 591 :M.002 0(                     `\(and ,x \(not ,y\)\)\)\)\))J72 602 :M.005 .001(  \(eval exp\) ; Dress rehersal to make sure elements are registered.)J72 613 :M(  \(values \(zerop \(eval exp\)\) t\)\))Sendp%%Trailerend%%EOF