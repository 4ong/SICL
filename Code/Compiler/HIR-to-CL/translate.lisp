(cl:in-package #:sicl-hir-to-cl)

(defgeneric translate (client instruction context))

(defmethod translate (client (instruction cleavir-ir:assignment-instruction) context)
  (let* ((input (first (cleavir-ir:inputs instruction)))
         (output (first (cleavir-ir:outputs instruction)))
         (successor (first (cleavir-ir:successors instruction))))
    `((setq ,(cleavir-ir:name output)
            ,(if (typep input 'cleavir-ir:constant-input)
                 `',(cleavir-ir:value input)
                 (cleavir-ir:name input)))
      ,@(translate client successor context))))

(defmethod translate (client (instruction cleavir-ir:funcall-instruction) context)
  (let ((inputs (cleavir-ir:inputs instruction))
        (successor (first (cleavir-ir:successors instruction))))
     `((setq ,(values-location context)
             (multiple-value-list
              (funcall ,@(mapcar #'cleavir-ir:name inputs))))
       ,@(translate client successor context))))

(defmethod translate (client (instruction cleavir-ir:return-instruction) context)
  `((return-from ,(block-name context)
      (apply #'values ,(values-location context)))))

(defmethod translate (client (instruction cleavir-ir:nop-instruction) context)
  (let ((successor (first (cleavir-ir:successors instruction))))
    (translate client successor context)))

(defmethod translate (client (instruction cleavir-ir:eq-instruction) context)
  (destructuring-bind (input1 input2)
      (cleavir-ir:inputs instruction)
    (destructuring-bind (successor1 successor2)
        (cleavir-ir:successors instruction)
      (let ((else (gensym))
            (out (gensym)))
        `((when (eq ,input1 ,input2)
            (go ,else))
          ,@(translate client successor1 context)
          (go ,out)
          ,else
          ,@(translate client successor2 context)
          ,out)))))

(defmethod translate (client (instruction cleavir-ir:consp-instruction) context)
  (let ((input (first (cleavir-ir:inputs instruction))))
    (destructuring-bind (successor1 successor2)
        (cleavir-ir:successors instruction)
      (let ((else (gensym))
            (out (gensym)))
        `((when (consp ,input)
            (go ,else))
          ,@(translate client successor1 context)
          (go ,out)
          ,else
          ,@(translate client successor2 context)
          ,out)))))

(defmethod translate (client (instruction cleavir-ir:fixnump-instruction) context)
  (let ((input (first (cleavir-ir:inputs instruction))))
    (destructuring-bind (successor1 successor2)
        (cleavir-ir:successors instruction)
      (let ((else (gensym))
            (out (gensym)))
        `((when (typep ,input 'fixnum)
            (go ,else))
          ,@(translate client successor1 context)
          (go ,out)
          ,else
          ,@(translate client successor2 context)
          ,out)))))

(defmethod translate (client (instruction cleavir-ir:characterp-instruction) context)
  (let ((input (first (cleavir-ir:inputs instruction))))
    (destructuring-bind (successor1 successor2)
        (cleavir-ir:successors instruction)
      (let ((else (gensym))
            (out (gensym)))
        `((when (characterp ,input)
            (go ,else))
          ,@(translate client successor1 context)
          (go ,out)
          ,else
          ,@(translate client successor2 context)
          ,out)))))

(defmethod translate :around (client instruction context)
  (let ((visited (visited context))
        (tag (gethash instruction (tags context))))
    (if (gethash instruction visited)
        `((go ,tag))
        (progn (setf (gethash instruction visited) t)
               (cons tag (call-next-method))))))
