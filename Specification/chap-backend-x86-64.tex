\chapter{x86-64}
\label{chapter-backend-x86-64}

\section{Register usage}

The standard calling conventions defined by the vendors, and used by
languages such as \clanguage{} use the registers as follows:

\begin{tabular}{|l|l|l|}
\hline
Name & Used for & Saved by\\
\hline
\hline
RAX & First return value & Caller\\
RBX & Optional base pointer & Callee\\
RCX & Fourth argument & Caller \\
RDX & Third argument, second return value & Caller\\
RSP & Stack pointer &\\
RBP & Frame pointer & Callee\\
RSI & Second argument & Caller\\
RDI & First argument & Caller\\
R8 & Fifth argument & Caller\\
R9 & Sixth argument & Caller\\
R10 & Temporary, static chain pointer & Caller\\
R11 & Temporary & Caller\\
R12 & Temporary & Callee\\
R13 & Temporary & Callee\\
R14 & Temporary & Callee\\
R15 & Temporary & Callee\\
\hline
\end{tabular}

We mostly respect this standard, and define the register allocation as
follows:

\begin{tabular}{|l|l|l|}
\hline
Name & Used for & Saved by\\
\hline
\hline
RAX & First return value & Caller\\
RBX & Dynamic environment & Callee\\
RCX & Fourth argument, third return value & Caller \\
RDX & Third argument, second return value & Caller\\
RSP & Stack pointer &\\
RBP & Frame pointer & Caller\\
RSI & Second argument, fourth return value & Caller\\
RDI & First argument, value count & Caller\\
R8  & Fifth argument & Caller\\
R9  &  Argument count, return value pointer& Caller\\
R10 & Static env. argument & Caller\\
R11 & Scratch & Caller\\
R12 & Register variable & Callee\\
R13 & Register variable & Callee\\
R14 & Register variable & Callee\\
R15 & Register variable & Callee\\
\hline
\end{tabular}

\section{Representation of function objects}

\begin{itemize}
\item A static environment.
\item The entry point of the function as a raw machine address.  Since
  entry points are word aligned, this value looks like a fixnum.
\end{itemize}

\section{Calling conventions}

\refFig{fig-x86-64-stack-frame} shows the layout of a stack frame.

\begin{figure}
\begin{center}
\inputfig{fig-x86-64-stack-frame.pdf_t}
\end{center}
\caption{\label{fig-x86-64-stack-frame}
Stack frame for the x86-64 backend.}
\end{figure}

Normal call to external function, passing at most $5$ arguments:

\begin{enumerate}
\item Compute the callee function object and the arguments into
  temporary locations.
\item Store the arguments in RDI, RSI, RDX, RCX, and R8.
\item Store the argument count in R9 as a fixnum.
\item Load the static environment of the callee from the callee
  function object into R10.
\item Push the value of RBP on the stack.
\item Copy the value of RSP into RBP, establishing the
  (empty) stack frame for the callee.
\item Load the entry point address of the callee from the callee
  function object into an available scratch register, typically RAX.
\item Use the CALL instruction with that register as an argument,
  pushing the return address on the stack and transferring control to
  the callee.
\end{enumerate}

Normal call to external function, passing at more than $5$ arguments:

\begin{enumerate}
\item Compute the callee function object and the arguments into
  temporary locations.
\item Subtract $8(N - 3)$ from RSP, where $N$ is the number of
  arguments to pass, thus leaving room in the callee stack frame for
  the $N - 5$ arguments, the return address, and the caller RBP.
\item Store the first $5$ arguments in RDI, RSI, RDX, RCX, and R8.
\item Store the remaining arguments in [RSP$ + 0$], [RSP$ + 8$],
  $\ldots$, [RSP$ + 8(N - 6)$] in that order, so that the sixth
  argument is on top of the stack.
\item Store the argument count in R9 as a fixnum.
\item Load the static environment of the callee from the callee
  function object into R10.
\item Store the value of RBP into [RSP + 8(N - 4)]
\item Copy the value of RSP$ + 8(N - 4)$ into RBP, establishing the
  stack frame for the callee.  The instruction LEA can be used for
  this purpose.
\item Load the entry point address of the callee from the callee
  function object into an available scratch register, typically RAX.
\item Use the CALL instruction with that register as an argument,
  pushing the return address on the stack and transferring control to
  the callee.
\end{enumerate}

By using a \texttt{CALL}/\texttt{RET} pair instead of (say) the caller
storing the return address in its final place using some other method,
we make sure that the predictor for the return address of the
processor makes the right guess about the eventual address to be
used.

\refFig{fig-x86-64-stack-frame-at-entry} shows the layout of the stack
upon entry to a function when more than $5$ arguments are passed.
Notice that the return address is not in its final place, and the
final place for the return address is marked ``unused'' in
\refFig{fig-x86-64-stack-frame-at-entry}.

\begin{figure}
\begin{center}
\inputfig{fig-x86-64-stack-frame-at-entry.pdf_t}
\end{center}
\caption{\label{fig-x86-64-stack-frame-at-entry}
Stack frame at entry with more than 5 arguments.}
\end{figure}

Tail call to external function, passing at most $5$ arguments:

\begin{enumerate}
\item Compute the callee function object and the arguments into
  temporary locations.
\item Store the arguments in RDI, RSI, RDX, RCX, and R8.
\item Store the argument count in R9 as a fixnum.
\item Load the static environment of the callee from the callee
  function object into R10.
\item Copy the value of RBP$ - 8$ to RSP, establishing the stack frame
  for the callee, containing only the return address.  The LEA
  instruction can be used for this purpose.
\item Load the entry point address of the callee from the callee
  function object into an available scratch register, typically RAX.
\item Use the JMP instruction with that register as an argument,
  transferring control to the callee.
\end{enumerate}

Tail call to external function, passing at more than $5$ arguments:%
\fixme{Determine the protocol.}

For \emph{internal calls} there is greater freedom, because the caller
and the callee were compiled simultaneously.  In particular, the
caller might copy some arbitrary \emph{prefix} of the code of the
callee in order to optimize it in the context of the caller.  This
prefix contains argument count checking and type checking of
arguments.  The address to use for the call is computed statically as
an offset from the current program counter, so that a CALL instruction
with a fixed relative address can be used.  Furthermore, the caller
might be able to avoid loading the static environment if it is known
that the callee uses the same static environment as the caller.

Upon function entry after an ordinary call, when more than $5$
arguments are passed, the callee must pop the return address off the
top of the stack and store it in its final location.  This can be done
with a single POP instruction, using [RBP$ - 8$] as the destination.
When fewer than $5$ arguments are passed, the return address is
already in the right place.

Return from callee to caller with no values:

\begin{enumerate}
\item Store NIL in RAX.
\item Store $0$ in RDI, represented as a fixnum.
\item Store the value of RBP$ - 8$ in RSP so that the stack frame
  contains only the return address.  To accomplish this effect, the
  callee can use the LEA instruction.
\item Return to the caller by executing the RET instruction.
\end{enumerate}

Return from callee to caller with a $1 - 4$ values:

\begin{enumerate}
\item Store the values to return in RAX, RDX, RCX, RSI.
\item Store the number of values in RDI, represented as a fixnum.
\item Store the value of RBP$ - 8$ in RSP so that the stack frame
  contains only the return address.  To accomplish this effect, the
  callee can use the LEA instruction.
\item Return to the caller by executing the RET instruction.
\end{enumerate}

Return from callee to caller with more than $4$ values:

\begin{enumerate}
\item Store the first $4$ values to return in RAX, RDX, RCX, RSI.
\item Access the \emph{thread} object in the dynamic environment in
  order to obtain an address to be used for the remaining return
  values and put that address in R8.
\item Store the number of values in RDI, represented as a fixnum.
\item Store the value of RBP$ - 8$ in RSP so that the stack frame
  contains only the return address.  To accomplish this effect, the
  callee can use the LEA instruction.
\item Return to the caller by executing the RET instruction.
\end{enumerate}

\section{Use of the dynamic environment}

The dynamic environment is a simply linked sequence of entries
allocated in the stack rather than on the heap.  The following entry
types exist:

\begin{itemize}
  \item An entry representing the binding of a special variable.  This
    entry contains two fields; the symbol to be bound and the value.

  \item An entry representing a \texttt{catch} tag.  The entry
    contains two fields; the \texttt{catch} tag and the value of
    \texttt{EBP} in the stack frame to return from.

  \item An entry representing a \texttt{block} or a \texttt{tagbody}.
    It is similar to the entry representing a \texttt{catch} tag.  The
    entry contains three fields; two fields representing a 64-bit time
    stamp and one field containing the value of ebp in the stack frame
    to return from.

  \item An entry representing an \texttt{unwind-protect} form.  This
    entry contains a thunk containing the cleanup forms of the
    \texttt{unwind-protect} form.
\end{itemize}

In addition to their own fields, each entry contains a pointer to the
next entry in the sequence, and a field indicating what type of entry
it is.

Of the three types of entries above, the \texttt{catch} and the
\texttt{block}/\texttt{tagbody} entries represent exit points.  An
exit point can be marked as "expired" or "invalid" by storing 0 as the
ebp value in the entry.

\texttt{catch} is implemented as a call to a function.  This function
establishes a \texttt{catch} tag and calls a thunk containing the body
of the \texttt{catch} form.  The \texttt{catch} tag is established by
allocating (as dynamic local data on the stack) an entry of the second
type and making \texttt{[EBP$-4 \cdot 4$]} point to it as shown in
\refFig{fig-x86-64-catch}

\begin{figure}
\begin{center}
\inputfig{fig-x86-64-catch.pdf_t}
\end{center}
\caption{\label{fig-x86-64-catch}
\texttt{catch} tag for the x86-64 backend.}
\end{figure}

THROW searches the dynamic environment for an entry with the right
\texttt{catch} tag.  If one is found and it is valid (as indicated by
the stored ebp different from 0), then the target to which control is
transferred is the return address in the stack frame indicated by the
stored ebp.

A \texttt{block} form may establish an exit point.  In the most
general case, a \texttt{return-from} is executed from a function
lexically-enclosed inside the \texttt{block} with an arbitrary number
of intervening stack frames.  When this is the case, \texttt{block} is
implemented as a call to a function, in a way similar to the way
\texttt{catch} is implemented.  The function establishes a
\texttt{block}/\texttt{tagbody} entry with a fresh time stamp.  The
time stamp is also stored in a lexical variable in the static
environment.  \refFig{fig-x86-64-block-tag} shows this situation.

\begin{figure}
\begin{center}
\inputfig{fig-x86-64-block-tag.pdf_t}
\end{center}
\caption{\label{fig-x86-64-block-tag}
\texttt{block} tag for the x86-64 backend.}
\end{figure}

\texttt{return-from} consults the time stamp in the lexical variable
and searches the dynamic environment for a corresponding time stamp in
a \texttt{block}/\texttt{tagbody} entry.  If one is found and it is
valid (as indicated by the stored ebp different from 0), then the
target to which control is transferred is the return address in the
stack frame indicated by the stored ebp.

A \texttt{tagbody} may establish several exit points.  In the most
general case, a \texttt{go} is executed from a function
lexically-enclosed inside the \texttt{tagbody} with an arbitrary
number of intervening stack frames.  When this is the case,
\texttt{tagbody} is implemented as a call to a function, in a way
similar to the way \texttt{block} is implemented.  The function
establishes a \texttt{block}/\texttt{tagbody} entry with a fresh time
stamp.  The time stamp is also stored in a lexical variable in the
static environment.  For each tag that is the target of a \texttt{go},
an address to which control is transferred is also stored in a lexical
environment.

\texttt{go} consults the time stamp in the lexical variable and
searches the dynamic environment for a corresponding time stamp in a
\texttt{block}/\texttt{tagbody} entry.  If one is found and it is
valid (as indicated by the stored ebp different from 0), then the
target to which control is transferred is defined by the lexically
stored ebp/address pair.  The code to which control is transferred is
responsible for adjusting esp to a particular value relative to ebp.

\section{Transfer of control to an exit point}

Whenever transfer of control to an exit point is initiated, the exit
point is first searched for.  If no valid exit point can be found, an
error is signaled.  If a valid exit point is found, the stack must
then be unwound.  First, the dynamic environment is traversed for any
intervening exit points, and they are marked as invalid by storing 0
as the stored ebp value.  The traversal stops when the stack frame of
the valid exit point is reached.  Unwinding now begins.  The dynamic
environment is traversed again and thunks in UNWIND-PROTECT entries
are executed.  The traversal again stops when the stack frame of the
valid exit point is reached.

\begin{figure}
\begin{center}
\inputfig{fig-x86-64-unwind-protect.pdf_t}
\end{center}
\caption{\label{fig-x86-64-unwind-protect}
\texttt{unwind-protect} tag for the x86-64 backend.}
\end{figure}

\begin{figure}
\begin{center}
\inputfig{fig-x86-64-dynamic-binding.pdf_t}
\end{center}
\caption{\label{fig-x86-64-dynamic-binding}
Dynamic variable binding for the x86-64 backend.}
\end{figure}

\section{Parsing keyword arguments}

When the callee accepts keyword arguments, it is convenient to have
all the arguments in a properly-ordered sequence somewhere in memory.
We obtain this sequence by pushing the register arguments to the stack
in reverse order, so that the first argument is at the top of the
stack.  When more than $5$ arguments are passed, the program counter
is popped off the top of the stack, thereby moving it to its final
destination before the register arguments are pushed.

%%  LocalWords:  callee
