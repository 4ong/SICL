\chapter{Data representation}
\label{chap-data-representation}

\section{Low-level tag bits}

The two least significant bits of a machine word are used to represent
four different \emph{tags} as follows:

\begin{itemize}
\item \texttt{00}.  This tag is used for fixnums.  The remaining bits
  represent a signed integer in two's complement representation.  On a
  32-bit machine, a fixnum is thus in the interval $[2^{-29}, 2^{29} -
    1]$.  On a 64-bit machine, a fixnum is in the interval $[2^{-61}, 2^{61} -
    1]$.  
\item \texttt{01}.  This tag is used for \texttt{cons} cells.  A
  pointer to a \texttt{cons} cell is thus a pointer aligned to a
  double word to which the machine integer $1$ has been added.  On a
  32-bit machine, the bit representing $2^2$ will always have the
  value $0$.  On a 64-bit machine, the bits representing $2^2$ and
  $2^3$ will always have the value $0$.
\item \texttt{10}.  This tag is used for various \emph{immediate}
  objects.  In particular for \emph{characters}, but also a
  distinguished bit pattern that is used to initialize \emph{unbound}
  variables and slots.  On 64-bit platforms \emph{single-floats} are
  represented as immediate values. 
\item \texttt{11}.  This tag is used for all heap-allocated objects
  other than \texttt{cons} cells.
\end{itemize}

\section{Immediate objects}

\subsection{Characters}

\subsection{Unbound}

\subsection{Short floats}

\subsection{Single floats}

\section{Representation of \texttt{cons} cells}

A \texttt{cons} cell is represented as two consecutive machine
words aligned on a double-word boundary.

\section{Representation of other heap objects}

All heap objects other than \texttt{cons} cells are represented in (at
least) two parts, a \emph{header} object and a \emph{contents} vector.
The header object always consists of two consecutive words aligned on
a double-word boundary (just like \texttt{cons} cells).  The first
word always contains a tagged pointer to a \emph{class} object (which
is another heap object).  The second word contains a \emph{raw
  pointer} to the first word of the contents vector.  In the following
sections we give the details of the representation for all possible
heap objects.

\section{Subclasses of \texttt{standard-object}}

Subclasses of \texttt{standard-object} must allow for must allow for
the class of an instance to be changed to some other class
(\texttt{change-class}) and for the definition of the class of the
instance to be modified.  Changing the class of an instance is fairly
straightforward because the instance is then passed as an argument and
the slots of the instance can be updated as appropriate.

Allowing for the class of an instance to be redefined is significantly
more complicated.  The main reason for that is that when a class is
redefined, the existing instances must be updated.  The standard
specifically allows for these updates to be delayed and not happen as
a direct result of the class redefinition.  They must happen before an
attempt is made to access some slot (or some other information about
the slots) of the instance.  It is undesirable to make the all
instances directly accessible from the class, because such a solution
would waste space and would have to make sure that memory leaks are
avoided.  We must thus take into account the presence of
\emph{obsolete instance} in the system, i.e., instances that must be
\emph{updated} at some later point in time. 

The solution is to store some kind of \emph{version} information in
the contents vector so that when an attempt is made to access an
obsolete instance, the instance can first be updated to correspond to
the current definition of its class.  This version information must
allow the system to determine whether any slots have been added or
removed since the instance was created.  Furthermore, if the garbage
collector traces an obsolete instance, then it must either first
update it, or the version information must allow the garbage collector
to trace the obsolete version of the instance.  Our solution allows
both.  We simply store a reference to the \emph{list of effective
  slots} that the class of the instance defined when the instance was
created.  This reference is stored as the first word of the contents
vector.  

This solution makes it possible to determine the layout of the
contents vector of an obsolete instance, so that it can be traced by
the garbage collector when necessary.  Furthermore, it is easy to
determine whether some instance is obsolete, simply by comparing the
list of effective slots in its \emph{class} (as contained in the first
word of the header object) to the list of effective slots stored in
the contents vector.  This comparison is fast, because it can be done
using \texttt{eq}.  Clearly, this solution also allows the system to
determine which slots have been added and which slots have been
removed since the instance was created. 

\section{Arrays}

An array being a heap object, it is represented as a two-word header
object and a contents vector.  For a \emph{simple} array the contents
vector contains:

\begin{itemize}
\item A word containing a fixnum that represents the \emph{rank} of
  the array.
\item A word containing a fixnum for each dimension of the array.
\item A number of consecutive words holding the contents of the
  array. 
\end{itemize}

The element type of the array is determined by the exact class of the
array. 

We suggest providing specialized arrays for the following data types:

\begin{itemize}
\item \texttt{double-float}
\item \texttt{single-float}
\item \texttt{(unsigned-byte $n$)}, where $n$ is the width of a
  machine word
\item \texttt{(signed-byte $n$)}, where $n$ is the width of a
  machine word.
\item \texttt{(unsigned-byte 8)}, used for code, interface with the
  operating system, etc. 
\item \texttt{character} (i.e., strings) as required by the HyperSpec.
\item \texttt{bit}, as required by the HyperSpec.
\end{itemize}

\section{Strings}

A string is a subtype of \texttt{array}.  Tentatively, we think that
there is no need to optimize strings that contain only characters that
could be represented in a single byte.  Thus the contents vector of a
\emph{simple} string is represented as follows:

\begin{itemize}
\item A fixnum with the value of 1.
\item A fixnum containing the number of characters in the string.
\item A number of consecutive words, each holding a tagged immediate
  object representing a Unicode character.
\end{itemize}

\section{Symbols}

A symbol is represented with a two-word header (as usual) and a
contents vector of three consecutive words.  The tree words contain:

\begin{enumerate}
\item The \emph{name} of the symbol.  The value of this slot is a
  string.
\item The \emph{package} of the symbol.  The value of this slot is a
  package or \texttt{NIL} if this symbol does not have a package.
\item The \emph{plist} of the symbol.  The value of this slot is a
  property list.
\end{enumerate}

Notice that the symbol does not contain its \emph{value} as a global
variable, nor does it contain its definition as a \emph{function} in
the global environment.  Instead, this information is contained in an
explicit \emph{global environment} object.

\section{Packages}

A package is represented with a two-word header (as usual) and a
contents vector of 7 words:

\begin{enumerate}
\item The \emph{name} of the package.  The value of this slot is a
  string.
\item The \emph{nicknames} of the package.  The value of this slot is
  a list of strings. 
\item The \emph{use list} of the package.  The value of this slot is a
  proper list of packages that are used by this package. 
\item The \emph{used-by list} of the package.  The value of this slot
is a proper list of packages that use this package. 
\item The \emph{external symbols} of the package.  The value of this
  slot is a proper list of symbols that are both present in and
  exported from this package.
\item The \emph{internal symbols} of the package.  The value of this
  slot is a proper list of symbols that are present in the package but
  that are not exported.
\item The \emph{shadowing symbols} of the package.  The value of this
  slot is a proper list of symbols. 
\end{enumerate}

\section{Hash tables}

\section{Streams}

\section{Functions}

An \emph{ordinary} (i.e., non-generic) function is represented as a
two-word header (as usual) and a contents vector of three words:

\begin{enumerate}
\item A \emph{code object} (see below).
\item An \emph{entry point} which gives an offset from the start of
  the instructions in the code object to the first instruction of the
  function. 
\item An \emph{environment}, which is the local environment in which
  the function was defined. If it is a global function, then the
  environment is \texttt{NIL}. 
\end{enumerate}

The \emph{class} of an ordinary function is a subclass of
\texttt{function}. 

A \emph{code object} is represented as a two-word header (as usual)
and a contents vector containing:

\begin{enumerate}
\item A byte vector containing the machine instructions for one or
  more functions.
\item A simple vector called the \emph{linkage vector} which contains
  objects that executing functions need to access such as values of
  complex constant objects, cells containing function objects
  for global functions used in the code, symbols naming special
  variables, etc.  The linkage vector is created and filled as a
  result of a \emph{fasl} file being loaded, or as a result of calling
  \texttt{compile}. 
\item Correspondence between values of the program counter
  (represented as offsets into the byte vector of instructions) and
  source code locations.  
\item Correspondence between values of the program counter and the
  contents of the local environment.  This information is used by the
  garbage collector and by the debugger. 
\end{enumerate}

By having several functions share the same code object, we can
simplify calls between functions in the same compilation unit, because
the caller and the callee would then share the same code object,
including the linkage vector.  In contrast, a call from a function in
one compilation unit to a function in a different compilation unit
involves (in the most general case) storing the linkage vector in a
register and setting a slot in the stack frame containing the code
object of the callee. 

For a \emph{generic function}, each method contains a separate
ordinary function.  
