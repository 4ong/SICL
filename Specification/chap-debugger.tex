\chapter{Debugger}
\label{chap-debugger}

Part of the reason for SICL is to have a system that provides
excellent debugging facilities for the programmer.  The kind of
debugger we plan to support is described in a separate repository.%
\footnote{See https://github.com/robert-strandh/Clordane}  In this
chapter, we describe only the support that \sysname{} contains in
order to make such a debugger possible.

When a function is compiled with a high value of the \texttt{debug}
quality%
\footnote{In fact, given the small cost of this feature, we might
  include it even though the value of the \texttt{debug} quality is
  low.},
the execution of that function starts by loading a \emph{flag} that is
specific to the thread into a lexical variable.  How that flag is
passed has yet to be determined, but it could be in an ordinary
register, in a floating-point register, or as a condition code.  This
flag indicates whether the
current thread is being debugged.  The function contains two versions
of the code, one that does its execution normally and one that has a
small test before and after the evaluation of each source-level form%
\footnote{This idea was suggested by Michael Raskin.}.
The flag determines which version is chosen.  Thus, when the thread is
not being debugged, the only overhead is a single test at the
beginning of the function.

In the debug version of the function body the compiler inserts a call
to a small subroutine before and after every form to be evaluated.
The subroutine does not use the full \commonlisp{} function-call
protocol.  Instead, it is just a very fast call that can be done with
a \texttt{jsr} instruction (or equivalent) on must architectures.

The subroutine does a test in two steps.  In the first step, the value
of the program counter is taken modulo some reasonably large value
such as 256, and a bit-table in the thread instance is queried to see
whether the corresponding entry is a 1.  If it is 0, the subroutine
simply returns.  This first step will slow down every debugged thread
a little bit, but most of the time, the value will be 0, and then,
normal function execution is resumed.

If the entry in the bit table turns out to be 1, then the final test
is made.  The program counter is checked against a hash table in the
thread instance to see whether some action must be taken.  If so, the
thread gives up control to the debugger.

%% For each possible breakpoint, the system must keep a description of
%% the lexical environment.  This includes mappings from variable names
%% to registers or stack locations, information about liveness of
%% registers and stack location, how a variable is stored in a location
%% (immediate value, pointer, with or without type tag, etc).

