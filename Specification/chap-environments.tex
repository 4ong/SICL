\chapter{Environments}
\label{chap-environments}

\cl{} has a concept of \emph{environments}, and in fact several
different environments and several different \emph{kinds} of
environment are mentioned in the HyperSpec.  However, \cl{} does not
mandate any particular representation of these environments, nor does
it mention any particular \emph{operations} on environments other than
the implicit operations of defining functions, variables, macros,
types, etc. 

\section{The global environment}
\label{sec-the-global-environment}

In many \cl{} systems the global environment is \emph{spread out} in
that it does not have an explicit definition as a data type.  Parts of
it might be contained in global locations such as the set of packages
or the set of classes.  Other parts of it may be stored in symbols
such as the value or the function definition of a symbol.  The
standard specifically allows for this kind of spread-out
representation.  

In \sysname{}, we prefer to have an explicit representation of the
global environment as a data object.  By doing it this way, we can
allow for any number of global environments present in the system at
any point in time.  Different global environments can have a different
set of packages, a different set of classes, a different set of types,
etc.  This representation can give us several interesting advantages: 

\begin{itemize}
\item We might ensure that there is always a \emph{sane} environment
  present in case some environment gets destroyed (by a user
  accidentally removing some essential system function, for instance).
\item We can allow for several different packages with the same name
  to exist in a system, as long as they are present in different
  environments, which would allow for simpler experimentation with
  different versions of packages. 
\item We could even imagine a multi-user system based on different
  environments, and we could then allow users to do things such as
  defining \texttt{:after} methods on \texttt{print-object} that are
  private to that user. 
\item etc.
\end{itemize}

A global environment in \sysname{} would then contain:

\begin{itemize}
\item A set of \emph{packages}, represented either as a list or as a
  hash table mapping names to packages.
\item A dictionary of \emph{classes}, represented either as an
  association list or as a hash table mapping names to classes.
\item A mapping from function names to functions, macros, and special
  operators.
\item Type information for names of functions.
\item A mapping from names to type definitions.
\item A mapping from names to \emph{variables}.
\item Values of \emph{constant variables}.
\item etc.\fixme{State exactly what the global environment contains.}
\end{itemize}

\section{The static runtime environment}
\label{sec-environments-static-runtime}

The \emph{static runtime environment} contains runtime objects that
the compiler can not prove to have \emph{dynamic extent}, so it must
assume that they have \emph{indefinite extent}.  

This situation occurs when some function captures the environment by
using a \texttt{lambda} expression which contains references to local
variables outside the expression itself.  Though such a capture in
itself does not necessarily imply that the variables thus referenced
have indefinite extent.  It all depends on what happens to the
function that is the result of the lambda expression.  

If that function is just \emph{called}, then there is no capture.  This
situation might occur as a result of a \texttt{let} being transformed
into an application of a \texttt{lambda} expression.  

If that function is passed as an argument to another function which is
known not to hold on to its argument for longer than the duration of
the function invocation, then there is no capture.  The typical
situation would be when a \texttt{lambda} expression is passed to a
standard \cl{} function such as one of the \emph{sequence} functions
that is known to have this property.  

In other cases, it might be too risky for the compiler to assume
dynamic extent.  Even if a function is called which declares its
corresponding parameter to have dynamic extent, it might be too risky
to trust this, because the function might be redefined later.%
\footnote{An exception would be if the called function is in the same
  \emph{compilation unit} in which case it can not be redefined
  without the caller being redefined at the same time.}

When the compiler must assume that some variable has indefinite
extent, then code must be generated to store that variable in a
heap-allocated environment.  We represent this environment as a proper
\cl{} list of simple vectors.  

This representation might seem wasteful, because a simple vector is
represented as a header object and a contents vector containing the
\emph{length} of the vector, though that information is implicit in
the value of the program counter, so it could be elided.  The
representation is wasteful in two ways:

\begin{itemize}
\item Allocation is a bit slower because two chunks of memory must be
  allocated and linked, and length information must be stored. 
\item Looking up the value of a variable requires another
  indirection. 
\end{itemize}

However, we think this apparent waste is going to be insignificant.
Take for instance the example of a sequence function.  The capture
itself (and the allocation of the environment) is going to be
insignificant compared to the processing done by the sequence
function.  Furthermore, the access to the captured variable is going
to be insignificant compared to the overhead of calling the closure
from the sequence function because of all the checks that have to be
made such as argument count, etc.  

