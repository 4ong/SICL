\chapter{Bootstrapping}

An image I is said to be \emph{viable} if and only if it is possible
to obtain a complete \cl{} system by starting with I and loading a
sequence of ordinary compiled files.

There are many ways of making a viable image.  We are interested in
making a \emph{small} viable image.  In particular, we want the
initial image \emph{not to contain the compiler}, because we want to
be able to load the compiler as a bunch of compiled files. 

By requiring the viable image not to contain the compiler, we place
some restrictions on the code in it.  

One such restriction is that creating the discriminating function of a
generic function is not allowed to invoke the compiler.  Since doing
so is typical in any CLOS implementation, we must find a different
way.

Another such restriction concerns the creation of classes.  Typically,
when a class is created, the reader and writer methods are created by
invoking the compiler.  Again, a different way must be found.

In order to create an instance of a class, the following functions
are called, so they must exist and be executable:

\begin{itemize}
\item \texttt{make-instance}.  Called directly to create the instance.
\item \texttt{allocate-instance}.  Called by \texttt{make-instance} to
  allocate storage for the instance.
\item \texttt{initialize-instance}.  Called by \texttt{make-instance}
  to initialize the slots of the instance.
\item \texttt{shared-initialize}.  Called by
  \texttt{initialize-instance}.
\item \texttt{slot-value}.  Called by \texttt{shared-initialize}.
\item \texttt{(setf slot-value)}.  Called by
  \texttt{shared-initialize}.
\end{itemize}

Most of these functions are generic functions, so the functionality
that implements generic function dispatch must also be in place,
including:

\begin{itemize}
\item \texttt{compute-discriminating-function}.
\item \texttt{compute-applicable-methods}.
\item \texttt{compute-applicable-methods-using-classes}.
\item \texttt{compute-effective-method}.  This function returns a form
  to be compiled, but since we do not have the compiler, we instead
  use some more direct method similar to what is shown in chapter 1 of
  the AMOP.  Furthermore, in order to take into account different
  method combinations, we also need the compiler, so only the method
  combinations used by the compiler will be considered at
  bootstrapping.
\end{itemize}

\section{Bootstrapping stages}

\subsection{Stage 1, compiling macro definitions}

Stage 1 of the bootstrapping process consists of using the cross
compiler to compile files containing definitions of standard macros
that will be needed for compiling other files. 

When a \texttt{defmacro} form is compiled by the cross compiler, we
distinguish between the two parts of that defmacro form, namely the
\emph{expander code} and the \emph{resulting expansion code}.  The
\emph{expander code} is the code that will be executed in order to
compute the resulting expansion code when the macro is invoked.  The
\emph{resulting expansion code} is the code that replaces the macro
call form. 

As an example, consider the hypothetical definition of the
\texttt{and} macro shown in \refCode{code-defmacro-and}.

\begin{codefragment}
\inputcode{code-defmacro-and.code}
\caption{\label{code-defmacro-and}
Example implementation of the \texttt{and} macro.}
\end{codefragment}

In \refCode{code-defmacro-and}, the occurrences of \texttt{car},
\texttt{cdr}, \texttt{null}, and \texttt{cond} are part of the
\emph{expander code} whereas the occurrence of \texttt{when}, of
\texttt{t}, and the occurrence of \texttt{and} in the last line are
part of the resulting expansion code. 

The result of expanding the \texttt{defmacro} form in
\refCode{code-defmacro-and} is shown in
\refCode{code-macro-expansion-and}. 

\begin{codefragment}
\inputcode{code-macro-expansion-and.code}
\caption{\label{code-macro-expansion-and}
Expansion of the macro call.}
\end{codefragment}

Thus, when the code in \refCode{code-defmacro-and} is compiled by the
cross compiler, it is first expanded to the code in
\refCode{code-macro-expansion-and}, and the resulting code is compiled
instead.  Now \refCode{code-macro-expansion-and} contains an
\texttt{eval-when} at the top level with all three situations (i.e.,
\texttt{:compile-toplevel}, \texttt{:load-toplevel}, and
\texttt{:execute}.  As a result, two things happen to the
\texttt{funcall} form of \refCode{code-macro-expansion-and}:

\begin{enumerate}
\item It is \emph{evaluated} by the \emph{host function}
  \texttt{eval}.
\item It is \emph{minimally compiled} by the cross compiler.
\end{enumerate}

In order for the evaluation by the host function \texttt{eval} to be
successful, the following must be true:

\begin{itemize}
\item All the \emph{functions} and \emph{macros} that are
  \emph{invoked} as a result of the call to \texttt{eval} must exist.
  In the case of \refCode{code-macro-expansion-and}, the function
  \texttt{(setf sicl-environment::macro-function)} must exist, and that
    is all.
\item All the \emph{macros} that occur in macro forms that are
  \emph{compiled} as a result of the call to \texttt{eval} must
  exist.  These are the macros of the expansion code; in our example
  only \texttt{cond}.  Clearly, if only standard \cl{} macros are
  used in the expansion code of macros, this requirement is
  automatically fulfilled.
\item It is \emph{preferable}, though not absolutely necessary for the
  \emph{functions} that occur in function forms that are
  \emph{compiled} as a result of the call to \texttt{eval} exist.  If
  they do not exist, the compilation will succeed, but a warning will
  probably be issued.  These functions are the functions of the
  expansion code; in our example \texttt{car}, \texttt{cdr}, and
  \texttt{null}.  Again, if only standard \cl{} function are used in
  the expansion code of macros, this requirement is automatically
  fulfilled.  It is common, however, for other functions to be used as
  well.  In that case, those functions should preferably have been
  loaded into the host environment first. 
\end{itemize}

In order for the minimal compilation by the cross compiler to be
successful, the following must be true:

\begin{itemize}
\item All the \emph{macros} that occur in macro forms that are
  \emph{minimally compiled} by the cross compiler must exist.  These
  are again the macros of the expansion code; in our example only
  \texttt{cond}.  Now, the cross compiler uses the \emph{compilation
    environment} of the \emph{target} when looking up macro
  definitions.  Therefore, in order for the example in
  \refCode{code-defmacro-and} to work, a file containing the
  definition of the macro \texttt{cond} must first be compiled by the
  cross compiler. 
\item While it would have been desirable for the \emph{functions} that
  occur in function forms that are \emph{minimally compiled} by the
  cross compiler to exist, this is typically not the case.%
  \fixme{Investigate the possibility of first compiling a bunch of
    \texttt{declaim} forms containing type signatures of most
    standard \cl{} functions used in macro expansion code.}
  As a
  result, the cross compiler will emit warnings about undefined
  functions.  The generated code will still work, however.
\end{itemize}

Of the constraints listed above, the most restrictive is the one that
imposes an order between the files to be cross compiled, i.e., that
the macros of the expansion code must be cross compiled first.  It is
possible to avoid this restriction entirely by using \emph{auxiliary
  functions} rather than macros.  The alternative implementation of
the \texttt{and} macro in \refCode{code-defmacro-and-2} shows how this
is done in the extreme case.

\begin{codefragment}
\inputcode{code-defmacro-and-2.code}
\caption{\label{code-defmacro-and-2}
Alternative implementation of the \texttt{and} macro.}
\end{codefragment}

We use the technique of \refCode{code-defmacro-and-2} only when the
expansion code is fairly complex.  An example of a rather complex
expansion code is that of the macro \texttt{loop} which uses mutually
recursive functions and fairly complex data structures.  When this
technique is used, we can even use a macro to implement its own
expansion code.  For instance, nothing prevents us from using
\texttt{loop} to implement the functions of the expander code of
\texttt{loop}, because when the \texttt{loop} macro is used to expand
code in the cross compiler, the occurrences of \texttt{loop} in the
functions called by the expander code are executed by the host.  As it
turns out, we do not do that, because we would like for the \sysname{}
implementation of \texttt{loop} to be used as a drop-in extension in
implementations other than \sysname{}.


