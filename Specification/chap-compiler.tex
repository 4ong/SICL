\chapter{Compiler}
\label{chap-compiler}

\section{Different uses of the compiler}

The compiler is used in several different situations.  There are
essentially three use cases, so it is appropriate to talk about three
different compilers:

\begin{itemize}
\item The \emph{file compiler}.  This compiler is invoked by
  \texttt{compile-file}.  It takes a \cl{} source file and generates a
  file containing object code (a so-called \emph{fasl} file). 
\item The \emph{lambda expression compiler}.  This compiler is invoked
  when \texttt{compile} is called with arguments \texttt{nil} and a
  \emph{lambda expression}, and by \texttt{coerce} to convert a lambda
  expression to a function.  It compiles the lambda expression in the
  \emph{null lexical environment}.  It produces a \emph{function
    object}.
\item The \emph{top-level expression compiler}.  This compiler is
  invoked by \texttt{eval}.  It produces a function with no parameters
  which is then immediately \emph{called} by \texttt{eval}.  
\end{itemize}

In addition to these use cases, we also distinguish between different
compilers along an orthogonal dimension:

\begin{itemize}
\item A \emph{native} compiler is a compiler that produces code for
  its host \cl{} system. 
\item A \emph{foreign} compiler is a compiler that produces code for a
  \cl{} system other than its host system.  A foreign compiler is
  also known as a \emph{cross compiler}.
\end{itemize}

We now have potentially 6 different compilers.  Specific issues
related to cross compilation are discussed in
\refChap{chap-cross-compilation}. 

\section{Compilation phases}

\subsection{Read (file compiler)}

If the file compiler is used, then the first thing that happens is
that a top-level form is \emph{read} from a file stream.  The result
of this phase is a data structure representing the form in the usual
way. 

In addition to the internal data structure, the reader also supplies
information about \emph{source location} of each form.  

\subsection{Convert to abstract syntax tree}

\subsubsection{Processing of top-level forms}

The \hs{} requires the file compiler to process top-level forms in a
special way.%
\footnote{See section 3.2.3.1 in the \hs{}.}
As part of this processing, the compiler might call \texttt{eval} to
evaluate forms in the \emph{evaluation environment} of the
compilation. 

\subsubsection{Conversion}

A top-level form that is required to be compiled is then converted
into an abstract syntax tree.  This is done in the usual way, by
traversing the form while accessing a \emph{syntactic environment}
which determines what different types of expressions mean,
i.e. whether a variable is really a symbol-macro, and whether a
compound expression is a function call, a macro call, or a special
form.  In this step, macros and symbol macros are expanded, and nodes
the abstract syntax tree are created as
appropriate. \seechap{chap-abstract-syntax-tree} References to
variables are replaced by nodes so that the name of a variable no
longer influences its scope.

\subsubsection{Inlining}

As part of this phase, a \emph{function call form} might be replaced
by the body of the function that is called.  Whether this
transformation happens or not depends on several factors:

\begin{itemize}
\item The abstract syntax tree of the called function must be
  available.  In general, this will be the case when an
  \texttt{inline} declaration was in effect when the function was
  defined.  But it could also be the case that the abstract syntax
  tree was explicitly removed, for instance as part of the delivery of
  commercial code. 
\item As required by the \hs{}, there must not be a \texttt{notinline}
  declaration of the function in effect when the function call form is
  encountered.
\item In \sysname{} we also require that there be an \texttt{inline}
  declaration in effect when function call form is encountered.
\end{itemize}

The reason inlining is done this early is that the code that is
generated may depend on the \emph{context} in which a form is
evaluated, and in particular how many \emph{values} are required.  

\subsection{Convert to medium-level intermediate representation}

In the next phase, the abstract syntax tree is converted into a
\emph{flowchart}, which is a particular kind of \emph{graph} with two
kinds of nodes (\emph{instruction nodes} and \emph{data nodes}) and
two kinds of edges (\emph{control-flow edges} and \emph{data-flow
  edges}).  For details on this representation, see
\refChap{chap-mir}.

\subsection{Optimizations}

\subsection{Code generation} 

\section{Random thoughts}

The compiler should be as portable as possible.  It should use
portable Common Lisp for as many of the passes as possible.  

The compiler should keep information about which registers are live,
and how values are represented in live registers, for all values of
the program counter.  This information is used by the garbage
collector to determine what registers should be scanned, and how.   It
is also used by the debugger.  

The compiler should do some extensive type inferencing.  It should be
able to eliminate code for which the result of executing it is known
as a result of the contents of the compilation environment.  

