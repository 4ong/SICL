\chapter{Garbage collector}

To fully appreciate the contents of this chapter, the reader should
have some basic knowledge of the usual techniques for garbage
collection.  We recommend ``The Garbage Collection Handbook''
\cite{Jones:2011:GCH:2025255} to acquire such basic knowledge.  We
also recommend Paul Wilson's excellent survey paper
\cite{Wilson:1992:UGC:645648.664824}.

We think it would be good to use a per-thread nursery combined with a
global allocator for older objects.

In \refChap{chap-data-representation} we suggest a data representation
where every heap allocated object has a two-word header object.  If it
is a \texttt{cons} cell, then that is the entire object.  For other
heap-allocated objects (called \emph{general instances}, the first of
the two words is a tagged pointer to the class object, and the second
of the two words is a raw pointer to the \emph{rack}.  In
this chapter, we describe the consequences of this suggested
representation to the garbage collector.

We begin this chapter by describing the algorithms used in the global
collector and the nursery collector.  We then describe how promotion
takes place.  Finally, we describe the synchronization procedure
required for the nursery collectors to collaborate with the global
collector.

\section{Global collector}
\subsection{General description}

No implementation work has been done yet on the global collector.

The global collector is a concurrent collector, i.e., it runs in
parallel with the mutator threads.  With modern processors, it is
probably practical to assign at least one core more or less
permanently to the global collector.  According to current thinking,
the global collector will be a combination of a mark-and-sweep
collector and a  traditional memory allocator as implemented by
\texttt{malloc()/free()} in a \clanguage{} environment.

We define a global heap divided into two parts.  The first part is a
single vector consisting of two-word blocks.  This is where
\texttt{cons} cells and the \emph{headers} of general instances are
allocated.  The second part of the global heap is organized as the
space managed by an ordinary memory allocator, for example the one
created by Doug Lea.%
\footnote{A few simplifications compared to Doug Lea's allocator are
  likely possible, given the difference in allocation patters of a
  typical \clanguage{} program and the requests from the nursery
  collectors of \sysname{}.}

Since all general instances have a two-word header and \texttt{cons}
cells consist of two words as well, we can use a mark-and-sweep
collector for these objects without suffering any fragmentation.  The
advantage of a mark-and-sweep collector is that objects will never
move, which is an advantage when they are used as keys in hash tables
and when they are used to communicate with code in foreign languages
that assume that an address of an object is fixed once and for all.

The racks are allocated in the second part of the global heap.  As a
consequence, the racks also do not move once allocated.  This
fixed position is advantageous for code on some architectures.  For
example, the correspondence between source code location and values of
the program counter does not have to be updated as a result of code
being moved by the garbage collector.

Another great advantage of racks being in a permanent position is that
mutator threads can cache a pointer without the necessity of this
pointer having to be updated as a result of a garbage collection in
the global heap.  Garbage collection in the global heap can therefore
be done in parallel with the execution of the mutator threads.

The global collector is subject to a write barrier.  Let G be some
object in the global heap, and let N be some object in a nursery.  The
write barrier must prevent the existence of a reference from G to N.
Therefore, when attempt is made to create such a reference, N and its
transitive closure is first moved to the global heap.  As a result,
there are no references from the global heap to objects in any
nursery.  The write barrier is implemented as a test, emitted by the
compiler, to determine:

\begin{enumerate}
\item whether the object written to is indeed an object in the global
  heap, and
\item whether the datum being written is a reference to a
  heap-allocated object (as opposed to an immediate object).
\end{enumerate}

In many cases, this test can be omitted as a result of \emph{type
  inference}, for instance if the datum being written can be
determined at compile time to be an immediate object.

The write barrier is tripped whether the reference to be stored is to
an object in the global heap or to an object in the local heap.  In
the first case, the write barrier is used to make sure there is not a
reference to a white object stored in a black object.  In the second
case, the write barrier is used to trigger a migration of local
objects to the global heap.

Objects in the global heap are \emph{allocated black}, i.e. it is
assumed that they are referenced.  When the global heap is about to be
collected, threads are first asked to garbage collect their nurseries
and then to report any references to objects in the global heap.  Once
every thread has finished this task, collection in the global heap can
start.  The first part of the heap is scanned and a free list of
objects that are no longer referenced is established.  Then, this free
list is traversed, effectively executing a \texttt{free()} of the rack
in the second part of the heap.

In order for marking by the global collector to be done in parallel
with mutator activity, we use a standard three-color marking
algorithm.  As mentioned before, we use a write barrier, so that when
a reference to a white object is about to be stored in a black object,
we change the color of either one of the two to gray.  The choice can
be based on the type of objects in question, or it can be a global
choice.  The write barrier is implemented as additional instructions
emitted by the compiler.  These additional instructions can be avoided
in many cases, and in particular when the object being stored is known
to be an immediate object (fixnum, character, etc) or when it an
unboxed object to be stored in a specialized array.  The type
inferencer can thus be used to determine whether the write barrier can
be elided.

\subsection{Protocol}

The names of these functions are exported by the package named
\texttt{sicl-global-allocator}.

\Defun {copy-object} {object}

This function takes an object that is allocated in some thread-local
heap, copies it, and returns a copy that is allocated in the global
heap.  All the objects referred to by \textit{object}, including the
class of a general instance, must either be immediate objects, or
objects located in the global heap,

\Defun {make-array} {dimensions \key element-type initial-element
  initial-contents adjustable fill-pointer}

This function is similar to the \commonlisp{} function with the same
name.  The difference is that this function can not be used to
allocate displaced arrays.  This function can be used by client code
to allocate arrays that are too big to be allocated in the
thread-local heap.  All arguments must either be immediate objects, or
objects located in the global heap.

\Defun {allocate-rack} {size}

Allocate a rack containing \textit{size} words and return an untagged
pointer to it.  Because the pointer is untagged, it will look like a
fixnum.

\Defun {allocate-header} {class rack}

This function allocates a new two-word header and returns a tagged
pointer to it.  The argument \textit{class} is the class of the object
to be constructed.  The argument \textit{rack} is the rack that holds
the data contained in the object to be constructed.

\Defun {cons} {car cdr}

This function allocates a new two-word \texttt{cons} cell and returns
a tagged pointer to it.  The arguments have the same meaning as for
the standard \commonlisp{} function \texttt{cons}.

\section{Nursery collector}

\subsection{General description}

The directory \texttt{Code/Garbage-collector} contains some code that
uses a different data representation from what we now suggest.  

For the nursery, we suggest using a copying collector to manage small
(a few megabytes) linear space.  Instead of promoting objects that
survive a collection, we suggest using a \emph{sliding collector} in
the nursery.  Such a collector gives a very precise idea of the age of
different objects, so objects would always be promoted in the order of
the oldest to the youngest.  This technique avoids the problem where
the allocation of some intermediate objects is immediately followed by
a collection, so these objects are promoted even though they are
likely to die soon after the collection.  In a sliding collector,
promotion will happen only when a collection leaves insufficient space
in the nursery, at which point only the number of objects required to
free up enough memory would be promoted, and in the strict order of
oldest to youngest.

\subsection{Allocation}

The nursery allocator maintains two pointers into the nursery, namely
the \emph{header free pointer} and the \emph{rack free pointer}.  The
header free pointer always has a smaller value than the rack free
pointer.  These pointers are illustrated in
\refFig{fig-nursery-pointers}.

\begin{figure}
\begin{center}
\inputfig{fig-nursery-pointers.pdf_t}
\end{center}
\caption{\label{fig-nursery-pointers}
Allocation pointers in the nursery.}
\end{figure}

The nursery allocator also contains a bitmap called the \emph{general
  instance bitmap} with half the number of bits in compared to the
number of words in the nursery, or one bit for every possible header
in the nursery.  If a bit in the bitmap is set, that means that the
corresponding header object is a general instance.  If it is cleared,
it means that the header object is a \texttt{cons} cell.  This
information is necessary so that the garbage collector can determine
whether the header object points to a rack or not in the rack
compaction phase as explained in
\refSec{sec-garbage-collection-rack-compaction-phase}.

To allocate a \texttt{cons} cell or a header, the value returned is
the existing value of the header free pointer with appropriate tag
bits added.  Before this value is returned, the header free pointer is
incremented by a value corresponding to two full words.  If a
\texttt{cons} cell is allocated, no further action is required.  If
not, the corresponding bit is set in the general instance bitmap.

To allocate a rack, the rack free pointer is first decremented by a
value corresponding to the number of words in the rack.  The new value
of the rack free pointer is then returned.  No tag bits are added.

When a request for allocation would result in less than one free word
left in the nursery, a collection is first triggered before the
request is granted.  The reason we need one spare word is explained in
\refSec{sec-garbage-collection-break-table-build-phase}.

\subsection{Finding roots}

Several of the phases of the nursery collector involve finding every
\emph{root}, i.e., every \commonlisp{} object that is currently in a
processor register or on the stack.  What is done to the object once
it is found, depends on the phase.

Finding the roots is a fairly complicated procedure, which is probably
why some implementations prefer traversing the stack
\emph{conservatively}, i.e., considering every word on the stack that
\emph{might} be a root to actually \emph{be} one.  But such tricks
complicate other aspects of the garbage collector.

In \sysname{} we use \emph{precise} stack traversal, meaning that we
know exactly when a location contains a root and when it does not.

This precise traversal is complicated by the fact that some registers
are so called \emph{callee saves} registers, meaning that a particular
function invocation does not save the register to the stack before
making a function call, and instead it relies on a the first function
on the call chain that needs to use the register to save it and
restore it after use.  A direct consequence of this scheme is that a
register or a stack location close to the top of the stack may contain
a datum that belongs to a function invocation arbitrarily further down
the stack, and whether that register or stack location is a root can
only be determined by knowing the current value of the program counter
in that function invocation.

To find the roots owned by each stack frame, we use the \emph{return
  address} stored in the stack frame immediately above the one we are
interested in.  That return address is used to access the
\emph{register map}, the \emph{stack frame map}, and the
\emph{callee-saves map} as described in
\refSec{data-representation-code-objects}.

When the stack traversal starts, the top stack frame belongs to the
garbage collector itself.  That frame does not contain any roots.  We
maintain a table called \emph{register contents table} of contents of
callee-saves registers.  The table is initially filled with the
current contents of those real registers.

The stack is then traversed, frame by frame, starting with the second
one from the top, and using the return address in the top frame.
Initially, the register contents table contains the current value of
those registers when the root-finding function was called.

When a stack frame is visited, the \emph{register map} and the
\emph{stack frame map} are used to determine location of roots.  When
those roots have been processed, the \emph{callee-saves map} for the
current stack frame is consulted.  Recall that this map is indexed by
a callee-saves register and contains a stack location in the current
frame.  The values of the register entry in the register contents
table and the corresponding stack frame are swapped, so that the
register contents table now contains the callee-saves registers for
the next frame, and the next frame is then visited.

When the bottom frame of the stack has been processed, be back up by
applying the information in the callee-saves map again, thereby
swapping back to the correct contents of the stack frame.

\subsection{Mark phase}

The mark phase uses a separate bitmap called the \emph{live object
  bitmap}.  It has a bit for every two words in the nursery.  After
the mark phase has finished, if a bit is set in the bitmap, it means
that the corresponding object (as represented by the header or a
\texttt{cons} cell) is live.  The live object bitmap is initialized so
that all bits are cleared before the mark phase begins.

The mark phase starts by determining the place in the code where an
allocation was requested.  It uses this information to consult the
\emph{code object} of the function in which is stored information
about register contents and stack-frame layout. Every register or
stack location containing a heap-allocated object is visited.  A flag
determines whether a reference to an object allocated in the global
heap should be marked or not.  This flag is set when the local garbage
collection was requested by the global garbage collector, and cleared
when the local garbage collection was performed as a result of the
local heap being full.  If a traced object is located in the heap and
the flag is set, then the global collector is informed that it is
live.  If the object is located in the nursery, the corresponding bit
in the live object bitmap is set, and the object is traced according
to its class.  For a \emph{cons} cell, the \texttt{car} and the
\texttt{cdr} are recursively visited.  For a general instance, the
class is visited, and also consulted to determine what words of the
rack may contain pointers to heap-allocated objects.  Tracing stops
when an object is reached that has already been traced.

The mark phase maintains an integer variable named \emph{live object
  space}.  It is initialized to $0$ at the beginning of the mark
phase.  For every unmarked object in the nursery that is encountered,
the value of the variable is incremented by the size of that object.
If the object is a general instance, as indicated by the corresponding
bit being set in the general instance bitmap, then not only is the
rack traced, but the size of the rack is added to the value of the
variable as well.  When the mark phase is finished, this variable
contains the total amount of live space in the nursery.

At the end of the mark phase, if the flag is set, a \emph{signal}
operation is performed on a semaphore used for synchronization between
the local and the global garbage collector.

\subsection{Promotion phase}

After the mark phase has finished, the value of the variable
\emph{live object size} is used to determine whether some of the
objects in the nursery should be \emph{promoted}.  Good threshold
values are yet to be determined, but we think that if more than half
the nursery contains live objects, then some objects should be
promoted.  The higher the threshold, the more likely it is that a
collection will be triggered soon after the current one.  The lower
the threshold, the more likely it is for young objects to be promoted
even though they are likely to die soon.

The other threshold value to be determined is how many objects should
be promoted.  We think that, after promotion, around one fourth of the
nursery should contain live objects.  The higher the threshold, the
more likely it is for another promotion to be triggered during the
next invocation of the collector.  The lower the threshold, the more
likely it is for young objects to be promoted even though they are
likely to die soon.

The promotion phase uses a bitmap called the \emph{promotion bitmap}
again containing one bit per possible header in the nursery.  This
bitmap is initialized so that all its bits are cleared.  When a bit is
set, it indicates that the corresponding object has been moved to the
global heap, and that the first word of the corresponding header in
the nursery contains a reference to the promoted copy of the object.

The promotion phase executes a loop over the live objects that have
not yet been promoted in the nursery, starting from the one with the
smallest address.  An object is skipped if it not live, as indicated
by the bit in the live object bitmap, and an object is skipped if it
has already been promoted, as indicated by the bit in the promotion
bitmap.  If the object is not to be skipped, it is promoted.  This
means that a \emph{copy} of the object is allocated in the global
heap.  A forward reference is stored in the first word of the header
of the original object, and a bit is set in the promotion bitmap.
Notice that, during this phase, there will be references from the
global heap to the nursery, but these references will never be
followed by the global collector, and they will disappear at the end
of the promotion phase.

The newly promoted \emph{copy} is then traced in much the same way as
objects are traced during the mark phase.  An object is traced by
recursively visiting its contained objects.  When a visited object
reference indicates that it has already been promoted, as indicated by
the corresponding bit being set in the promotion bitmap, the reference
is replaced by the forward reference stored in the first word of the
header in the nursery, and tracing stops.  If the visited object has
not yet been promoted, then a copy is allocated in the global heap as
described above.  The corresponding bit in the promotion bitmap is set
and a forward reference is stored, again as above, and the copy is
recursively traced.  Notice that if a functional programming style is
used, all objects referred to by the initial copy will have already
been promoted.  Only side effects can result in an object containing a
reference to an object that was allocated later on in the nursery.
Therefore, if a functional style is used, the recursion will be very
shallow.  For every object that is being promoted, we keep a tally of
the amount of total space that has been promoted this way.  When the
total amount of space is greater than or equal to the threshold that
has been determined, the outer loop stops.  We can not, however, stop
the tracing in each iteration, because stopping it prematurely means
that there will be references from the global heap to the nursery
remaining after this phase.

When a sufficient number of objects have been promoted, the registers
and the stack are traversed again, much in the same way as during the
mark phase in order to find every object reference referring to an
object in the nursery that has been promoted, as determined by the
promotion bitmap.  Such a reference is replaced by the forward
reference stored in the first word of the header in the nursery.

Finally, every object in the nursery that has not been promoted is
scanned to determine any reference to a promoted object.  Such a
reference is replaced by the forward reference as before.

When every relevant reference to a promoted object has been updated
this way, the promotion bitmap is subtracted from the live object
bitmap.  This way, the live object bitmap has a bit set only for live
objects that are still in the nursery.

\subsection{Header compaction phase}

In the \emph{header compaction phase}, live header objects are compacted
toward the beginning of the heap.  A \emph{source} and a \emph{target}
pointer follow blocks in the bitmap and live words are moved. 

\subsection{Break table build phase}
\label{sec-garbage-collection-break-table-build-phase}

In the \emph{table build phase}, the bitmap is used to construct an
\emph{offset table} at the end of the lower part of the heap.  The
offset table contains a sequence of pairs $<a,o>$ meaning that a
pointer with an address less than or equal to $a$ (and greater than
the corresponding field of the previous pair) should be adjusted by
offset $o$.  There is always enough room for this table, because it
can contain at most as many entries as there are dead header objects.  

\subsection{Pointer adjustment phase}

In the \emph{adjust phase}, header objects and racks are
scanned, and fields containing pointers are adjusted according to the
offset table.  The offset table is searched using binary search,
except that a simple caching scheme is used to avoid a full binary
search in nearly all cases. 

\subsection{Rack compaction phase}
\label{sec-garbage-collection-rack-compaction-phase}

In the \emph{rack compaction phase}, header objects are scanned in
order of increasing addresses, and the corresponding racks
are compacted towards the end of the heap.

\section{Promotion}
\label{sec-garbage-collection-promotion}

Objects are typically promoted when the space recovered in the nursery
as a result of a thread-local garbage collection is deemed too small.%
\footnote{Here ``too small'' means that another garbage collection
  would be triggered very soon again, which is not desirable.}  When
this happens, The objects in a \emph{prefix} of the nursery (and the
associated racks in the suffix), as well as the transitive closure of
those objects are moved to the space managed by the global collector.
The remaining objects in the nursery are then compacted, and the
pointers are adjusted according to the size of the prefix and the
suffix.

Promotion could happen for reasons other than age.  Objects that are
too large for the nursery would be allocated directly in the global
allocator.  Objects to which references from foreign code are
about to be created would first be promoted to the global collector
where they would no longer move.  The same is true for an object that
is about to be used as key in an \texttt{eq} hash table.  Objects that
can be expected to have a significant life span (such as symbols)
might also be allocated directly in the global collector. 

\section{Synchronization between collectors}

Since each thread is responsible for collecting its own heap and since
the global collector can not run until every application thread has
run its own collector, we need to find a way of dealing with threads
that are stopped for any reason, for instance waiting for
input/output.

We think that in cases like that, one of the threads of the global
collector would run the garbage collector on behalf of the stopped
thread.  During the execution of the garbage collector, if the stopped
thread becomes unstopped, it must then be prevented from running
application code until the collection has run to completion.

We do this by introducing a variable and two semaphores for each
application thread that are shared between that thread and the global
collector threads.  The variable has 4 bit positions with the
following meaning:

\begin{itemize}
\item \texttt{application-blocked} meaning that the application thread
  might be blocked when the bit is set, and is therefore not capable
  of executing the local garbage collector.  This bit is both set and
  cleared by the application thread.
\item \texttt{gc-requested} meaning that the global collector has
  requested that the application thread run the garbage collector.
  This bit is set by the global collector and cleared by the
  application thread.
\item \texttt{gc-in-progress} meaning that the global collector is
  running the nursery garbage collector on behalf of the thread.  This
  bit is both set and cleared by the global collector.
\item \texttt{application-waiting} meaning that the application is
  waiting for the global collector to finish the garbage collection on
  behalf of the application thread.
\end{itemize}

The two semaphores work as follows:

\begin{itemize}
\item \texttt{global-gc-may-proceed}.  This semaphore is initialized to
  $0$.  When the global collector requests that an application thread
  run the local garbage collector it waits on this semaphore.  The
  application thread signals this semaphore, indicating that all
  objects in the global heap reachable from the local heap have been
  marked.
\item \texttt{application-may-execute}.  This semaphore is initialized
  to $0$.  When an application thread awakes after having been
  blocked, it checks whether the global collector is currently
  executing on behalf of this application thread.  If so, the
  application thread waits on this semaphore.  When the global
  collector has finished executing on behalf of this thread, it
  signals this semaphore, allowing the application thread to continue
  its execution.
\end{itemize}

\subsection{Running application thread}

At every safe point (function call, function return, and a branch to
an inferior address%
\footnote{To minimize the overhead in case of a very tight loop, we
  will use loop unrolling so that a branch to an inferior address will
  be less frequent}), the application thread consults the shared
variable.  If the \texttt{gc-requested} bit is set, then it clears
that bit and runs the nursery garbage collector.  At the end of the
collection, it signals the \texttt{global-gc-may-proceed} semaphore
indicating to the global collector that it has finished, and finally
continues the application thread.  No synchronization is required to
read the shared variable, because once the \texttt{gc-request} bit is
set, no other bit is going to move as the result of any action on the
part of the global collector.

\subsection{Application thread about to block}

When there is a possibility that an application thread is about to
block, for example when it is about to execute some input or output
operation,  it must inform the global collector that it might be
unable to run the local garbage collector itself, and that the global
collector may have to run it on behalf of the application thread.

The application starts by reading the shared variable into an ordinary
lexical variable.  If the \texttt{gc-request} bit is set, it clears
the bit and runs the nursery garbage collector.  At the end of the
collection, it signals the \texttt{global-gc-may-proceed} semaphore
indicating to the global collector that it has finished, and then
starts over by reading the variable again.  This action is repeated
until the \texttt{gc-request} bit is cleared.

When the \texttt{gc-request} bit is cleared, it sets the
\texttt{application-blocked} bit in a second local copy of the shared
variable.  It then performs a CAS operation to set the
\texttt{application-blocked} bit in the shared variable.  Should this
operation fail, then it means that the \texttt{gc-request} bit has
been set since the shared variable was read the first time.  The
application thread then starts the entire operation over again.

If the CAS operation succeeds. it means that the global collector has
been informed that, if it needs for this nursery heap to be garbage
collected, it has to do it on behalf of the thread.  The application
thread can now perform the operation that might block the thread.

\subsection{Application thread waking up after block}

When the application thread wakes up after having been blocked, there
is a possibility that the global garbage collector is in the process
of running the nursery collector on behalf of the application thread.
If that is the case, then the application thread must wait until the
garbage collection is finished.

The application thread starts by reading the shared variable into an
ordinary lexical variable, and it also makes a second copy.  If the
\texttt{gc-in-progress} bit is cleared, it then clears the
\texttt{application-blocked} bit in the second copy and performs a CAS
operation.  If the CAS operation succeeds, this means that the global
collector is not running on behalf of the application thread, and will
not do so because it has been informed that the application thread is
not blocked.  The application thread then returns to its normal
operation without any further action.

If the CAS operation fails, then that means that the global collector
has started a collection on behalf of the application thread since the
shared variable was read.  Then the application thread starts the
process over by reading the shared variable again.  If the
\texttt{gc-in-progress} bit is set, then the application thread clears
the \texttt{application-blocked} bit and sets the
\texttt{application-waiting} bit in the second local copy of the
shared variable.  It then performs a CAS operation.  If the CAS
operation succeeds, it means that the global collector is still
running the nursery collector on behalf of the application thread, and
that the global collector has been informed that, when the nursery
collection is finished, it should signal the
\texttt{application-may-execute} semaphore.

\subsection{Preparing for a global collection}

Before a global collection can take place, each nursery must first be
collected, and references from the nurseries to the global heap must
be marked so that the global collector will keep the referenced
objects.

For each application thread, the following actions are performed:

The contents of the shared variable is read into an ordinary lexical
variable, and a second copy of it is made.  The
\texttt{application-blocked} bit is examined

\begin{enumerate}
\item If it is cleared, then the \texttt{gc-request} bit is set in the
  second copy, and a CAS operation is attempted.
  \begin{enumerate}
  \item If the operation succeeds, then that means that the
    application thread is still not blocked and it has been properly
    informed that it is expected to run a nursery collection.  The
    \texttt{global-gc-may-proceed} semaphore for this application
    thread is added to a set of such semaphores.
  \item If the operation fails, then that means that the application
    has been blocked in the meantime.  The entire operation is then
    restarted by reading the shared variable again.
  \end{enumerate}
\item If it is set, then the application is blocked.  Then the
  \texttt{gc-in-progress} bit of the second copy is set, and a CAS
  operation is attempted.
  \begin{enumerate}
  \item If the operation succeeds, then that means that the
    application thread is still blocked, and that it has been properly
    informed that a nursery collection on its behalf is pending.  A
    new thread (or an existing one from a pool) is assigned to do a
    nursery collection on behalf of the application thread, and the
    thread is added to a set of such threads.
    \item If the operation fails, then that means that the application
      is no longer blocked.  The entire operation is then restarted by
      reading the shared variable again.
  \end{enumerate}
\end{enumerate}

When all the application threads have been processed this way, the
global garbage collector executes a \emph{wait} operation sequentially
on each semaphore in the saved set.

Then the global collector waits for each the threads in the set of
threads doing a nursery collection on behalf of an application thread
to finish.  When such a thread finishes, the shared variable is read
into an ordinary lexical variable and a second copy is made.  The
\texttt{application-waiting} bit is examined.

\begin{enumerate}
\item If it is set, the global collector clears the bit, clears the
  \texttt{gc-in-progress} bit, and executes a \emph{signal} operation
  on the \texttt{application-may-execute} semaphore.  No further
  synchronization is required.
\item  If it is cleared, then that means that the application is still
  blocked.  Then the global collector clears the
  \texttt{gc-in-progress} bit in the second copy and attempts a CAS
  operation.
  \begin{enumerate}
  \item If the CAS operation succeeds, then it means that the
    operation is still blocked, and it has been informed that it can
    safely execute application code when it wakes up.
  \item If the CAS operation fails, then application may no longer be
    blocked.  The entire operation is then restarted by reading the
    shared variable again.
  \end{enumerate}
\end{enumerate}

\section{Implementation}

In most systems, the garbage collector is implemented in some language
other than \commonlisp{}.  However, we imagine using \commonlisp{}
together with some additional low-level primitives for accessing
memory by address instead.

%%  LocalWords:  mutator
