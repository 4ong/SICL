\section{Our technique}
\label{sec-our-technique}

A \sicl{} object is represented in one of three different ways:

\begin{itemize}
\item As an \emph{immediate} object where the object is stored in the
  pointer itself, with the appropriate tag bits.  Fixnums, characters
  and single floats are represented this way.
\item As a two-word block.  This is how \texttt{cons} cells are
  represented.
\item As a two-word block where the first word points to a class
  object, and the second word points to a sequence of words, called
  the \emph{rack}, that contains the slots of the object.  All objects
  other than immediates and \texttt{cons} cells are represented this
  way.  We call this representation a \emph{general instance}. 
\end{itemize}

The first word of the rack contains a \emph{stamp} which is a unique
integer taken from the class when the instance was created.  The
stamps of the arguments to a generic function are used by the generic
dispatch technique to determine which effective method to execute.
The object representation and generic dispatch technique has been
described in detail previously
\cite{Strandh:2014:FGD:2635648.2635654}, but this short summary is
sufficient to understand out bootstrapping technique.

In the description of our technique, we use the word \emph{class} in a
general way, as an object that can be used as a model for the creation
of \emph{instances}.  Thus the word \emph{class} does not imply that
it is a class in the sense of the host \commonlisp{} implementation.

Similarly, we use the word \emph{generic function} in a general way,
as an object that can be executed and that can have methods associated
with it, providing partial implementations of the generic function.
Thus, in this sense the word \emph{generic function} is not a generic
function in the sens of the host \commonlisp{} implementation.
However, during the bootstrapping procedure, these objects are
executable in the host system, because they are instances of the host
class \emph{funcallable-standard-object}.

Our technique uses several first-class global environments
\cite{Strandh:2015:ELS:Environments} to create a graph of objects that
is isomorphic to the graph of objects to be written to the resulting
executable file.  By using first-class global environments, we avoid
the problems related to packages and environments cited in
\refSec{sec-cl-in-cl}.  The main feature of our technique, though, is
that we create the generic functions and classes of the metaobject
protocl \emph{first}.

The environments are filled with definitions mainly as a result of
loading files containing production \sicl{} code, though some code
specific to bootstrapping is required as discussed at the end of this
section.  This loading process uses the Eclector reader and the
Cleavir compiler to produce intermediate code in the form of fairly
conventional \emph{flow graph} of instructions.  The Cleavir compiler
takes a first-class global environment as an argument, and uses this
environment to search for definitions of macros etc.  The resulting
intermediate code is then translated to a simple subset of
\commonlisp{} code that accesses that same environment for definitions
of functions and other objects.  This \commonlisp{} code is then
compiled using the host compiler in order to make it executable in the
host.

In preparation for the bootstrapping procedure, several first-class
global environments are created and filled with definitions of \sicl{}
macros.  The definitions of those macros reside in production \sicl{}
files.  Little or no special code is required for those definitions.

A number of host object types are used during bootstrapping, in
particular symbols, packages, \texttt{cons} cells, and integers.
Though, when such an object is used as an argument to a \sicl{}
generic function, a special version of \texttt{class-of} assigns a
\sicl{} class object as its type.  Some of the host functions
operating on these kinds of objects are \emph{imported} to our
environments in preparation for the bootstrapping procedure.

To facilitate the description of our technique, we need some
definitions:

\begin{definition}
A \emph{simple instance} is an instance of some class, but that is
also neither a class nor a generic function.
\end{definition}

\begin{definition}
A \emph{host class} is a class in the host system.  If it is an
instance of the host class \texttt{standard-class}, then it is
typically created by the host macro \texttt{defclass}.
\end{definition}

\begin{definition}
A \emph{host instance} is an instance of a host class.  If it is an
instance of the host class \texttt{standard-object}, then it is
typically created by a call to the host function
\texttt{make-instance} using a host class or the name of a host class.
\end{definition}

\begin{definition}
A \emph{host generic function} is a generic function created by the
host macro \texttt{defgeneric}, so it is a host instance of the host
class \texttt{generic-function}.  Arguments to the discriminating
function of such a generic function are host instances.  The host
function \texttt{class-of} is called on some required arguments in
order to determine what methods to call.
\end{definition}

\begin{definition}
A \emph{host method} is a method created by the host macro
\texttt{defmethod}, so it is a host instance of the host class
\texttt{method}.  The class specializers of such a method are host
classes.
\end{definition}

\begin{definition}
A \emph{simple host instance} is a host instance that is neither a
host class nor a host generic function.
\end{definition}

\begin{definition}
An \emph{ersatz instance} is a target general instance represented as
a host data structure, using a host standard object to represent the
\emph{header} and a host simple vector to represent the \emph{rack}.
In fact, the header is an instance of the host class
\texttt{funcallable-standard-object} so that some ersatz instances can
be used as functions in the host system.
\end{definition}

\begin{definition}
An ersatz instance is said to be \emph{pure} if the class slot of the
header is also an ersatz instance.  An ersatz instance is said to be
\emph{impure} if it is not pure.  See below for more information on
impure ersatz instances.
\end{definition}

\begin{definition}
An \emph{ersatz class} is an ersatz instance that can be instantiated
to obtain another ersatz instance.
\end{definition}

\begin{definition}
An \emph{ersatz generic function} is an ersatz instance that is also a
generic function.  It is possible for an ersatz generic function be
executed in the host system because the header object is an instance
of the host class \texttt{funcallable-standard-object}.  The methods
on an ersatz generic function are ersatz methods.
\end{definition}

\begin{definition}
An \emph{ersatz method} is an ersatz instance that is also a method.
\end{definition}

\begin{definition}
A \emph{bridge class} is a representation of a target class as a
simple host instance.  An impure ersatz instance has a bridge class in
the class slot of its header.  A bridge class can be instantiated to
obtain an impure ersatz instance.
\end{definition}

\begin{definition}
A \emph{bridge generic function} is a target generic function
represented as a simple host instance, though it is an instance of the
host function \texttt{funcallable-standard-object} so it can be
executed by the host.

Arguments to a bridge generic function are ersatz instances.  The
bridge generic function uses the
\emph{stamp}
\seesec{sec-generic-function-dispatch-the-discriminating-function} of
the required arguments to dispatch on.

The methods on a bridge generic function are bridge methods.
\end{definition}

\begin{definition}
A \emph{bridge method} is a target method represented by a simple host
instance.  The class specializers of such a method are bridge classes.%
\footnote{check the truth of that statement.}
The \emph{method function} of a bridge method is an ordinary host
function.
\end{definition}

The essence of our technique consists of four phases.  In each phase
$i$, three first-class global environments are involved, $E_{i-1}$,
$E_{i}$, and $E_{i+1}$.  Before phase $i$ starts, $E_{i-1}$ contains
classes to be instantiated during phase $i$, and $E_i$ contains
generic functions that are not involved in phase $i$, but that will be
used in phase $i+1$ to operate on the instances of the classes in
$E_{i-1}$.  Some of the generic functions in $E_i$ are accessor
functions containing methods that were automatically added as a result
of the classes in $E_{i-1}$ being defined.  Others are higher-level
functions that call those accessors to accomplish tasks such as
initialization of various metaobjects, class finalization, creation of
effective methods, and creation of discriminating functions.

Phase $i$ has two main steps:

\begin{enumerate}
\item In this step, accessor generic functions are created in
  $E_{i+1}$ by loading \sicl{} production code containing
  \texttt{defgeneric} forms.  These generic functions are accessor
  functions for MOP classes.  Notice that these functions are created
  in $E_{i+1}$ rather than in $E_i$ so as to protect the existing
  functions in $E_i$ that are needed later.
\item In this step, classes are created in $E_i$ by loading \sicl{}
  production code containing \texttt{defclass} forms.  As a result of
  the creation of these classes, methods are automatically added to
  the corresponding accessor generic functions in $E_{i+1}$.
\end{enumerate}

Depending on the phase, \sicl{} production code might be loaded before
the first step, between the steps, or after the last step for the
tasks cited above.

The four phases accomplish the creation of these objects:

\begin{enumerate}
\item In this phase, host classes and host class metaclasses in $E_0$
  are used to create host generic functions in $E_2$ and host classes
  in $E_1$.
\item In this phase, host classes in $E_1$ are used to create bridge
  generic functions in $E_3$ and bridge classes in $E_2$.
\item In this phase, bridge classes in $E_2$ are used to create impure
  ersatz generic functions in $E_4$ and impure ersatz classes in
  $E_3$.
\item In this phase, impure ersatz classes in $E_3$ are used to create
  pure ersatz generic functions in $E_5$ and pure ersatz classes in
  $E_4$.
\end{enumerate}

%%  LocalWords:  accessors metaobjects accessor immediates
