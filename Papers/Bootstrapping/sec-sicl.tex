\section{The \sicl{} source code}

\sicl{} is a system that is written entirely in \commonlisp{}.  We
decided to use the full language to implement the system so as to
avoid having to define and remember what subset of the language is
allowed for which modules.  Thus, the compiler (Cleavir) makes heavy
use of generic functions and classes.  By using these tools, we can
have a compiler that is adaptable to different \commonlisp{}
implementations.  It is currently used as the main compiler of Clasp,
and recently, a Cleavir-based compiler has been written for CLISP.

In addition to using the full language for the implementation of
\sicl{}, we want the code to be as idiomatic as possible.  For
example, our definition of the class \texttt{t}, looks like this:

\begin{verbatim}
(defclass t ()
  ()
  (:metaclass built-in-class))
\end{verbatim}

This definition clearly expresses the characteristics of the class
\texttt{t}.  It has no superclasses because no superclasses are
explicitly mentioned, and the metaclass \texttt{built-in-class} does
not provide any default superclasses like \texttt{standard-class} and
\texttt{funcallable-standard-class} do.  While this definition of the
class \texttt{t} is clear, it is not operational as is.  The
metaclass \texttt{built-in-class} is an indirect subclass of the class
\texttt{t}, so the the class \texttt{t} must exist in order for the
class \texttt{built-in-class} to exist.

Our definition of the class \texttt{standard-class} looks like this:%
\footnote{In reality, there are intermediate classes between
  \texttt{class} and \texttt{standard-class} that are not shown here.}

\begin{verbatim}
(defclass standard-class (class)
  (...))
\end{verbatim}

Again, this definition is clear.  No metaclass option is given, so the
metaclass defaults to \texttt{standard-class}.  Like the defintion of
\texttt{t}, this definition is not operational as it is, because the
class \texttt{standard-class} must exist in order to be the metaclass
of itself.

In addition to using the \clos{} machinery for defining the classes
defined by the metaobject protocol, we use the same machinery for
defining system classes.  For example, our definition of the class
\texttt{symbol} looks like this:

\begin{verbatim}
(defclass symbol (t)
  ((%name :reader symbol-name)
   (%package :reader symbol-package))
  (:metaclass built-in-class))
\end{verbatim}

Not only is this definition clear, it is also operational.  By using
the \clos{} machinery for definitions of system classes, we avoid
having to use an additional, special, mechanism for this purpose.

In a \commonlisp{} implementation that must bootstrap \clos{} from a
subset of the language that does not include \clos{}, some other
mechanism must be used.  As an example of the consequences of the use
of such a subset, consider the following definitions from ECL:

\begin{verbatim}
(defparameter +specializer-slots+
  '((flag :initform nil :accessor eql-specializer-flag)
    (direct-methods :initform nil :accessor specializer-direct-methods)
    (direct-generic-functions :initform nil ...)))
\end{verbatim}

\begin{verbatim}
(defparameter +class-slots+
  `(,@+specializer-slots+
    (name :initarg :name :initform nil :accessor class-id)
    (direct-superclasses :initarg :direct-superclasses ...)
    ...))
\end{verbatim}

Here, two special variables are defined, each one containing the
specifications of the direct slots of a class.  These two definitions
express the exact same information as two \texttt{defclass} forms
defining the classes \texttt{specializer} and \texttt{class},
respectively.  However, because the \texttt{defclass} form can not be
used at this stage of the bootstrapping process, a different mechanism
must be used.
