\documentclass{beamer}
\usepackage[latin1]{inputenc}
\beamertemplateshadingbackground{red!10}{blue!10}
%\usepackage{fancybox}
\usepackage{epsfig}
\usepackage{verbatim}
\usepackage{url}
%\usepackage{graphics}
%\usepackage{xcolor}
\usepackage{fancybox}
\usepackage{moreverb}
%\usepackage[all]{xy}
\usepackage{listings}
\usepackage{filecontents}
\usepackage{graphicx}

\lstset{
  language=Lisp,
  basicstyle=\scriptsize\ttfamily,
  keywordstyle={},
  commentstyle={},
  stringstyle={}}

\def\inputfig#1{\input #1}
\def\inputeps#1{\includegraphics{#1}}
\def\inputtex#1{\input #1}

\inputtex{logos.tex}

%\definecolor{ORANGE}{named}{Orange}

\definecolor{GREEN}{rgb}{0,0.8,0}
\definecolor{YELLOW}{rgb}{1,1,0}
\definecolor{ORANGE}{rgb}{1,0.647,0}
\definecolor{PURPLE}{rgb}{0.627,0.126,0.941}
\definecolor{PURPLE}{named}{purple}
\definecolor{PINK}{rgb}{1,0.412,0.706}
\definecolor{WHEAT}{rgb}{1,0.8,0.6}
\definecolor{BLUE}{rgb}{0,0,1}
\definecolor{GRAY}{named}{gray}
\definecolor{CYAN}{named}{cyan}

\newcommand{\orchid}[1]{\textcolor{Orchid}{#1}}
\newcommand{\defun}[1]{\orchid{#1}}

\newcommand{\BROWN}[1]{\textcolor{BROWN}{#1}}
\newcommand{\RED}[1]{\textcolor{red}{#1}}
\newcommand{\YELLOW}[1]{\textcolor{YELLOW}{#1}}
\newcommand{\PINK}[1]{\textcolor{PINK}{#1}}
\newcommand{\WHEAT}[1]{\textcolor{wheat}{#1}}
\newcommand{\GREEN}[1]{\textcolor{GREEN}{#1}}
\newcommand{\PURPLE}[1]{\textcolor{PURPLE}{#1}}
\newcommand{\BLACK}[1]{\textcolor{black}{#1}}
\newcommand{\WHITE}[1]{\textcolor{WHITE}{#1}}
\newcommand{\MAGENTA}[1]{\textcolor{MAGENTA}{#1}}
\newcommand{\ORANGE}[1]{\textcolor{ORANGE}{#1}}
\newcommand{\BLUE}[1]{\textcolor{BLUE}{#1}}
\newcommand{\GRAY}[1]{\textcolor{gray}{#1}}
\newcommand{\CYAN}[1]{\textcolor{cyan }{#1}}

\newcommand{\reference}[2]{\textcolor{PINK}{[#1~#2]}}
%\newcommand{\vect}[1]{\stackrel{\rightarrow}{#1}}

% Use some nice templates
\beamertemplatetransparentcovereddynamic

\newcommand{\A}{{\mathbb A}}
\newcommand{\degr}{\mathrm{deg}}

\title{Bootstrapping \commonlisp{} on \commonlisp{}}

\author{Irène Durand\\Robert Strandh}
\institute{
LaBRI, University of Bordeaux
}
\date{April, 2019}

%\inputtex{macros.tex}


\begin{document}
\frame{
\resizebox{3cm}{!}{\includegraphics{Logobx.pdf}}
\hfill
\resizebox{1.5cm}{!}{\includegraphics{labri-logo.pdf}}
\titlepage
\vfill
\small{European Lisp Symposium, Genoa, Italy \hfill ELS2019}
}

\setbeamertemplate{footline}{
\vspace{-1em}
\hspace*{1ex}{~} \GRAY{\insertframenumber/\inserttotalframenumber}
}

\frame{
\frametitle{Context: The \sicl{} project}

https://github.com/robert-strandh/SICL

Several objectives:

\begin{itemize}
\item Create high-quality \emph{modules} for implementors of
  \commonlisp{} systems.
\item Improve existing techniques with respect to algorithms and data
  structures where possible.
\item Improve readability and maintainability of code.
\item Improve documentation.
\item Ultimately, create a new implementation based on these modules.
\end{itemize}
}


\frame{
\frametitle{How \commonlisp{} systems are built}

Two main categories of systems:

\begin{enumerate}
\item Systems written mainly in a language other than \commonlisp{},
  typically C or C++.
\item Systems written mainly in \commonlisp{}.
\end{enumerate}

According to Rhodes (SBCL: A Sanely-Bootstrappable Common Lisp):

\begin{enumerate}
\item GCL, ECL, CLISP, ABCL (Java), xcl.
\item Allegro, LispWorks, CMUCL, Scieneer CL, CCL, SBCL.
\end{enumerate}


}

\frame{
\frametitle{How \commonlisp{} systems are built}

Of the systems mainly written in \commonlisp{} there are two ways of
making them evolve:

\begin{enumerate}
\item Image-based techniques, i.e., the system evolves by careful
  evolution of an in-memory image, that is then saved to secondary
  memory to become a new executable.
\item The system is built from a set of source files, using an
  existing \commonlisp{} implementation to create an executable for
  the new system.
\end{enumerate}

Again, according to Rhodes, only SBCL uses the second technique,
though CCL is also built from source, even though at the moment, only
an old CCL version can be used for the bootstrapping process.

}

\frame{
\frametitle{Complications with building Common Lisp systems}

Question: Is the build process for creating a \commonlisp{} system
intrinsically harder than the build process for creating a mere
file-translating compiler, even for a language as complex as
\commonlisp{}, and if so, why?

}

\frame{
\frametitle{Complications with building Common Lisp systems}

Possible answer: We think that it is, and we think that it is due to
the following difference between the two:

\begin{itemize}
\item A file-translating compiler contains essentially only code.
  That code translates statements and expressions of a source language
  to object code in assembler or machine language.
\item A \commonlisp{} system, on the other hand, contains not only
  code, but also complex data structures.  The most practical way of
  creating those data structures is by executing some code.
\end{itemize}

Imagine, for instance, writing the C source statements that will
generate a single generic function with its methods, effective method
functions, etc.

}

\frame{
\frametitle{Strategies for creating the data structures}

There are several possible strategies for creating these data
structures:

\begin{enumerate}
\item Create them when the system starts.  This strategy is used by
  ECL and Clasp.
\item Create them in an executing subset \commonlisp{} system, and
  then save the memory image to a file.  This strategy is used by the
  image-based implementations, but also by SBCL.
\item In a host \commonlisp{} system, create an octet vector that
  holds a mirror of the contents of the target system.  This strategy
  is used by SBCL to create an initial ``core'' image.
\item In a host \commonlisp{} system, create a graph of objects that
  is isomorphic to the one in the target system, then save that graph
  to a file.  This is the strategy used by SICL.
\end{enumerate}
}

\frame[containsverbatim]{
\frametitle{Objectives of SICL}

We want the code to look ``natural''.  For example:

\begin{verbatim}
(defclass class (specializer)
  ((%name :initform nil :initarg :name ...)
   ...
   (%direct-subclasses :initform '() ...)))
\end{verbatim}

\begin{verbatim}
(defclass standard-class (class)
  (...))
\end{verbatim}


}

\frame[containsverbatim]{
\frametitle{Objectives of SICL}

This is how the same information is expressed in ECL:

\begin{verbatim}
(defparameter +class-slots+
  `(,@+specializer-slots+
    (name :initarg :name :initform nil ...)
    ...
    (direct-subclasses :initform nil ...)
    ...))
\end{verbatim}

\begin{verbatim}
(defparameter +standard-class-slots+
  (append +class-slots+
          '((optimize-slot-access)
            (forward))))
\end{verbatim}

}

\frame[containsverbatim]{
\frametitle{Objectives of SICL}

In SICL, we take advantage of the CLOS machinery for defining system
classes as well as standard classes:

\begin{verbatim}
(defclass symbol (t)
  ((%name :reader symbol-name)
   (%package :reader symbol-package))
  (:metaclass built-in-class))
\end{verbatim}

}

\frame[containsverbatim]{
\frametitle{Objectives of SICL}

This is how the same information is expressed in SBCL:

\begin{verbatim}
(define-primitive-object
    (symbol :lowtag other-pointer-lowtag
            :widetag symbol-header-widetag
            :alloc-trans %make-symbol
            :type symbol)
  ...
  (name :ref-trans symbol-name :init :arg)
  (package :ref-trans symbol-package
           :set-trans %set-symbol-package
           :init :null)
  ...)
\end{verbatim}

}

\frame[containsverbatim]{
\frametitle{Objectives of SICL}

In fact, we can even write this definition in SICL:

\begin{verbatim}
(defclass t ()
  ()
  (:metaclass built-in-class))
\end{verbatim}


}

\frame{
  \frametitle{SICL object representation}

  SICL has the following three ways of representing objects:

  \begin{enumerate}
  \item Immediate objects stored in the pointer itself, appropriately
    tagged, like fixnums and characters.
  \item CONS cells represented as a pair of words.
  \item All other objects represented as a two-word \emph{header}
    containing a pointer to the class, and a pointer to the
    \emph{rack} which has some number of consecutive words.
  \end{enumerate}

\begin{figure}
\begin{center}
\inputfig{sicl-object.pdf_t}
\end{center}
\end{figure}

}

\frame{
  \frametitle{First-class global environments}

In \sicl{}, the global environment is a first-class object,
containing the following mappings:

\begin{itemize}
\item From names to variables, including information
  about type, global value, etc.
\item From names to functions, including information about
  type, compiler macros, inline information, etc.
\item From names to classes.
\item From names to \texttt{setf} expanders.
\item From names to type expanders.
\item From names to method combinations.
\item etc.
\end{itemize}

Having environments be first-class objects, allows us to have several
simultaneous instance.
}

\frame{
  \frametitle{First-class global environments}

The Cleavir compiler processes top-level forms relative to the
information provided in a first-class global environment, passed to it
as an argument.

}

\frame{
\frametitle{Previous work}


}

\frame[containsverbatim]{
\frametitle{Definition of the class \texttt{t}}

\begin{verbatim}
(defclass t ()
  ()
  (:metaclass built-in-class))
\end{verbatim}

}

\frame{
\frametitle{Future work}


}

\frame{
  \frametitle{Acknowledgments}

}

\frame{
\frametitle{Thank you}

Questions?
}

%% \frame{\tableofcontents}
%% \bibliography{references}
%% \bibliographystyle{alpha}

\end{document}
