\section{Our technique}

\subsection{Basic technique}

To illustrate our technique, we first show a very simple version of it
in the form of the following code:

{\small\begin{verbatim}
(defun find-from-end (x list)
  (labels ((aux (x list n)
             (if (= n 1)
                 (when (eq x (car list))
                   (return-from find-from-end x))
                 (let* ((n/2 (ash n -1))
                        (half (nthcdr n/2 list)))
                   (aux x half (- n n/2))
                   (aux x list n/2)))))
    (aux x list (length list))))))
\end{verbatim}}

This function starts by computing the length of the list and then
calling the auxiliary function with the original arguments and the
length.  The auxiliary function calls \texttt{nthcdr} in order to get
a reference to about half the list it was passed.  Then it makes two
recursive calls, first with the second half of the list and then with
the firs half of the list.  The recursion terminates when the list has
a single element in it.  Then this element is compared to the argument
\texttt{x} and if they are the same,%
\footnote{We use \texttt{eq} for the comparison here, because the
  exact nature of the test is unimportant for illustrating our general
  technique.}
then the element is returned form the function.

The main feature of our technique is that it trades fewer recursive
calls for multiple traversals of the list.  The maximum number% of
simultaneous active invocations of this simple function is around
$\mathsf{lb}\thinspace n$, where $n$ is the length of the list.  The
maximum value of this number is quite modest.  On a 64-bit processor,
it can never exceed $60$ and it is significantly smaller in practice
of course.  The number of times this function computes the
\texttt{cdr} of a list depends on where in the list the item to be
found is located.  If it is the \emph{last} element of the list (best
case), each \texttt{cons} cell is processed twice; once to compute the
length of the list, and once again as part of the recursive traversal.
When the item to be found is the \emph{first} element of the list
(worst case), the number of \texttt{cdr} operations can be
approximately expressed as $n\thinspace (1 +
\frac{1}{2}\mathsf{lb}\thinspace n)$.

The best case for this function is very efficient indeed.%
\FIXME{Add a table comparing execution times}
The worst case is unacceptably slow.  Even for a list of some
reasonable length such as a million elements, the execution time is a
factor $20$ slower than for the best case.

The remainder of this section is dedicated to ways of improving on the
worst-case performance of the basic technique.

\subsection{Using more stack space}

By far the most important improvement to the basic technique is to
take advantage of the available stack space to decrease the number of
multiple list traversals required by the basic technique.

{\small\begin{verbatim}
(defun find-2 (x list)
  (labels ((recursive (x list n)
             (if (zerop n)
                 nil
                 (progn (recursive x (cdr list) (1- n))
                        (when (eq x (car list))
                          (return-from find-2 x))))))
    (labels ((aux (x list n)
               (if (< n 10000)
                   (recursive x list n)
                   (let* ((n/2 (ash n -1))
                          (half (nthcdr n/2 list)))
                     (aux x half (- n n/2))
                     (aux x list n/2)))))
      (aux x list (length list)))))
\end{verbatim}}

\subsection{Other improvements}

Excluding the initial traversal of the list in order to compute the
length, the number of \texttt{cdr} operations of the basic technique
can be expressed with this recursive equation:%
\FIXME{Add the base case.}

$$f(n) = \left\lfloor\frac{n}{2}\right\rfloor
+ f(\left\lfloor\frac{n}{2}\right\rfloor)4.
+ f(\left\lceil\frac{n}{2}\right\rceil)$$
