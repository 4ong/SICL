;; divide by a constant *k* = 2^*log* 2^4 = 16 works best

(defvar *log*)
(defvar *k*)
(setq *log* 4 *k* (ash 2 *log*))

(defun count-from-end-with-length-3 (x list length)
  (declare (type fixnum length) (optimize (speed 3) (compilation-speed 0)))
  (let ((count 0))
    (declare (type fixnum count))
    (flet ((process (elem)
	     (when (eql elem x)
	       (incf count))))
      (labels ((recursive-traverse (rest length)
		 (declare (type fixnum length))
		 (when (> length 0)
		     (recursive-traverse (cdr rest) (1- length))
		     (process (car rest))))
	       (traverse (rest length)
		 (declare (type fixnum length))
;;		 (print (list 'traverse (length rest) length))
		 (cond  ((< length 16384) (recursive-traverse rest length))
			(t ;; divide
			 (let* ((f (ash length (- *log*)))
				(r0 rest) (r1 (nthcdr f r0)) (r2 (nthcdr f r1)) (r3 (nthcdr f r2)) 
				(r4 (nthcdr f r3)) (r5 (nthcdr f r4)) (r6 (nthcdr f r5)) (r7 (nthcdr f r6))
				(r8 (nthcdr f r7)) (r9 (nthcdr f r8)) (r10 (nthcdr f r9)) (r11 (nthcdr f r10))
				(r12 (nthcdr f r11)) (r13 (nthcdr f r12)) (r14 (nthcdr f r13)) (r15 (nthcdr f r14)))
			   (traverse (nthcdr f r15) (- length (ash f *k*)))
			   (traverse r15 f) (traverse r14 f) (traverse r13 f) (traverse r12 f) (traverse r11 f)
			   (traverse r10 f) (traverse r9 f) (traverse r8 f) (traverse r7 f) (traverse r6 f)
			   (traverse r5 f) (traverse r4 f) (traverse r3 f) (traverse r2 f) (traverse r1 f)
			   (traverse rest f))))))
	       (traverse list length)
	       count))))

(defun count-from-end-with-length-3-macro (x list length)
  (declare (type fixnum length) (optimize (speed 3) (compilation-speed 0)))
  (let ((count 0))
    (declare (type fixnum count))
    (flet ((process (elem)
	     (when (eql elem x)
	       (incf count))))
      (macrolet ((divide (rest length)
		   (let* ((n (ash 1 *log*))
			  (gensyms (loop repeat n collect (gensym)))
			  (f (gensym)))
		     `(let ((,f (ash length (- ,*log*)))
			    (,(car gensyms) ,rest))
			(let* ,(loop
				 for gensym1 in gensyms
				 for gensym2 in (cdr gensyms)
				 collect `(,gensym2 (nthcdr ,f ,gensym1)))
			  (traverse
			   (nthcdr ,f ,(car (last gensyms)))
			   (- ,length (ash ,f ,*log*)))
			  ,@(loop
			      for gensym in (reverse gensyms)
			      collect `(traverse ,gensym ,f)))))))
	(labels ((recursive-traverse (rest length)
		   (declare (type fixnum length))
		   (when (> length 0)
		     (recursive-traverse (cdr rest) (1- length))
		     (process (car rest))))
		 (traverse (rest length)
		   (declare (type fixnum length))
		   ;;		 (print (list 'traverse (length rest) length))
		   (cond  ((< length *k*) (recursive-traverse rest length))
			  (t (divide rest length)))))
	  (traverse list length)
	  count)))))

(defun reverse-count-3 (x list)
  (count-from-end-with-length-3 x list (length list)))

(defun reverse-count-3-macro (x list)
  (count-from-end-with-length-3-macro x list (length list)))
