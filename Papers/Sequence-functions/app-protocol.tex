\appendix

\section{Protocol}

In this appendix, we describe the macros and functions that are part
of the protocol of our technique, used for implementing most of the
sequence functions.

\Defun {apply-key-function} {element key-function}

This function takes an element of the sequence and a function to apply
in order to obtain the object to use for comparison.  For performance
reasons, this function should be inlined.

A typical definition of this function might look like this:

{\small\begin{verbatim}
(defun apply-key-function (element key-function)
  (declare (optimize (speed 3) (debug 0) (safety 3)))
  (declare (type function key-function))
  (cond ((eq key-function #'identity)
	 element)
	((eq key-function #'car)
	 (car element))
	((eq key-function #'cdr)
	 (cdr element))
	(t
	 (funcall key-function element))))
\end{verbatim}}

\Defmacro {canonicalize-key} {key-var}

This macro takes a single argument which must be a variable that holds
the value of the \texttt{\&key} keyword argument.  Its role is to make
sure the contents of the variable is a function.  A typical
implementation might look like this:

{\small\begin{verbatim}
(defmacro canonicalize-key (key-var)
  `(cond ((null ,key-var)
	  (setf ,key-var #'identity))
	 ((not (functionp ,key-var))
	  (setf ,key-var (fdefinition ,key-var)))
	 (t nil)))
\end{verbatim}}

\Defmacro {for-each-relevant-cons}\\
{(cons-var index-var list start end from-end) \body body}

This macro executes \textit{body} for each \emph{relevant
  \texttt{cons} cell}.  It takes into account the values of
\textit{start} and \textit{end} to restrict the execution to a
particular sub-sequence, and it takes into account the value of
\textit{from-end} to determine the order in which the relevant
\texttt{cons} cells are supplied to the \textit{body} code.  The
parameter \textit{cons-var} is the name of a variable that contains a
reference to the relevant \texttt{cons} cell for each execution of
\textit{body}.  Similarly, the parameter \textit{index-var} is the
name of a variable that contains the index of the particular
\texttt{cons} cell to be processed.

Because of the size of the definition of this macro, due mainly to the
code for processing \texttt{cons} cells in reverse order
\cite{Durand:2015:ELS:reverse}, we do not show its definition here.

\Defmacro {with-test-and-test-not}\\
{(test-var test-not-var) \body body}

The role of this macro is to supply certain special cases for the
possible values of the keyword parameters \texttt{test} and
\texttt{test-not} of a typical sequence function.  It is assumed that
it has already been verified that at most one of the two keyword
arguments has a value other than \texttt{nil}.  A typical
implementation might look like this:

{\small\begin{verbatim}
(defmacro with-test-and-test-not
    ((test-var test-not-var) &body body)
  `(cond ((null ,test-not-var)
	  (locally (declare (type function ,test-var))
	    (cond ((eq ,test-var #'eq)
		   ,@body)
		  ((eq ,test-var #'eql)
		   ,@body)
		  (t
		   ,@body))))
	 ((null ,test-var)
	  (locally (declare (type function ,test-not-var))
	    (cond ((eq ,test-not-var #'eq)
		   ,@body)
		  ((eq ,test-not-var #'eql)
		   ,@body)
		  (t
		   ,@body))))
	 (t nil)))
\end{verbatim}}
