\section{Benefits of our method}
 
\subsection{Cross compilation}

\subsection{Native compilation}

The \commonlisp{} standards suggests that the \emph{startup
  environment} and the \emph{evaluation environment} may be
different.%
\footnote{Recall that the startup environment is the global
environment as it was when the compilation was initiated, and that the
evaluation environment is the global environment in which evaluations
initiated by the compiler are accomplished.}
Our method allows most evaluations by the compiler to have no
influence in the startup environment.  It suffices to \emph{clone} the
startup environment in order to obtains the evaluation environment. 

With the method described in the previous section, some evaluations
by the compiler would have side effects in the startup environment.
In particular, the value cells and function cells are shared.
Therefore, executing code at compile time that alters the global
binding of a function or a variable will also be seen in the startup
environment.  

\subsection{Bootstrapping}

When a \emph{host} \commonlisp{} system is used to bootstrap a
\emph{target} \commonlisp{} system, the target system needs its own
definitions of many standard \commonlisp{} features.  In particular,
in order to compile code for the target system in the host system, the
cross compiler needs access to the target definitions of standard
\commonlisp{} macros.

It is, of course, not an option to replace the host versions of such
macros with the corresponding target versions.  Doing so would almost
certainly break the host system in irreparable ways.  For that reason,
many \commonlisp{} systems have a feature called \emph{package locks}%
\footnote{The name of this feature is misleading.  While it does make
  sure that the protected package is not modified, it also makes sure
  that functions, macros, etc., with names in the package are not
  redefined.  Such modifications do not alter the package itself, of
  course.}
which prevents the redefinition of standard \commonlisp{} functions,
macros, etc.

To deal with the problem of bootstrapping, some systems (in particular
SBCL)%
\FIXME{Cite Rhodes paper}
replace the standard package names by some other names for target
code, typically derived from the standard names in some systematic
way.  Using different package names guarantees that there is no clash
between a host package name and the corresponding target package
name.  However, using non-standard package names also means that the
text of the source code for the target will differ from the target
code that ends up in the final system.

As an alternative to renaming packages, first-class global
environments represent an elegant solution to the bootstrapping
problem.  In a system that already supports first-class global
environments, creating a new such environment in which the target
definitions are allowed to replace standard \commonlisp{} definitions
is of course very simple.  But even in a host system that do not a
priori support first-class global environments, it is not very
difficult to create such environments.

Making the cross compiler access such a first-class global environment
is just a matter of structuring its environment-lookup functions so
that they do not directly use standard \commonlisp{} functions such as
\texttt{fboundp} or \texttt{fdefinition}, and instead use the generic
functions of the first-class global environment protocol.

\subsection{Sanboxing}

It is notoriously hard to create a so-called \emph{sandbox
  environment} for \commonlisp{}, i.e., an environment that contains
a subset of the full languages.  A typical use case would be to
propose a Read-Eval-Print Loop accessible through a web interface for
educational purposes.  Such a sandbox environment is hard to achieve
because functions such as \texttt{eval} and \texttt{compile} would
have to be removed so that the environment could not be destroyed by a
careless user.  However, these functions are typically used by parts
of the system.  For example, \clos{} might need the compiler in order
to generate dispatch code.

The root of the problem is that in \commonlisp{} there is always a way
for the user of a Read-Eval-Print Loop to access every global function
in the system, including the compiler.

Using first-class global environments solves this problem in an
elegant way.  It suffices to propose a restricted environment in which
there is no binding from the names \texttt{eval} and \texttt{compile}
to the corresponding functions.  These functions can still be
available in some other environment for use by the system itself.

%%  LocalWords:  Sanboxing startup
