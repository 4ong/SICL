\section{Our technique}

The technique described in this paper was developed as part of
\sicl{}.%
\footnote{The \sicl{} repository is public, and it is currently
  located at https://github.com/robert-strandh/SICL.}  The system is
written entirely in \cl{} and it was designed to be bootstrapped 
from a conforming \cl{} implementation including \clos{}.  

A generic function in \sicl{} contains a \emph{cache} (a \emph{call
  history} in \sicl{} terminology) which associates classes of
required arguments with corresponding effective methods, and
specifically allowed by the AMOP.  The discriminating function of
every standard generic function contains two parts: one part computed
from the call history and a second \emph{default} part, invoked when
the first part fails.  This second part of the discriminating function
invokes the complete machinery defined by
\texttt{compute-applicable-methods-using-classes},
\texttt{compute-applicable-methods}, and
\texttt{compute-effective-method}.

Metastability issues can be handled automatically, provided that:

\begin{itemize}
\item The call history contains entries for every combination of
  classes of required arguments such that:
  \begin{enumerate}
  \item the classes are specified by the AMOP, and 
  \item there is at least one primary applicable method for the
    combination.
  \end{enumerate}
\item When the class hierarchy changes, an entry in the call history
  is removed only if it involves a modified class.
\item When a method is removed a generic function (possibly because it
  was replaced with a new one with the same specializers), an entry in
  the call history is removed only if it involves the method that was
  removed.
\end{itemize}

The reason that the these conditions automatically handle
metastability issues is that the AMOP specifically disallows
modifications to specified classes.  Then the first part of the
discriminating function (i.e., the part computed from the call
history) will always handle invocations where classes of required
arguments are specified classes, including the function
\texttt{compute-discriminating-function}. 

Our technique, called \emph{satiation} makes sure that that the
conditions are met by trying every combination of existing classes as
the required arguments of every existing generic function in order to
see whether this combination corresponds to an applicable primary
method of the generic function.  If that is the case, then a
corresponding effective method is computed, and an entry is added to
the call history.  Finally, the resulting discriminating function is
computed.  Clearly, these computations require a fully-functional
machinery for precisely the functions that are being processed. 

Now, in a system where \clos{} must be bootstrapped from a pre-\clos{}
implementation, satiation would require specialized code in the form
of ordinary functions (as opposed to generic functions) that do the
same work as the specified generic functions on arguments that are
instances of specified classes, with much duplicated code as a result.

In \sicl{}, we bootstrap \clos{} on an existing conforming \cl{}
implementation (the host) as follows:

\begin{enumerate}
\item First we use the definitions of the MOP classes to create
  ordinary host classes, albeit with names in a separate package.
  Slots with associated accessors will generate ordinary host generic
  functions. 
\item Next, we create \emph{bridge classes} and \emph{bridge generic
  functions}.  A bridge class is a host instance of one of the host
  classes created in phase 1.  A bridge generic function is an
  instance of the host class \texttt{standard-generic-function}
  created in phase 1, but also of the host class named
  \texttt{funcallable-standard-object}.
\item Third, we use bridge classes and bridge generic functions to
  create \emph{ersatz classes} and \emph{ersatz generic functions}.
  These are target instances represented as a combination of a host
  \emph{structure} for the header, and a host \emph{simple vector} for
  the rack. 
\item Finally, we traverse the graph of ersatz instances in order to
  create an isomorphic graph as sequence of bytes to become the memory
  image of the target system.
\end{enumerate}

%%  LocalWords:  metastability specializer specializers accessor
%%  LocalWords:  accessors funcallable
