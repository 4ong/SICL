\section{Previous work}

\subsection{\pcl{}}
\label{sec-pcl}

Portable Common Loops, \pcl{} for short, is a library that implements
the functions defined in the book ``The Art of the Metaobject
Protocol'' \cite{Kiczales:1991:AMP:574212}, and is meant as an add-on
to pre-standard \commonlisp{} implementations, i.e., implementations
without \clos{}.

Most \commonlisp{} implementations that exist today were initially
written before the standard was published, and many of those
implementations chose to use \pcl{} to incorporate \clos{}
functionality, though frequently, the code has since been adapted for
each specific implementation.  Much of the analysis in this section
was also described in \cite{verna.18.els}, although the description in
that paper refers to the way \sbcl{} handled method combinations at
the time that article was written.

\pcl{} unsurprisingly defines the class \texttt{method\--combination}
and then the class \texttt{standard\--method\--combination} as a
subclass of the class named \texttt{method\--combination}.

More surprisingly, it then defines two subclasses of the class
\texttt{standard\--method\--combination}, namely
\texttt{long\--method\-combination} and
\texttt{short\--method\--combination}, each for use with the different
forms (long and short) of the macro
\texttt{define\-method\--combination}.

The class \texttt{short-method-combination} contains slots for the for
the method-combination type (i.e. a symbol), and the
method-combination options.

The class \texttt{short-method-combination} adds two more slots,
namely the operator and a Boolean that indicates whether the operator
is the identify function when given a single argument.

The short form of \texttt{define-method-combination} adds a method to
the generic function \texttt{find-method-combination}.  The second
parameter of this method has an \texttt{eql} specializer with the name
of the method-combination type being defined.  The method function of
this method first checks that the options given are valid for the
short form of \texttt{define-method\-combination}, and then it creates
a fresh instance of the class \texttt{short-method-combination}.  In
other words, a fresh method combination is created whenever
\texttt{find-method-combination} is called, which is typically
whenever a generic function is created.  As a result, with a
method-combination type defined by the short form, the method
combination of a generic function using this type is not updated as a
result of redefining that method-combination type.

Furthermore, \texttt{compute-effective-method} has a method
specialized to the class \texttt{short-method-combination} that
handles the case of the short method combination as a special case.

The long form of \texttt{define-method-combination} turns the body of
the for into a method-combination \emph{function}.  This function has
the same lambda list as \texttt{compute-effective\-method}.  The
expansion of the macro stores this function in a global hash table,
using the method-combination type as a key.  There is a slot for this
function in the class \texttt{long-method\-combination}, but this slot
is not used.

Like the short form, the long form also creates a method on
\texttt{find-method-combination}, also with an \texttt{eql}
specializer for the second parameter. This method simply creates an
instance of the class \texttt{long-method-combination}.  The generic
function \texttt{compute-effective-method} has a method specialized to
the class \texttt{long-method-combination}.  This method consults the
hash table to find the method-combination function and applies that
function to the generic function, the method combination, and the
applicable methods.

Appendix B of \cite{verna.18.els} shows some very strange consequences
of the use of the global hash table, combined with the fact that the
effective-method cache is not flushed when the method-combination type
is redefined using the long form.  A generic function may well end up
with some effective methods computed \emph{before} the redefinition
and some  computed \emph{after} it.  Needless to say, this behavior is
very undesirable.

In summary then, the generic function named \texttt{find-method\-combination}
acts as a container for method-combination types, encoded as
\texttt{eql}-specialized methods.  Furthermore, there is no attempt to
reuse existing method combinations.  A new one is created whenever
\texttt{find-method-combination} is called.  Finally, while the
validity of the options is verified for the built-in method
combination types, no such verification is made for custom
method-combination types defined by the long form of
\texttt{define-method-combination}.

\subsection{\sbcl{}}

The \sbcl{} \commonlisp{} implementation uses a heavily modified
version of \pcl{} (See \refSec{sec-pcl}).  Prior to April of 2018,
\sbcl{} used the unmodified technique from \pcl{} as described in
\refsec{sec-pcl}.  The technique described in this section is a result
of significant modifications to the code for handling method
combinations.  An article by Didier Verna \cite{verna.18.els}
published at ELS in April of 2018 contained a detailed description of
the technique used by \sbcl{} at that time.  Perhaps the improvements
to \sbcl{} were a result of the descriptions in this article.

One aspect of the \sbcl{} code that remains from the previous version
is that the two subclasses of \texttt{method-combination} are still
present.

An invocation of \texttt{define-method-combination} does not create
any new class.  Instead, an \emph{info} structure is created, and
stored in a hash table that uses the name of the method-combination
type as a key.  This info structure contains a \emph{cache}, which is
an association list.  The key of an element of the association list is
a list of options for the method combination, and the value of an
element is the method-combination object.  Initially, the cache is
empty, except for the info structure associated with the
\texttt{standard} method combination.

The function \texttt{find-method-combination} is given the
method-combination name and the desired options.  It looks up the
appropriate info structure, and searches the cache for an element
corresponding to the options.  If such an element is found, the
method-combination object is returned.  If no element is found, a new
one is constructed, pushed on the cache, and returned.  The new
element is constructed by consing the list of options and the result
of applying a \emph{constructor function} to the list of options.
This constructor function is stored in a slot in the info structure.
As a result, existing method-combination instances are reused whenever
possible.  However, the reuse is not perfect.  Consider the following
definition of a method combination:

{\small\begin{verbatim}
(define-method-combination my-and
    (&key (order :most-specific-first)
          (exclude-around :t))
  ((around (:around))
   (primary (and) :order order :required t))
  (let ((form `(and ,@(mapcar
                        #'(lambda (method)
                            `(call-method ,method))
                        primary))))
    (if (and around (not exclude-around))
        `(call-method ,(first around)
                      (,@(rest around)
                       (make-method ,form)))
                 form)))
\end{verbatim}}

It differs from from the built-in \texttt{and} method combination type
in that it has two options, and that those options are defined as
keyword parameters rather than optional parameters.

Now, if we define the following two generic functions using this
method combination:

{\small\begin{verbatim}
(defgeneric ff (x)
  (:method-combination my-and
      :order :most-specific-first
      :exclude-around nil))

(defgeneric gg (x)
  (:method-combination my-and
      :exclude-around nil
      :order :most-specific-first))
\end{verbatim}}

\noindent
then these two functions do not have the same method combination, as
the following experiment shows:

{\small\begin{verbatim}
(eq (sb-mop:generic-function-method-combination #'ff)
    (sb-mop:generic-function-method-combination #'gg))
=> NIL
\end{verbatim}}

The reason for the two being different is that the method combination
is identified by the ordered list of options, and the lists are
different for the different \texttt{defgeneric} forms.

When a generic function is defined with one of the built-in method
combinations, \sbcl{} will check that the options given to the
\texttt{:method-combination} \texttt{defgeneric} option are valid.
This verification is done by special-purpose code.  However, with a
user-defined method combination, no verification is made.  It is only
when an attempt is made to invoke the generic function that the
function resulting from the custom method combination is invoked, and
the incompatible lambda lists are detected.  Furthermore, the error
message is very general and can be difficult to decipher by the
programmer.

\sbcl{} handles re-evaluation of \texttt{define-method-combination}
forms with the name of an existing info entry in the hash table.
Every method-combination instance contains a list of back pointers to
generic functions that use this method combination.  The cache of the
existing info entry is traversed, and for each method combination, the
effective methods of its generic functions are invalidated.

\subsection{\clcl{}}
\label{sec-ccl}

The \clcl{} implementation (\ccl{} for short) defines the class
\texttt{method-combination} and then tree subclasses of that class:

\begin{itemize}
\item \texttt{standard-method-combination} with a single instance,
  namely the standard method combination.  This class is used as a
  specializer in a method on the generic function
  \texttt{compute-effective-method} so as to handle the standard
  method combination as a special case.
\item \texttt{short-method-combination} which is used for method
  combinations defined by the short form of the macro
  \texttt{define-method-combination}.
\item \texttt{long-method-combination} which is used for method
  combinations defined by the long form of the macro
  \texttt{define-method-combination}.
\end{itemize}

The class \texttt{standard-method-combination} in \ccl{} thus does not
play the role as a general instantiable subclass of
\texttt{method-combination}.

In \ccl{}, the macro \texttt{define-method-combination} does not
define a method combination, nor a new method-combination class.
Instead it defines an \emph{info} vector (disguised as a structure)
that acts as a template for creating method combinations later.  The
info vector contains the following elements:

\begin{itemize}
\item The name of the method-combination class to be created which is
  either \texttt{short-method-combination} or
  \texttt{long-method-combination}.
\item An element that contains the short-form options if the info
  vector was created as a result of the short form of
  \texttt{define-method-combination}, and an \emph{expander function}
  if the info vector was created as a result of the long form.
\item A list of \emph{instances}, i.e. method-combination objects that
  share the same info vector.
\item A list of generic functions using method combinations of the
  type defined by the info vector.
\end{itemize}


\subsection{\ecl{}}
\label{sec-ecl}

The \ecl{} \commonlisp{} implementation defines the class
\texttt{method-combination}, and method-combination metaobjects are
direct instances of this class, which is not conforming.

The macro \texttt{define-method-combination} does not define a method
combination, nor a new method-combination class.  Instead it defines a
function that we will call the \emph{method-combination function}.
This function computes the effective method of a generic function.
The lambda list of the method-combination function consists of two
required parameters, namely a generic function and a list of
applicable methods, followed by the lambda list given to
\texttt{define-method-combination}.  That lambda list will contain
\texttt{\&optional (order :most-specific-first)} for most built-in
method-combination types.  The resulting function is stored in a hash
table with the name of the method-combination type as a key.

When a generic function is created, a new instance of the
\texttt{method-combination} class is created.  The new instance
contains the method-combination function and a list of the options
given after the method-combination name in the
\texttt{:method-combination} option to \texttt{defgeneric}.

Since a new instance is created each time, two different generic
function that, when created, were given the same method-combination
name and the same method-combination arguments, will have two
different instances of the class \texttt{method-combination}.

\subsection{\clasp{}}

\clasp{} is a \commonlisp{} implementation based on \ecl{} (See
\refSec{sec-ecl}), although all the \clanguage{} code in \ecl{} was
rewritten in \cplusplus{}.

A large part of the \commonlisp{} code in \clasp{} is identical or
near-identical to the corresponding code in \ecl{}, and that includes
the code for handling method combinations.  As a result, \clasp{}
handles method combinations in exactly the same way as \ecl{}.
