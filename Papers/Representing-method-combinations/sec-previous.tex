\section{Previous work}

\subsection{\pcl{}}
\label{sec-pcl}

Portable Common Loops, \pcl{} for short, is a library that implements
the functions defined in the book ``The Art of the Metaobject
Protocol'' \cite{Kiczales:1991:AMP:574212}, and is meant as an add-on
to pre-standard \commonlisp{} implementations, i.e., implementations
without \clos{}.

Most \commonlisp{} implementations that exist today were initially
written before the standard was published, and many of those
implementations chose to use \pcl{} to incorporate \clos{}
functionality, though frequently, the code has since been adapted for
each specific implementation.

\pcl{} unsurprisingly defines the class \texttt{method\--combination}
and then the class \texttt{standard\--method\--combination} as a
subclass of the class named \texttt{method\--combination}.

More surprisingly, it then defines two subclasses of the class
\texttt{standard\--method\--combination}, namely
\texttt{long\--method\-combination} and
\texttt{short\--method\--combination}, each for use with the different
forms (long and short) of the macro
\texttt{define\-method\--combination}.

\subsection{\sbcl{}}

The \sbcl{} \commonlisp{} implementation uses a heavily modified
version of \pcl{} (See \refSec{sec-pcl}).  Prior to April of 2018,
\sbcl{} used the unmodified technique from \pcl{} as described in
\refsec{sec-pcl}.  The technique described in this section is a result
of significant modifications to the code for handling method
combinations.  An article by Didier Verna \cite{verna.18.els}
published at ELS in April of 2018 contained a detailed description of
the technique used by \sbcl{} at that time.  Perhaps the improvements
to \sbcl{} were a result of the descriptions in this article.

An invocation of \texttt{define-method-combination} does not create
any new class.  Instead, an \emph{info} structure is created, and
stored in a hash table that uses the name of the method-combination
type as a key.  This info structure contains a \emph{cache}, which is
an association list.  The key of an element of the association list is
a list of options for the method combination, and the value of an
element is the method-combination object.  Initially, the cache is
empty, except for the info structure associated with the
\texttt{standard} method combination.

The function \texttt{find-method-combination} is given the
method-combination name and the desired options.  It looks up the
appropriate info structure, and searches the cache for an element
corresponding to the options.  If such an element is found, the
method-combination object is returned.  If no element is found, a new
one is constructed, pushed on the cache, and returned.  The new
element is constructed by consing the list of options and the result
of applying a \emph{constructor function} to the list of options.
This constructor function is stored in a slot in the info structure.
As a result, existing method-combination instances are reused whenever
possible.  However, the reuse is not perfect.  Consider the following
definition of a method combination:

{\small\begin{verbatim}
(define-method-combination my-and
    (&key (order :most-specific-first)
          (exclude-around :t))
  ((around (:around))
   (primary (and) :order order :required t))
  (let ((form `(and ,@(mapcar
                        #'(lambda (method)
                            `(call-method ,method))
                        primary))))
    (if (and around (not exclude-around))
        `(call-method ,(first around)
                      (,@(rest around)
                       (make-method ,form)))
                 form)))
\end{verbatim}}

It differs from from the built-in \texttt{and} method combination type
in that it has two options, and that those options are defined as
keyword parameters rather than optional parameters.

Now, if we define the following two generic functions using this
method combination:

{\small\begin{verbatim}
(defgeneric ff (x)
  (:method-combination my-and
      :order :most-specific-first
      :exclude-around nil))

(defgeneric gg (x)
  (:method-combination my-and
      :exclude-around nil
      :order :most-specific-first))
\end{verbatim}}

\noindent
then these two functions do not have the same method combination, as
the following experiment shows:

{\small\begin{verbatim}
(eq (sb-mop:generic-function-method-combination #'ff)
    (sb-mop:generic-function-method-combination #'gg))
=> NIL
\end{verbatim}}

The reason for the two being different is that the method combination
is identified by the ordered list of options, and the lists are
different for the different \texttt{defgeneric} forms.

When a generic function is defined with one of the built-in method
combinations, \sbcl{} will check that the options given to the
\texttt{:method-combination} \texttt{defgeneric} option are valid.
This verification is done by special-purpose code.  However, with a
user-defined method combination, no verification is made.  It is only
when an attempt is made to invoke the generic function that the
function resulting from the custom method combination is invoked, and
the incompatible lambda lists are detected.  Furthermore, the error
message is very general and can be difficult to decipher by the
programmer.

\sbcl{} handles re-evaluation of \texttt{define-method-combination}
forms with the name of an existing info entry in the hash table.
Every method-combination instance contains a list of back pointers to
generic functions that use this method combination.  The cache of the
existing info entry is traversed, and for each method combination, the
effective methods of its generic functions are invalidated.

\subsection{\ecl{}}
\label{sec-ecl}

The \ecl{} \commonlisp{} implementation defines the class
\texttt{method-combination}, and method-combination metaobjects are
direct instances of this class, which is not conforming.

The macro \texttt{define-method-combination} does not define a method
combination, nor a new method-combination class.  Instead it defines a
function that we will call the \emph{method-combination function}.
This function computes the effective method of a generic function.
The lambda list of the method-combination function consists of two
required parameters, namely a generic function and a list of
applicable methods, followed by the lambda list given to
\texttt{define-method-combination}.  That lambda list will contain
\texttt{\&optional (order :most-specific-first)} for most built-in
method-combination types.  The resulting function is stored in a hash
table with the name of the method-combination type as a key.

When a generic function is created, a new instance of the
\texttt{method-combination} class is created.  The new instance
contains the method-combination function and a list of the options
given after the method-combination name in the
\texttt{:method-combination} option to \texttt{defgeneric}.

Since a new instance is created each time, two different generic
function that, when created, were given the same method-combination
name and the same method-combination arguments, will have two
different instances of the class \texttt{method-combination}.

\subsection{\clasp{}}

\clasp{} is a \commonlisp{} implementation based on \ecl{} (See
\refSec{sec-ecl}), although all the \clanguage{} code in \ecl{} was
rewritten in \cplusplus{}.

A large part of the \commonlisp{} code in \clasp{} is identical or
near-identical to the corresponding code in \ecl{}, and that includes
the code for handling method combinations.  As a result, \clasp{}
handles method combinations in exactly the same way as \ecl{}.
