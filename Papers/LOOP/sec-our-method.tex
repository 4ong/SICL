\section{Our technique}

In order to parse \texttt{loop} clauses We use a simplified version%
\footnote{It is simplified because we do not need the full
  backtracking power of combinator parsing.}
of a parsing technique known as \emph{combinator parsing}
\cite{Wadler:1985:RFL:5280.5288}.

With this parsing technique, client code defines \emph{elementary
  parsers} that are then combined using combinators such as
\emph{alternative} and \emph{sequence}.  The resulting parser code is
\emph{modular} in that individual parsers do not have to be listed in
one single place.  For the \texttt{loop} clauses, this modularity
means that each type of clause can be defined in a different module.

Initially, the \texttt{loop} body is parsed as a sequence of
individual \texttt{loop} clauses, without any consideration for the
order between those clauses.  A failure to parse during this phase
will manifest itself as an error relating to a particular clause,
whether it is in a valid position or not.  Furthermore, ignoring
restrictions on clause ordering allows us to check the syntax of each
clause.  If order had been taken into account, we would either have to
abandon the parsing phase when a syntactically correct clause were
found in the wrong position and thereby being unable to verify
subsequent clauses, or else we would have to implement some
sophisticated error recovery, allowing the parsing process to continue
after a failure.

The result of the initial parsing process is a list of clauses, where
each clause has been turned into a standard instance%
\footnote{We avoid using language such as ``an instance of a \clos{}
  class'' since all classes are \clos{} classes and therefore all
  \commonlisp{} objects are instances of \clos{} classes.  A
  ``standard instance'' representing a \texttt{loop} clause is created
  by calling \texttt{make-instance} on a class defined by
  \texttt{defclass}.}
