\section{Our technique}
\label{sec-our-technique}

\subsection{Parsing clauses}
\label{sec-our-technique-parsing-clauses}

In order to parse \texttt{loop} clauses We use a simplified version%
\footnote{It is simplified because we do not need the full
  backtracking power of combinator parsing.}
of a parsing technique known as \emph{combinator parsing}
\cite{Wadler:1985:RFL:5280.5288}.

With this parsing technique, client code defines \emph{elementary
  parsers} that are then combined using combinators such as
\emph{alternative} and \emph{sequence}.  The resulting parser code is
\emph{modular} in that individual parsers do not have to be listed in
one single place.  For the \texttt{loop} clauses, this modularity
means that each type of clause can be defined in a different module.

In our parsing framework, an individual parser is an ordinary
\commonlisp{} function that takes a list of \commonlisp{} expressions
and that returns three values:

\begin{enumerate}
\item A generalized Boolean indicating whether the parse succeeded.
\item The result of the parse.  If the parse does not succeed, then
  this value is unspecified.
\item A list of the tokens that remain after the parse.  If the
  parse does not succeed, then this list contains the original
  list of tokens passed as an argument.
\end{enumerate}

Initially, the \texttt{loop} body is parsed as a sequence of
individual \texttt{loop} clauses, without any consideration for the
order between those clauses.  A failure to parse during this phase
will manifest itself as an error relating to a particular clause,
whether it is in a valid position or not.  Furthermore, ignoring
restrictions on clause ordering allows us to check the syntax of each
clause.  If order had been taken into account, we would either have to
abandon the parsing phase when a syntactically correct clause were
found in the wrong position and thereby being unable to verify
subsequent clauses, or else we would have to implement some
sophisticated error recovery, allowing the parsing process to continue
after a failure.

\subsection{Representing parsed clauses}
\label{sec-our-technique-representing-parsed-clauses}

The result of the initial parsing process is a list of clauses, where
each clause has been turned into a standard instance.%
\footnote{We avoid using language such as ``an instance of a \clos{}
  class'' since all classes are \clos{} classes and therefore all
  \commonlisp{} objects are instances of \clos{} classes.  A
  ``standard instance'' representing a \texttt{loop} clause is created
  by calling \texttt{make-instance} on a class defined by
  \texttt{defclass}.}

The classes representing different clause are organized into a graph
that that mostly mirrors the names and descriptions of different
clause types defined by the \commonlisp{} standard.

So for example, the class named \texttt{main-clause} is
the root class of all clauses of that type mentioned in the standard.
The same is true for \texttt{variable-clause}, \texttt{name-clause},
etc.

This organization allows us to capture commonalities between different
clause types by defining methods on generic functions that are
specialized to the appropriate class in this graph.

In addition to representing each clause as a standard instance, we
also represent the \texttt{loop} body itself as an instance of the
class named \texttt{loop-body}.  This instance contains a list of all
the clauses, but also other information, in particular about default
accumulation for this call to the \texttt{loop} macro.

\subsection{Semantic analysis}
\label{sec-our-technique-semantic-analysis}

We use generic functions to analyze the contents of the parsed
clauses, and to generate code from them.  The reason for using generic
functions is again one of modularity.  A method specialized to a
particular clause type, represented by a particular standard class,
can be physically close to other code related that clause type.

Checking the validity of the order between clauses is done in the
first step of the \emph{semantic analysis}, allowing us to signal
pertinent error conditions if the restrictions concerning the order of
clauses are not respected.

\subsection{Code generation}
\label{sec-our-technique-code generation}

\subsection{Tests}
\label{sec-our-technique-tests}

Our code has been thoroughly tested.  The code for testing contains
almost $5000$ lines.  This code has been taken from the Paul Dietz'
ANSI test suite%
\footnote{See: https://gitlab.common-lisp.net/groups/ansi-test}
and adapted to our needs.  In particular, we had to remove some tests
that did not conform to the standard, and we added tests where the
test suite omitted to test potentially non-conforming behavior.
