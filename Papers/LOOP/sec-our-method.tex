\section{Our technique}
\label{sec-our-technique}

\subsection{Parsing clauses}
\label{sec-our-technique-parsing-clauses}

In order to parse \texttt{loop} clauses We use a simplified version%
\footnote{It is simplified because we do not need the full
  backtracking power of combinator parsing.}
of a parsing technique known as \emph{combinator parsing}
\cite{Wadler:1985:RFL:5280.5288}.

With this parsing technique, client code defines \emph{elementary
  parsers} that are then combined using combinators such as
\emph{alternative} and \emph{sequence}.  The resulting parser code is
\emph{modular} in that individual parsers do not have to be listed in
one single place.  For the \texttt{loop} clauses, this modularity
means that each type of clause can be defined in a different module.

Initially, the \texttt{loop} body is parsed as a sequence of
individual \texttt{loop} clauses, without any consideration for the
order between those clauses.  A failure to parse during this phase
will manifest itself as an error relating to a particular clause,
whether it is in a valid position or not.  Furthermore, ignoring
restrictions on clause ordering allows us to check the syntax of each
clause.  If order had been taken into account, we would either have to
abandon the parsing phase when a syntactically correct clause were
found in the wrong position and thereby being unable to verify
subsequent clauses, or else we would have to implement some
sophisticated error recovery, allowing the parsing process to continue
after a failure.

\subsection{Representing parsed clauses}
\label{sec-our-technique-representing-parsed-clauses}

The result of the initial parsing process is a list of clauses, where
each clause has been turned into a standard instance.%
\footnote{We avoid using language such as ``an instance of a \clos{}
  class'' since all classes are \clos{} classes and therefore all
  \commonlisp{} objects are instances of \clos{} classes.  A
  ``standard instance'' representing a \texttt{loop} clause is created
  by calling \texttt{make-instance} on a class defined by
  \texttt{defclass}.}

We use generic functions to analyze the contents of the parsed
clauses, and to generate code from them.  The reason for using generic
functions is again one of modularity.  A method specialized to a
particular clause type, represented by a particular standard class,
can be physically close to other code related that clause type.

\subsection{Semantic analysis}
\label{sec-our-technique-semantic-analysis}

Checking the validity of the order between clauses is done in the
first step of the \emph{semantic analysis}, allowing us to signal
pertinent error conditions if the restrictions concerning the order of
clauses are not respected.
