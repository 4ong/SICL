\section{Previous work}

Before inlining was applied to so-called ``structured programming
languages'', the technique was applied to languages such as Fortran,
that do not allow recursion, so do not need for subroutines to
allocate their own environments upon entry.  And it was then referred
to as ``open-coding of subroutines''.  Scheifler
\cite{Scheifler:1977:AIS:359810.359830} is probably one of the first
to apply inlining to more modern programming languages, in this case
CLU \cite{Liskov:1977:AMC:359763.359789}.

Ayers et al \cite{Ayers:1997:AI:258915.258928} consider the benefit of
inlining consisting of the elimination of the overhead of a procedure
call to be a ``side benefit'', and we agree.  They cite the main
benefit as the opportunity for more optimizing code transformations
when the code of the called function is exposed in the context of the
calling function.

In their paper, they also mention \emph{cloning} as an alternative to
inlining, i.e., the duplication and specialization of the called
function according to the context of the calling function.  However,
they consider inlining to be strictly superior to cloning in terms of
the possible additional optimizations made possible, so they recommend
cloning only as a means to avoid too large an increase in the code
size, which could slow down subsequent non-linear optimizations.

Most existing work is concerned with determining when inlining is to
be performed, based on some analysis of the benefits as compared to
the penalties in terms of increased compilation time in subsequent
optimization passes.  The inlining technique itself is considered
trivial, or in the words of Chang and Hwy
(\cite{Chang:1989:IFE:73141.74840.1, Chang:1989:IFE:74818.74840.2}) ``The
work required to duplicate the callee is trivial''.

Although the paper by Ayers et al explains that their technique is
applied to intermediate code, the paper contains little information
about the details of the technique.

%%  LocalWords:  inlining optimizations
