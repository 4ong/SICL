\section{Our technique}

In our compiler, source code is first converted to an \emph{abstract
  syntax tree}.  In such a tree, lexical variables and lexical
function names have been converted to unique objects.  When a globally
defined function $F$ is inlined into another function $G$, we simply
incorporate the abstract syntax tree of $F$ as if it were a local
function in $G$.  No alpha renaming is required.

In the second phase, the abstract syntax tree is translated to
intermediate code in the form of a flow graph of instructions.  Our
inlining technique is designed to work on this intermediate
representation.

\subsection{Intermediate code}

The intermediate code on which our technique is designed to work is
called \emph{High-level Intermediate Representation}, or \emph{HIR}
for short.  This representation takes the form of a \emph{flow graph}
of \emph{instructions} as used by many traditional compiler
optimization techniques.  The main difference between HIR and the
intermediate representation used in compilers for lower-level
languages is that in HIR, the only data objects that the instructions
manipulate are \commonlisp{} objects.  Arbitrary computations on
addresses are exposed in a later stage called \emph{Medium-level
  Intermediate Representation}, or \emph{MIR}.

A HIR instruction falls into one of the following categories:

\begin{itemize}
\item Low-level accessors such as \texttt{car}, \texttt{cdr},
  \texttt{rplaca}, \texttt{rplacd}, \texttt{aref}, \texttt{aset},
  \texttt{slot-read}, and \texttt{slot-write}.
\item Instructions for low-level arithmetic on, and comparison of,
  floating-point numbers and fixnums.
\item Instructions for testing the type of an object.
\item Instructions such as \texttt{funcall}, \texttt{return}, and
  \texttt{unwind} for handling function calls and returns.
\item The \texttt{enclose} instruction.  This instruction takes the
  \emph{code} of a nested function (represented by its \texttt{enter}
  instruction) and creates a \emph{callable function} that may be a
  \emph{closure}.
\item The \texttt{enter} instruction.  This instruction is the first
  one to be executed in a function, and it is responsible for creating
  the local lexical environment of the function from the arguments
  given by the calling function.
\end{itemize}

Notice that, although the names of these instructions often resemble
the names of \commonlisp{} operations, the instruction typically
requires more precise objects than the corresponding \commonlisp{}
operation does.  Thus, the \texttt{car} instruction requires the
argument to be a \emph{cons} object, and the \texttt{funcall}
instruction requires it first argument to be a function.

\subsection{Algorithm}

Our technique maintains the following information:

\begin{itemize}
\item A mapping from instructions in the called function that have
  already been inlined to the corresponding instructions in the
  calling function.
\item A mapping from lexical variables in the called function that
  have already been duplicated in the calling function.
\item Information about the ownership of lexical variables referred to
  by the called function.
\end{itemize}

The algorithm that implements our technique maintains a
\emph{worklist}.  An item of the worklist contains:

\begin{itemize}
\item A \texttt{funcall} instruction, representing the call site in the
  calling function.
\item An \texttt{enter} instruction, representing the called function.
\item The successor instruction of the \texttt{enter} instruction.
  This instruction is used for generic dispatch.
\item The mapping and ownership information described previously.
\end{itemize}

Before the algorithm starts, assignment instructions are inserted
before the \texttt{funcall} instruction, copying each argument to a
temporary lexical variable.  These lexical variables represent a copy
of the initial environment of the called function, but allocated in
the calling function.  The pair consisting of the \texttt{funcall} and
the \texttt{enter} instruction can be seen as transferring this
environment from the calling function to the called function.

Initially, the worklist contains a single worklist item with the
following contents:

\begin{itemize}
\item The \texttt{funcall} instruction representing the call that
  should be inlined.
\item A \emph{private copy} of the initial \texttt{enter} instruction
  of the function to inline.
\item The successor instruction of the initial \texttt{enter}
  instruction.
\item The initial mapping described previously, as well as
  information about ownership lexical variables.
\end{itemize}

In each iteration of the algorithm, a worklist item is removed from
the worklist, and a generic function is called with four arguments,
representing the contents of the worklist item.  Each iteration may
result in zero, one, or two new worklist items, according to the
mapping and ownership information, and according to the number of
successors of the successor instruction in this contents.

\begin{enumerate}
\item If the next instruction has already been inlined, then replace
  the \texttt{funcall} instruction by the inlined version of the next
  instruction.
\item If the next instruction is a \texttt{return} instruction, then
  replace the \texttt{funcall} instruction by one or more assignment
  instructions mapping inputs of the \texttt{funcall} instruction to
  outputs of that same instruction.
\item If the next instruction has a single successor, insert a copy of
  the next instruction before the \texttt{funcall} instruction, and
  make the \texttt{enter} instruction refer to that successor.  Update
  the inputs of the \texttt{funcall} instruction and the \texttt{enter}
  instruction as described below.
\item If the next instruction has two successors, insert a copy of the
  next instruction before the \texttt{funcall} instruction, and
  replicate the \texttt{funcall} instruction in each branch.  Also
  replicate the \texttt{enter} instruction so that each replica refers
  to a different successor of the original instruction.  Update the
  inputs of the \texttt{funcall} instruction and the \texttt{enter}
  instruction as described below.
\end{enumerate}

\subsection{Example}

As an example of our technique, consider the initial instruction graph
in \refFig{fig41}.  On the left is the calling function.  It has three
lexical variables, namely x, a, and z.  The variable a is referenced by
the called function, but it is owned by the calling function.  The
called function has a single variable named y in its initial lexical
environment.  A temporary variable t2 is created as a result of the
execution of one of the instructions in the called function.

\begin{figure}
\begin{center}
\inputfig{fig41.pdf_t}
\end{center}
\caption{\label{fig41}
Initial instruction graph.}
\end{figure}

Before the inlining procedure is started, we create temporary
variables in the calling function for the variables in the initial
environment of the called function.  We also create a private copy of
the \texttt{enter} instruction so that we can mutate it during the
inlining procedure.  The result is shown in \refFig{fig42}.  Not shown
in the figure is that our mapping now contains an entry for the
lexical variable y of the called function, mapping it to the lexical
variable xx in the calling function.

\begin{figure}
\begin{center}
\inputfig{fig42.pdf_t}
\end{center}
\caption{\label{fig42}
Instruction graph after initialization.}
\end{figure}

As we can see in \refFig{fig42}, An assignment instruction has been
created that copies the value of the lexical variable into a variable
xx that mirrors the initial lexical variable y in the called
function.  We also see that there are now two identical \texttt{enter}
instructions.  The left one of those is the private copy.

Step one of the inlining procedure consists of inlining the successor
of our private \texttt{enter} instruction.  That instruction has a
single successor, and it has not yet been inlined.  Therefore, rule 3
applies, so we insert a copy of that instruction before the
\texttt{funcall} instruction.  Furthermore, since the input to the
original instruction is the lexical variable y, and that variable is
mapped to xx in the calling function, the inlined instruction receives
xx as its input.  The output of the original instruction is the
temporary variable t2 that is not in our mapping.  Therefore a
temporary variable tt2 is created in the calling function, and an
entry is created in the mapping that translates t2 to tt2.  The
private \texttt{enter} instruction is modified so that it now refers
to the next instruction to be considered.  The result of this step is
shown in \refFig{fig43}.

\begin{figure}
\begin{center}
\inputfig{fig43.pdf_t}
\end{center}
\caption{\label{fig43}
Instruction graph after one inlining step.}
\end{figure}

In step two of the inlining procedure, we are considering inlining an
instruction with two successors.  It has not yet been inlined, so rule
number 4 applies.  As rule number 4 stipulates, we must replicate both
the \texttt{enter} instruction and the \texttt{funcall} instruction.
The result is shown in \refFig{fig44}.

\begin{figure}
\begin{center}
\inputfig{fig44.pdf_t}
\end{center}
\caption{\label{fig44}
Instruction graph after two inlining steps.}
\end{figure}

Notice that in \refFig{fig44}, the leftmost \texttt{funcall}
instruction goes with the rightmost \texttt{enter} instruction.

In step three of the inlining procedure, we consider the rightmost
\texttt{funcall} instruction.  The corresponding \texttt{enter}
instruction has a \texttt{return} instruction as its successor, so
rule number 2 applies.  We must therefore replace the \texttt{funcall}
instruction by an assignment instruction, assigning the value of the
variable tt2 to the variable z.  The result of this operation is shown
in \refFig{fig45}.

\begin{figure}
\begin{center}
\inputfig{fig45.pdf_t}
\end{center}
\caption{\label{fig45}
Instruction graph after three inlining steps.}
\end{figure}

\begin{figure}
\begin{center}
\inputfig{fig46.pdf_t}
\end{center}
\caption{\label{fig46}
Instruction graph after four inlining steps.}
\end{figure}

\begin{figure}
\begin{center}
\inputfig{fig47.pdf_t}
\end{center}
\caption{\label{fig47}
Final instruction graph.}
\end{figure}

%%  LocalWords:  worklist funcall inlining inlined
