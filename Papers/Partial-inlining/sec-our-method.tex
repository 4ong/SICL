\section{Our technique}

In our compiler, source code is first converted to an \emph{abstract
  syntax tree}.  In such a tree, lexical variables and lexical
function names have been converted to unique objects.  When a globally
defined function $F$ is inlined into another function $G$, we simply
incorporate the abstract syntax tree of $F$ as if it were a local
function in $G$.  No alpha renaming is required.

In the second phase, the abstract syntax tree is translated to
intermediate code in the form of a flow graph of instructions.  Our
inlining technique is designed to work on this intermediate
representation.

\subsection{Intermediate code}

The intermediate code on which our technique is designed to work is
called \emph{High-level Intermediate Representation}, or \emph{HIR}
for short.  This representation takes the form of a \emph{flow graph}
of \emph{instructions} as used by many traditional compiler
optimization techniques.  The main difference between HIR and the
intermediate representation used in compilers for lower-level
languages is that in HIR, the only data objects that the instructions
manipulate are \commonlisp{} objects.  Arbitrary computations on
addresses are exposed in a later stage called \emph{Medium-level
  Intermediate Representation}, or \emph{MIR}.

A HIR instruction falls into one of the following categories:

\begin{itemize}
\item Low-level accessors such as \texttt{car}, \texttt{cdr},
  \texttt{rplaca}, \texttt{rplacd}, \texttt{aref}, \texttt{aset},
  \texttt{slot-read}, and \texttt{slot-write}.
\item Instructions for low-level arithmetic on, and comparison of,
  floating-point numbers and fixnums.
\item Instructions for testing the type of an object.
\item Instructions such as \texttt{funcall}, \texttt{return}, and
  \texttt{unwind} for handling function calls and returns.
\item The \texttt{enclose} instruction.  This instruction takes the
  \emph{code} of a nested function (represented by its \texttt{enter}
  instruction) and creates a \emph{callable function} that may be a
  \emph{closure}.
\item The \texttt{enter} instruction.  This instruction is the first
  one to be executed in a function, and it is responsible for creating
  the local lexical environment of the function from the arguments
  given by the calling function.
\end{itemize}

Notice that, although the names of these instructions often resemble
the names of \commonlisp{} operations, the instruction typically
requires more precise objects than the corresponding \commonlisp{}
operation does.  Thus, the \texttt{car} instruction requires the
argument to be a \emph{cons} object, and the \texttt{funcall}
instruction requires it first argument to be a function.

\subsection{Algorithm}

Our technique maintains the following information:

\begin{itemize}
\item A mapping from instructions in the called function that have
  already been inlined to the corresponding instructions in the
  calling function.
\item A mapping from lexical variables in the called function that
  have already been duplicated in the calling function.
\item Information about the ownership of lexical variables referred to
  by the called function.
\end{itemize}

The algorithm that implements out technique maintains a
\emph{worklist}.  An item of the worklist contains:

\begin{itemize}
\item A \texttt{funcall} instruction, representing the call site in the
  calling function.
\item An \texttt{enter} instruction, representing the called function.
\item The successor instruction of the \texttt{enter} instruction.
  This instruction is used for generic dispatch.
\item The mapping and ownership information described previously.
\end{itemize}

\begin{itemize}
\item If the next instruction has already been inlined, then replace
  the \texttt{funcall} instruction by the inlined version of the next
  instruction.
\item If the next instruction is a \texttt{return} instruction, then
  replace the \texttt{funcall} instruction by one or more assignment
  instructions mapping inputs of the \texttt{funcall} instruction to
  outputs of that same instruction.
\item If the next instruction has a single successor, insert a copy of
  the next instruction before the \texttt{funcall} instruction, and
  make the \texttt{enter} instruction refer to that successor.  Update
  the inputs of the \texttt{call} instruction and the \texttt{enter}
  instruction as described below.
\item If the next instruction has two successors, insert a copy of the
  next instruction before the \texttt{funcall} instruction, and
  replicate the \texttt{call} instruction in each branch.  Also
  replicate the \texttt{enter} instruction so that each replica refers
  to a different successor of the original instruction.  Update the
  inputs of the \texttt{call} instruction and the \texttt{enter}
  instruction as described below.
\end{itemize}

%%  LocalWords:  worklist
