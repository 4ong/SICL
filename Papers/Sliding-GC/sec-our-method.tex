\section{Our method}

Our method uses a \emph{break table} just like the method by Haddon
and Waite, but instead of building, moving, and sorting the table
while objects are moved, we first move the objects and then
construct the table.  For that, additional space in the form of a bit
vector is required.  The bit vector has one bit per word of memory in
the heap, which amounts to less than $2$\% additional memory on a
$64$-bit machine. 

\refFig{fig-example-a} shows a heap in which shaded areas indicate
live objects and white areas indicate dead objects.  The heap contains
16 word as shown by the addresses.  At the bottom of the figure is
shown the bitmap after the mark phase (phase 1) is complete.

\begin{figure}
\begin{center}
\inputfig{fig-example-a.pdf_t}
\end{center}
\caption{\label{fig-example-a}
Example of initial heap.}
\end{figure}

In phase 2, the heap is compacted by sliding the live objects to the
beginning of the heap.  In this phase, 2 pointers are used, a
\emph{source} pointer pointing to words containing live objects, and a
\emph{destination} pointer pointing to words containing dead objects,
as illustrated by \refFig{fig-example-b}.  Words are copied from the
source location to the destination location.  In each iteration, the
destination location is incremented by one unit, whereas the source
location is incremented until either it reaches the end of the heap,
or a word containing a live object as indicated by the bitmap
containing a $1$.

\begin{figure}
\begin{center}
\inputfig{fig-example-b.pdf_t}
\end{center}
\caption{\label{fig-example-b}
Pointers to source and destination locations.}
\end{figure}

\refFig{fig-example-c} shows the situation when phase 2 is complete. 

\begin{figure}
\begin{center}
\inputfig{fig-example-c.pdf_t}
\end{center}
\caption{\label{fig-example-c}
Heap after compaction.}
\end{figure}

In phase 3, a \emph{break table} is built at the position of the
destination pointer.  The break table contains \emph{entries}
consisting of two words each.  The first word of each entry is the
address of the beginning of a zone of dead objects, and the second
word of the entry is the sum of the sizes of the dead zones preceding
it.  \refFig{fig-example-d} shows the break table of the example heap
in \refFig{fig-example-a}.

\begin{figure}
\begin{center}
\inputfig{fig-example-d.pdf_t}
\end{center}
\caption{\label{fig-example-d}
Break table.}
\end{figure}

The break table is built by scanning the bitmap from start to end.  In
practice, since the heap is likely to contain fairly large contiguous
zones, the bitmap will contain long runs of $0$s and long runs of
$1$s.  It is therefore advantageous to scan the bitmap a word at a
time, making this phase quite efficient. 

In phase 4, the lower part of the heap is traversed word by word in
order to adjust the pointers according to the contents of the break
table.  For each pointer value $p$, an entry $e_i = (a_i,b_i)$ is
located such that $p < a_i$ and either $i = 0$ or $a_{i-1} < p$.  The
pointer value $p$ is adjusted by subtracting $b_i$ from it.  To find
the entry, the break table is search using \emph{binary search}.
However, it is very likely that the entry for a particular pointer is
the same as the entry for the pointer immediately preceding it.  By
testing this case first, the vast majority of full binary searches can
be avoided. 

