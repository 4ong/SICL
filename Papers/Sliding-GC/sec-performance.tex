\section{Performance}

It is notoriously hard to test the performance of garbage collection
algorithms.  Nevertheless, we would like to get some idea of the time
the various phases take.  To that end, we created a few test cases
which (together with some educated guesses) will give us some ballpark
figures with respect to performance of our method, at least as
compared to other methods. 

For our tests, we chose a heap size of $2^{19}$ words of $8$ bytes
each.  This heap size was not chosen randomly.  It was chosen so that
the entire heap would fit in the cache memory of the computer used for
the tests (x86-64, GNU/Linux, SBCL), and research
\cite{Marlow:2011:MGC:2076022.1993482} indicates that a nursery this
size is a good choice.

Thus, we have the following definitions valid for all the tests:

{\small\begin{verbatim}
(defparameter *size* (ash 1 19))

(defparameter *heap* (make-array *size*))

(defparameter *bitmap*
  (make-array *size* :element-type 'bit))
\end{verbatim}}


\subsection{Phase 1, marking}

We did not attempt to test the marking phase, because it is no
different from the marking phase of any other algorithm.

\subsection{Phase 2, compaction}

To test the compaction phase, we wrote the following compaction
program:

{\small\begin{verbatim}
(defun move (heap bitmap)
  (declare (type (simple-vector #.*size*) heap)
           (type (array bit (#.*size*)) bitmap)
           (optimize (speed 3) (safety 0) (debug 0)))
  (let* ((d (position 0 bitmap))
         (s (position 1 bitmap :start d)))
    (declare (type (integer 0 #.*size*) d s))
    (loop until (= s #.*size*)
          do (setf (aref heap d) (aref heap s))
             (incf d)
             (incf s)
             (loop until (or (= s #.*size*)
                             (= (sbit bitmap s) 1))
                   do (incf s)))))
\end{verbatim}}

The hypothesis here is that the time consumed by the compaction phase
is determined by $2$ elements:

\begin{enumerate}
\item A constant term that has to do with scanning the bitmap.
\item A term proportional to the number of elements that have to be
  moved.
\end{enumerate}

To test the hypothesis, we executed the function \texttt{move} with
three different bitmaps as shown in the following table:

\begin{tabular}{|r|r|}
\hline
Element count & CPU time (ms)\\
\hline
$1$ & $0.8$ \\
$2^{18}$ & $1.1$\\
$2^{19}-1$ & $1.4$\\
\hline
\end{tabular}

To avoid measuring the performance of the function \texttt{position},
the first line in the table was executed with a bitmap where the
element with index $1$ was equal to $1$.  The second line in the table
was executed with a bitmap where every other element was $1$.  The
third line in the table was executed with a bitmap where only element
$0$ was $0$.  In all cases, the test was run in a loop with $1000$
iterations.  The loop was the argument of the \texttt{time} macro, and
the right column of the table shows the result returned by
\texttt{time} divided by $1000$. 

The hypothesis above seems confirmed where scanning the bitmap seems
to take around $0.8$ms and moving an element seems to take around
$1$ns per element.  

Now, in a typical collection cycle at least around half of the
elements of the heap would be dead (if not, objects would be
\emph{promoted}).  Furthermore, since objects that are allocated
together die together, the bitmap will contain long runs of $0$s and
long runs of $1$s, and because objects either die young or survive a
long time, the bitmap will typically start with a run of $1$s.  A
slightly more clever implementation of the bitmap would then test $64$
bits at a time rather than individual bits like we do in our test.  In
such an implementation, the time for managing the bitmap would be
negligible.  In a typical collection cycle, significantly fewer than
half of the elements would have to be moved.  The expected compaction
time would therefore be closer to $0.3$ms. 

\subsection{Phase 3, building table}

{\small\begin{verbatim}
 (defun build-table (heap bitmap start)
  (let ((address (position 0 bitmap))
        (acc 0))
    (declare 
       (type fixnum address acc start)
       (type (simple-vector #.*size*))
       (type (simple-array bit (#.*size*)) bitmap)
       (optimize (speed 3) (safety 0) (debug 0)))
    (loop until (= address #.*size*)
          do (setf (svref heap start) address)
             (setf (svref heap (1+ start)) acc)
             (incf start 2)
             (let ((pos-1 (position 
                            1 bitmap 
                            :start address)))
               (when (null pos-1)
                 (return start))
               (incf acc (- pos-1 address))
               (setf address 
                     (or (position 0 bitmap 
                                   :start pos-1)
                         #.*size*)))
          finally (setf (svref heap start) address)
                  (setf (svref heap (1+ start)) acc)
                  (return #.*size*))))
\end{verbatim}}
